import "primitives/reshape.fil";

/// The abstract interface for all the conv2d kernels generated by Aetherling
comp Conv2d<'G: 1>(
    in[N]: ['G, 'G+1] 8,
) -> (
    out[N]: ['G+L, 'G+L+1] 8,
) with {
    /// The number of inputs the module accepts. This is always a factor of 16.
    exists N where N > 0, N <= 16, 16 % N == 0;
    /// The latency of the module
    exists L where L > 0;
} { /* Todo */ }

/// The module that interfaces with the outside world which always provides all
/// 16 inputs at the same time and exactly for one cycle.
comp Wrapper<'G: II>(
    valid_up: interface['G],
    I[16]: ['G, 'G+1] 8
) -> (
    O[16]: ['G+L, 'G+L+1] 8
) with {
    /// The latency of the module
    exists L where L > 0;
    /// The initiation interval of the module
    exists II where II > 0;
} {
    // The convolution module.
    C := new Conv2d;
    let Chunks = 16 / C::N;

    // The serializer produces C::N chunks of inputs for the convolution module.
    ser := new Serialize[8, Chunks, C::N]<'G>(I{0..16});

    // Track the outputs of the convolution for deserialization.
    // The liveness this because we send N inputs every cycle and receive them back in L cycles.
    bundle co[16]: for<j> ['G+j/C::N+C::L, 'G+j/C::N+C::L+1] 8;

    // Send the chunks to the conv and collect the outputs
    for i in 0..Chunks {
        // The start time of the chunk inputs
        let Base = i * C::N;
        // Send C::N inputs to the Convolution
        c := C<'G+i>(ser.out{Base..Base+C::N});
        // Assign the outputs to the bundle
        co{Base..Base+C::N} = c.out{0..C::N};
    }

    if Chunks > 1 {
        // The deserializer can start collecting the outputs after the latency of the convolution elapses.
        // It will collect C::N outputs every cycle and produce them at the end.
        de := new Deserialize[8, Chunks, C::N]<'G+C::L>(co{0..16});
        O{0..16} = de.out{0..16};
    } else {
        // No need to deserialize if there is only one chunk.
        O{0..16} = co{0..16};
    }

    // The output latency is determined by the Deserializer.
    exists L = C::L+16/C::N-1;

    // The II is limited by the speed at which the convolution can process the inputs.
    exists II = 16/C::N;
}