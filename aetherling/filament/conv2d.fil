import "primitives/core.fil";
import "primitives/math.fil";

extern "mul.sv" {
    comp BlackBoxMulUInt8<@G: 1>(
        clk: 1,
         I0: [@G, @G+1] 8,
         I1: [@G, @G+1] 8,
    ) -> (
         O: [@G+3, @G+4] 16,
    );
}

comp Filter<G: 1>() -> (
     out[9]: [G, G+1] 8
) {
    one := new Const[8, 1]<G>();
    two := new Const[8, 2]<G>();
    four := new Const[8, 4]<G>();

    out{0} = one.out; out{1} = two.out;  out{2} = one.out;
    out{3} = two.out; out{4} = four.out; out{5} = two.out;
    out{6} = one.out; out{7} = two.out;  out{8} = one.out;
}

// Performs a 2d convolution on a 3x3 window of elements with the filter:
// 1 2 1
// 2 4 2
// 1 2 1
comp Conv<@G: 1>(
     in[9]: [@G, @G+1] 8,
     w[9]: [@G, @G+1] 8,
) -> (
     out: [@G+6, @G+7] 8,
) {
    bundle m[9]: [@G+3, @G+4] 16;
    for #i in 0..9 {
      mult := new BlackBoxMulUInt8<@G>(in{#i}, w{#i});
      m{#i} = mult.O;
    }

    // Add the results
    sum := new ReduceAdd[16, 8]<@G+3>(m{0..8});
    acc := new Shift[16, 3]<@G+3>(m{8});
    red := new Add[16]<@G+6>(sum.out, acc.out);

    // Divide by 16
    four_16 := new Const[16, 4]<@G+6>();
    d := new ShiftRight[16]<@G+6>(red.out, four_16.out);
    slice := new Slice[16, 7, 0, 8]<@G+6>(d.out);

    out = slice.out;
}