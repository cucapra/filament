import "primitives/state.fil";

/// Given 16 inputs, generate N, consecutive 3x3 stencils from it.
comp GetStencils[W, N]<'G:1>(
    in[16]: ['G, 'G+1] W
) -> (
    out[N][3][3]: ['G, 'G+1] W
) where W > 0 {
    // Algorithm: For each stencil, start with the last index, get three
    // consecutive elements, skip one, and get the next three elements.
    /*
        for s in range(0, N):
        last = 16 - s - 1
        for i in range(0, 3):
            for j in range(0, 3):
                print(f"out[{s}][{2-i}][{2-j}] = in[{last - 4*i - j}];")
    */
    zero := new Const[W, 0]<'G>();
    for s in 0..N {
      // The final index
      let last = 16 - s - 1;
      for i in 0..3 {
        for j in 0..3 {
            if last >= 4*i + j {
                out{N-s-1}{2-i}{2-j} = in{last - 4*i - j};
            } else {
                out{N-s-1}{2-i}{2-j} = zero.out;
            }
        }
      }
    }

}

// A 3x3 stencil over a 4x4 matrix. N specifies the number of new inputs
// provided every cycles. This also determines the number of "views" on the
// matrix provided by the component.
comp Stencil[W, S]<'G:1>(
    in[S]: ['G, 'G+1] W
) -> (
    out[S][3][3]: ['G, 'G+1] W
) where W > 0 {
    bundle reg_outs[16]: ['G, 'G+1] W;
    bundle reg_ins[16]: ['G, 'G+1] W;

    // Set up the registers
    for i in 0..16 {
        p := new ContPrev[W, 1]<'G>(reg_ins{i});
        reg_outs{i} = p.prev;
    }

    // Set up the inputs to the register
    // The i'th register gets its value from i+2 register.
    for i in 0..16 {
        if i+S < 16 {
            reg_ins{i} = reg_outs{i+S};
        } else {
            reg_ins{i} = in{i+S-16};
        }
    }

    // Compute both the output stencils
    stencils := new GetStencils[W, S]<'G>(reg_ins{0..16});
    out{0..S}{0..3}{0..3} = stencils.out{0..S}{0..3}{0..3};
}