import "apps/blas/scal/scal.fil";
import "apps/blas/util.fil";

// Performs a*x + y, where x,y are vectors and a is a scalar
// W: Width of nums
// N: Length of vectors
// M: Number of multipliers
// A: Number of adders
comp Axpy[W, N, M, A]<'G:II>(
  go:   interface['G],
  a:    ['G, 'G+1] W,
  x[N]: ['G, 'G+1] W,
  y[N]: ['G, 'G+1] W,
) -> (
  out[N]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
  some II where II > 0;
} where W > 0,
        L > 0,
        N > 0,
        M > 0,
        A > 0
{
  // Perform a*x
  
  let uses = N / M;

  Mults := new Multipliers[W, M] in ['G, 'G + uses*Mults::II];
  // use as many adders as there are multipliers
  Adds := new Adders[W, M];

  let latency = uses*Mults::II + Mults::L;
  L := latency;

  let ii = uses*Mults::II;
  II := ii;

  bundle mult_out[uses][M]: for<k> ['G+k*Mults::II+Mults::L, 'G+k*Mults::II+Mults::L+1] W;
  bundle a_bundle[uses][M]: for<k> ['G+k*Mults::II, 'G+k*Mults::II+1] W;

  for j in 0..uses {
    let mul_start = j*Mults::II;
    let mul_end = j*Mults::II + Mults::L;

    a_reg := new Shift[W, mul_start]<'G>(a);
    y_reg := new Shift[W, mul_end, M]<'G>(y{j*M..(j+1)*M});

    // use inputs
    if j == 0 {
      // fill bundle with `a`
      for i in 0..M {
        a_bundle{j}{i} = a;
      }
      m := Mults<'G+mul_start>(x{j*M..(j+1)*M}, a_bundle{j}{0..M});
      mult_out{j}{0..M} = m.out{0..M};
    }
    // register inputs and use
    else {
      // fill bundle with `a`
      for i in 0..M {
        a_bundle{j}{i} = a_reg.out;
      }
      x_reg := new Shift[W, mul_start, M]<'G>(x{j*M..(j+1)*M});
      m := Mults<'G+mul_start>(x_reg.out{0..M}, a_bundle{j}{0..M});
      mult_out{j}{0..M} = m.out{0..M};
    }

    a := Adds<'G+mul_end>(mult_out{j}{0..M}, y_reg.out{0..M});
    add_reg := new Shift[W, latency - mul_end, M]<'G+mul_end>(a.out{0..M});
    out{j*M..(j+1)*M} = add_reg.out{0..M};
  }
}