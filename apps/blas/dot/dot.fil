import "primitives/math/math.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";
import "primitives/core.fil";
import "apps/blas/util.fil";

comp main<'G:II>(
  go: interface['G],
  x_0: ['G, 'G+1] W,
  x_1: ['G, 'G+1] W,
  x_2: ['G, 'G+1] W,
  x_3: ['G, 'G+1] W,
  x_4: ['G, 'G+1] W,
  x_5: ['G, 'G+1] W,
  x_6: ['G, 'G+1] W,
  x_7: ['G, 'G+1] W,
  x_8: ['G, 'G+1] W,
  x_9: ['G, 'G+1] W,
  x_10: ['G, 'G+1] W,
  x_11: ['G, 'G+1] W,
  x_12: ['G, 'G+1] W,
  x_13: ['G, 'G+1] W,
  x_14: ['G, 'G+1] W,
  x_15: ['G, 'G+1] W,
  y_0: ['G, 'G+1] W,
  y_1: ['G, 'G+1] W,
  y_2: ['G, 'G+1] W,
  y_3: ['G, 'G+1] W,
  y_4: ['G, 'G+1] W,
  y_5: ['G, 'G+1] W,
  y_6: ['G, 'G+1] W,
  y_7: ['G, 'G+1] W,
  y_8: ['G, 'G+1] W,
  y_9: ['G, 'G+1] W,
  y_10: ['G, 'G+1] W,
  y_11: ['G, 'G+1] W,
  y_12: ['G, 'G+1] W,
  y_13: ['G, 'G+1] W,
  y_14: ['G, 'G+1] W,
  y_15: ['G, 'G+1] W,
) -> (
  out: ['G+L, 'G+L+1] W
) with {
  let N = 8;
  let S = 16;
  let W = 32;
  some L where L > 0;
  some II where II > 0;
} where L > 0 {

  Dx := new Dot[W, S, N];

  bundle x[S]: ['G, 'G+1] W;
  bundle y[S]: ['G, 'G+1] W;

  x{0} = x_0; x{1} = x_1; x{2} = x_2; x{3} = x_3; 
  x{4} = x_4; x{5} = x_5; x{6} = x_6; x{7} = x_7;
  x{8} = x_8; x{9} = x_9; x{10} = x_10; x{11} = x_11;
  x{12} = x_12; x{13} = x_13; x{14} = x_14; x{15} = x_15;

  y{0} = y_0; y{1} = y_1; y{2} = y_2; y{3} = y_3; 
  y{4} = y_4; y{5} = y_5; y{6} = y_6; y{7} = y_7;
  y{8} = y_8; y{9} = y_9; y{10} = y_10; y{11} = y_11;
  y{12} = y_12; y{13} = y_13; y{14} = y_14; y{15} = y_15;

  d := Dx<'G>(x{0..S}, y{0..S});

  out = d.out;

  L := Dx::L;
  II := Dx::II;
}

// W: Width of nums
// S: Size of vectors
// N: Number of multipliers
comp Dot[W, S, N]<'G:II>(
  go: interface['G],
  x[S]: ['G, 'G+1] W,
  y[S]: ['G, 'G+1] W
) -> (
  out: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
  some II where II > 0;
} where W > 0,
        L > 0,
        S > 0
{

  let reuses = S / N;

  M := new Multipliers[W, N] in ['G, 'G + reuses*M::II];
  RA := new RAdd[W, N] in ['G + M::L, 'G + reuses*M::II + M::L];

  // needed for typechecking
  assume RA::L == log2(N);

  let latency = reuses*M::II+M::L + RA::L;
  L := latency;

  let ii = reuses*M::II;
  II := ii;

  bundle mult_out[reuses][N]: for<k> ['G+k*M::II+M::L, 'G+k*M::II+M::L+1] W;
  bundle add_out[reuses]: for<q> ['G + q*M::II + M::L + RA::L, 'G + q*M::II + M::L + RA::L + 1] W;
  
  P := new Prev[W, 1];
  FA := new Add[W];

  for j in 0..reuses {

    let mul_start = j*M::II;
    let mul_end = j*M::II + M::L;
    let last_add_start = j*M::II + M::L + RA::L;

    // first use can use raw inputs
    if j == 0 {
      m := M<'G+mul_start>(x{j*N..(j+1)*N}, y{j*N..(j+1)*N});
      mult_out{j}{0..N} = m.out{0..N};
    // any other use should use registered inputs
    } else {
      x_reg := new Shift[W, mul_start, N]<'G>(x{j*N..(j+1)*N});
      y_reg := new Shift[W, mul_start, N]<'G>(y{j*N..(j+1)*N});
      m := M<'G+mul_start>(x_reg.out{0..N}, y_reg.out{0..N});
      mult_out{j}{0..N} = m.out{0..N};
    }

    ra := RA<'G+mul_end>(mult_out{j}{0..N});
    add_out{j} = ra.out;

    // do the additions as they come in
    if j == 0 {
      zero := new Const[W, 0]<'G+last_add_start>();
      add := FA<'G+last_add_start>(zero.out, add_out{j});
      prev := P<'G+last_add_start>(add.out);
    } else {
      add := FA<'G+last_add_start>(prev.prev, add_out{j});
      prev := P<'G+last_add_start>(add.out);
    }
  }

  final := P<'G+latency>(final.prev);
  out = final.prev;
}

// Addition-based reduction tree with latency, II as output params
comp RAdd[W, N]<'G:1>(
    in[N]: for<i> ['G, 'G+1] W
) -> (
     out: ['G+K, 'G+K+1] W
) with {
  let K = log2(N);
  some L where L >= 0;
  some II where II > 0;
} where W >= 1,
        N >= 1,
        K == log2(N),
        K >= 0
{
    L := K;
    II := 1;

    if N == 1 {
        out = in{0};
    } else {
        // Required to make recursive calls type check.
        assert K-1 == log2(N/2);
        // This is a corollary of K != 0
        assert N >= 2;
        // This is not true in general for integer division but
        // because N is a power of 2 it is true.
        assert N - N/2 == N/2;

        left := new RAdd[W, N/2]<'G>(in{0..N/2});
        right := new RAdd[W, N/2]<'G>(in{N/2..N});
        add := new Add[W]<'G+K-1>(left.out, right.out);
        d := new Delay[W]<'G+K-1>(add.out);
        out = d.out;
    }
}