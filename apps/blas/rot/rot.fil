comp Rot[W, N, M, A]<'G:II>(
  go: interface['G],
  c: ['G, 'G+1] W,
  s: ['G, 'G+1] W,
  x[N]: ['G, 'G+1] W,
  y[N]: ['G, 'G+1] W,
) -> (
  out_x[N]: ['G+L, 'G+L+1] W,
  out_y[N]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
  some II where II > 0;
} where W > 0,
        L > 0,
        N > 0,
        M > 0,
        A > 0
{

  scale := new Scal[W, N, M];
  let scale_latency = scale::L;
  let scale_ii = scale::II;

  bundle cy[N]: ['G+scale_latency, 'G+scale_latency+1] W;
  scale_y := scale<'G>(y{0..N}, c);

  bundle sy[N]: ['G+scale_latency, 'G+scale_latency+1] W;

  L := 0;
  II := 1;

  out_x{0..N} = x{0..N};
  out_y{0..N} = y{0..N};
}