import "apps/blas/util.fil";

// Computes alpha * x * x^T + A in one cycle, where:
// alpha is a scalar
// x is a vector of length N
// A is a symmetric matrix
// W: width of nums
// N: length of vector
comp Syr_1_1[W, N]<'G:II>(
  go: interface['G],
  alpha: ['G, 'G+1] W,
  x[N]: ['G, 'G+1] W,
  A[N][N]: ['G, 'G+1] W
) -> (
  A_out[N][N]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
  some II where II > 0;
} where W > 0,
        N > 0
{
  assume Mults::L > mult_uses*Mults::II;

  let mult_uses = N / 1;
  let add_uses = N / 1;
  // in ['G, 'G+7];
  Mults := new Multipliers[W, 1] in ['G, 'G + Mults::L + (mult_uses*mult_uses)];
  Adds := new Adders[W, 1] in ['G + Mults::L + Mults::L, 'G + Mults::L + Mults::L + N*N];

  bundle alpha_x[mult_uses][1]: for<k> ['G+k+Mults::L, 'G+k+Mults::L+1] W;

  // alpha * x stage
  for i in 0..mult_uses {
    let mult_start = i;
    let mult_end = i + Mults::L;

    alpha_reg := new Shift[W, mult_start]<'G>(alpha);
    bundle alpha_bundle[1]: for<k> ['G+mult_start, 'G+mult_start+1] W;

    if i == 0 {
      for j in 0..1 {
        alpha_bundle{j} = alpha;
      }
      m := Mults<'G+mult_start>(x{i..(i+1)}, alpha_bundle{i..(i+1)});
      alpha_x{i}{0..1} = m.out{0..1};
    } else {
      alpha_reg := new Shift[W, mult_start]<'G>(alpha);
      for j in 0..1 {
        alpha_bundle{j} = alpha_reg.out;
      }
      x_reg := new Shift[W, mult_start, 1]<'G>(x{i..(i+1)});
      m := Mults<'G+mult_start>(x_reg.out{0..1}, alpha_reg.out{0..1});
      alpha_x{i}{0..1} = m.out{0..1};
    }
  }

  // (alpha*x) * x^T stage
  bundle vec_mult[N*N][1]: for<k> ['G+k+Mults::L + Mults::L, 'G+k+Mults::L +Mults::L+1] W;

  // each iteration corresponds to computing a row in resulting vector
  for i in 0..N {
    let second_mult_start = i+Mults::L; // latency is 3, so first packet ready after 3 cycles
    // for each mult use, 
    for j in 0..mult_uses {
      let offset = i*(mult_uses-1);
      x_reg := new Shift[W, i*N+j+Mults::L, 1]<'G>(x{j});
      alpha_x_reg := new Shift[W, i*N+j+Mults::L-second_mult_start, 1]<'G+second_mult_start>(alpha_x{i}{0..1});

      mult := Mults<'G+i*N+j+Mults::L>(alpha_x_reg.out{0..1}, x_reg.out{0..1});
      vec_mult{i*N+j}{0..1} = mult.out{0..1};
    }
  }

  // N = 2
  // MultsN = 1
  // mult_uses = 2
  // ax0 happens at G+0, done at G+3
  // ax1 happens at G+1, done at G+4
  // ax0 * x0 happens at G+3, done at G+6
  // ax0 * x1 happens at G+4, done at G+7
  // ax1 * x0 happens at G+5, done at G+8
  // ax1 * x1 happens at G+6, done at G+9

  bundle matrix_add[N*N][1]: for<k> ['G+k+Mults::L+Mults::L, 'G+k+Mults::L+Mults::L+1] W;

  // add stage
  for i in 0..N {
    for j in 0..add_uses {
      a_reg := new Shift[W, i*N+j+Mults::L + Mults::L, 1]<'G>(A{i}{j});
      add := Adds<'G+i*N+j+Mults::L + Mults::L>(vec_mult{i*N+j}{0..1}, a_reg.out{0..1});
      matrix_add{i*N+j}{0..1} = add.out{0..1};
    }
  }

  // i   j   i*N+j
  // 0   0     0
  // 0   1     1
  // 1   0     2
  // 1   1     3

  // synchronize everything
  let latency = Mults::L + Mults::L + N*N-1;
  for i in 0..N {
    for j in 0..N {
      reg := new Shift[W, latency - (i*N+j+Mults::L + Mults::L), 1]<'G+i*N+j+Mults::L + Mults::L>(matrix_add{i*N+j}{0..1});
      A_out{i}{j} = reg.out{0..1};
    }
  }

  L := latency;
  II := Mults::L + (mult_uses*mult_uses);
}