import "apps/blas/util.fil";

// Computes alpha * x * x^T + A in one cycle, where:
// alpha is a scalar
// x is a vector of length N
// A is a symmetric matrix
// W: width of nums
// N: length of vector
comp Syr_Gen[W, N, MultsN]<'G:II>(
  go: interface['G],
  alpha: ['G, 'G+1] W,
  x[N]: ['G, 'G+1] W,
  A[N][N]: ['G, 'G+1] W
) -> (
  A_out[N][N]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
  some II where II > 0;
} where W > 0,
        N > 0,
        N % MultsN == 0
{
  assume Mults::L > mult_uses*Mults::II;

  let mult_uses = N / MultsN;
  let add_uses = N / MultsN;
  // in ['G, 'G+7];
  Mults := new Multipliers[W, MultsN] in ['G, 'G + Mults::L + (mult_uses*N*Mults::II)];
  Adds := new Adders[W, MultsN] in ['G + Mults::L + Mults::L, 'G + Mults::L + Mults::L + mult_uses*N];

  bundle alpha_x[mult_uses][MultsN]: for<k> ['G+k+Mults::L, 'G+k+Mults::L+1] W;

  // alpha * x stage
  for i in 0..mult_uses {
    let mult_start = i;
    let mult_end = i + Mults::L;

    alpha_reg := new Shift[W, mult_start]<'G>(alpha);
    bundle alpha_bundle[MultsN]: for<k> ['G+mult_start, 'G+mult_start+1] W;

    if i == 0 {
      for j in 0..MultsN {
        alpha_bundle{j} = alpha;
      }
      m := Mults<'G+mult_start>(x{i*MultsN..(i+1)*MultsN}, alpha_bundle{0..MultsN});
      alpha_x{i}{0..MultsN} = m.out{0..MultsN};
    } else {
      alpha_reg := new Shift[W, mult_start]<'G>(alpha);
      for j in 0..MultsN {
        alpha_bundle{j} = alpha_reg.out;
      }
      x_reg := new Shift[W, mult_start, MultsN]<'G>(x{i*MultsN..(i+1)*MultsN});
      m := Mults<'G+mult_start>(x_reg.out{0..MultsN}, alpha_bundle{0..MultsN});
      alpha_x{i}{0..MultsN} = m.out{0..MultsN};
    }
  }

  // (alpha*x) * x^T stage
  bundle vec_mult[N*mult_uses][MultsN]: for<k> ['G+k+Mults::L + Mults::L, 'G+k+Mults::L +Mults::L+1] W;

  // each iteration corresponds to computing a row in resulting vector
  for i in 0..N {
    for j in 0..mult_uses {
      let second_mult_start = j+Mults::L; // latency is 3, so first packet ready after 3 cycles
      x_reg := new Shift[W, i*mult_uses+j+Mults::L, 1]<'G>(x{i});

      bundle x_i[MultsN]: ['G+i*mult_uses+j+Mults::L, 'G+i*mult_uses+j+Mults::L+1] W;
      for k in 0..MultsN {
        x_i{k} = x_reg.out{0..1};
      }

      alpha_x_reg := new Shift[W, i*mult_uses+j+Mults::L-second_mult_start, MultsN]<'G+second_mult_start>(alpha_x{j}{0..MultsN});

      mult := Mults<'G+i*mult_uses+j+Mults::L>(alpha_x_reg.out{0..MultsN}, x_i{0..MultsN});
      vec_mult{i*mult_uses+j}{0..MultsN} = mult.out{0..MultsN};
    }
  }

  // N = 2
  // MultsN = 1
  // mult_uses = 2
  // ax0 happens at G+0, done at G+3
  // ax1 happens at G+1, done at G+4
  // ax0 * x0 happens at G+3, done at G+6
  // ax0 * x1 happens at G+4, done at G+7
  // ax1 * x0 happens at G+5, done at G+8
  // ax1 * x1 happens at G+6, done at G+9

  // N = 2
  // MultsN = 2
  // mult_uses = 1
  // ax0 happens at G+0, done at G+3
  // ax1 happens at G+0, done at G+3
  // ax0 * x0 happens at G+3, done at G+6
  // ax0 * x1 happens at G+3, done at G+6
  // ax1 * x0 happens at G+4, done at G+7
  // ax1 * x1 happens at G+4, done at G+7

  bundle matrix_add[N*mult_uses][MultsN]: for<k> ['G+k+Mults::L+Mults::L, 'G+k+Mults::L+Mults::L+1] W;

  // add stage
  for i in 0..N {
    for j in 0..add_uses {
      a_reg := new Shift[W, i*mult_uses+j+Mults::L + Mults::L, MultsN]<'G>(A{i}{j*MultsN..(j+1)*MultsN});
      add := Adds<'G+i*mult_uses+j+Mults::L + Mults::L>(vec_mult{i*mult_uses+j}{0..MultsN}, a_reg.out{0..MultsN});
      matrix_add{i*mult_uses+j}{0..MultsN} = add.out{0..MultsN};
    }
  }

  // i   j   i*N+j
  // 0   0     0
  // 0   1     1
  // 1   0     2
  // 1   1     3

  // synchronize everything
  let latency = Mults::L + Mults::L + N*mult_uses-1;
  for i in 0..N {
    for j in 0..add_uses {
      reg := new Shift[W, latency - (i*mult_uses+j+Mults::L + Mults::L), MultsN]<'G+i*mult_uses+j+Mults::L + Mults::L>(matrix_add{i*mult_uses+j}{0..MultsN});
      A_out{i}{j*MultsN..(j+1)*MultsN} = reg.out{0..MultsN};
    }
  }

  L := latency;
  II := Mults::L + (mult_uses*N*Mults::II);
}