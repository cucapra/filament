
import "primitives/reshape.fil";

extern "spiral-fft-2.v" {
  // 16 point fft generated by spiral
  comp dft_top_2<'G: 105>(
    next: interface['G], // everything delayed by 1 because next refers to the next cycle
    clk: 1,
    reset: 1,
    X0: ['G+1, 'G+3] 32, // real part of first input
    X1: ['G+1, 'G+3] 32, // imaginary part of first input
    X2: ['G+1, 'G+3] 32,
    X3: ['G+1, 'G+3] 32,
    X4: ['G+1, 'G+3] 32,
    X5: ['G+1, 'G+3] 32,
    X6: ['G+1, 'G+3] 32,
    X7: ['G+1, 'G+3] 32,
    X8: ['G+1, 'G+3] 32,
    X9: ['G+1, 'G+3] 32,
    X10: ['G+1, 'G+3] 32,
    X11: ['G+1, 'G+3] 32,
    X12: ['G+1, 'G+3] 32,
    X13: ['G+1, 'G+3] 32,
    X14: ['G+1, 'G+3] 32,
    X15: ['G+1, 'G+3] 32
  ) -> (
    Y0: ['G+116, 'G+118] 32, // outputs happen 115 cycles after inputs
    Y1: ['G+116, 'G+118] 32,
    Y2: ['G+116, 'G+118] 32,
    Y3: ['G+116, 'G+118] 32,
    Y4: ['G+116, 'G+118] 32,
    Y5: ['G+116, 'G+118] 32,
    Y6: ['G+116, 'G+118] 32,
    Y7: ['G+116, 'G+118] 32,
    Y8: ['G+116, 'G+118] 32,
    Y9: ['G+116, 'G+118] 32,
    Y10: ['G+116, 'G+118] 32,
    Y11: ['G+116, 'G+118] 32,
    Y12: ['G+116, 'G+118] 32,
    Y13: ['G+116, 'G+118] 32,
    Y14: ['G+116, 'G+118] 32,
    Y15: ['G+116, 'G+118] 32,
  );
}

comp BundledSpiralFFT<'G: 105>(
  go: interface['G],
  in: ['G, 'G+1] NPoints*2*32, // input bundle
) -> (
  out: ['G+L+(NPoints-1)/StreamingWidth+1, 'G+L+(NPoints-1)/StreamingWidth+2] NPoints*2*32 // output wire
) with {
  let NPoints = 16;
  let StreamingWidth = 8;
  let L = 115;
} where
  NPoints % 2 == 0,
  L > 0
{
  in_split := new SplitWire[32, NPoints*2]<'G>(in);

  bundle input_bundle[NPoints][2]: for<ii> ['G + ii/StreamingWidth+1, 'G+ii/StreamingWidth+2] 32;

  for i in 0..NPoints {
    s1 := new Shift[32, i/StreamingWidth+1]<'G>(in_split.out{2*i});
    s2 := new Shift[32, i/StreamingWidth+1]<'G>(in_split.out{2*i+1});

    input_bundle{i}{0} = s1.out;
    input_bundle{i}{1} = s2.out;
  }

  bundle input_bundle_merged[StreamingWidth][2]: ['G+1, 'G+3] 32;

  for i in 0..StreamingWidth {
    bundle combinedinputs[NPoints/StreamingWidth][2]: for<ii> ['G+ii+1, 'G+ii+2] 32;

    for j in 0..NPoints/StreamingWidth {
      combinedinputs{j}{0..2} = input_bundle{StreamingWidth*j+i}{0..2};
    }

    merge1 := new UnsafeMergeBundle[32, NPoints/StreamingWidth]<'G+1>(combinedinputs{0..NPoints/StreamingWidth}{0});
    merge2 := new UnsafeMergeBundle[32, NPoints/StreamingWidth]<'G+1>(combinedinputs{0..NPoints/StreamingWidth}{1});

    input_bundle_merged{i}{0} = merge1.out;
    input_bundle_merged{i}{1} = merge2.out;
  }

  FP := new dft_top_2<'G>(
    input_bundle_merged{0}{0},
    input_bundle_merged{0}{1},
    input_bundle_merged{1}{0},
    input_bundle_merged{1}{1},
    input_bundle_merged{2}{0},
    input_bundle_merged{2}{1},
    input_bundle_merged{3}{0},
    input_bundle_merged{3}{1},
    input_bundle_merged{4}{0},
    input_bundle_merged{4}{1},
    input_bundle_merged{5}{0},
    input_bundle_merged{5}{1},
    input_bundle_merged{6}{0},
    input_bundle_merged{6}{1},
    input_bundle_merged{7}{0},
    input_bundle_merged{7}{1}
  );

  bundle fp_out[NPoints][2]: for<jj> ['G+L+jj/StreamingWidth+1, 'G+L+jj/StreamingWidth+2] 32;

  fp_out{0}{0} = FP.Y0;
  fp_out{0}{1} = FP.Y1;
  fp_out{1}{0} = FP.Y2;
  fp_out{1}{1} = FP.Y3;
  fp_out{2}{0} = FP.Y4;
  fp_out{2}{1} = FP.Y5;
  fp_out{3}{0} = FP.Y6;
  fp_out{3}{1} = FP.Y7;
  fp_out{4}{0} = FP.Y8;
  fp_out{4}{1} = FP.Y9;
  fp_out{5}{0} = FP.Y10;
  fp_out{5}{1} = FP.Y11;
  fp_out{6}{0} = FP.Y12;
  fp_out{6}{1} = FP.Y13;
  fp_out{7}{0} = FP.Y14;
  fp_out{7}{1} = FP.Y15;
  fp_out{8}{0} = FP.Y0;
  fp_out{8}{1} = FP.Y1;
  fp_out{9}{0} = FP.Y2;
  fp_out{9}{1} = FP.Y3;
  fp_out{10}{0} = FP.Y4;
  fp_out{10}{1} = FP.Y5;
  fp_out{11}{0} = FP.Y6;
  fp_out{11}{1} = FP.Y7;
  fp_out{12}{0} = FP.Y8;
  fp_out{12}{1} = FP.Y9;
  fp_out{13}{0} = FP.Y10;
  fp_out{13}{1} = FP.Y11;
  fp_out{14}{0} = FP.Y12;
  fp_out{14}{1} = FP.Y13;
  fp_out{15}{0} = FP.Y14;
  fp_out{15}{1} = FP.Y15;

  bundle fp_output_bundle[NPoints*2]: ['G+L+(NPoints-1)/StreamingWidth+1, 'G+L+(NPoints-1)/StreamingWidth+2] 32;

  for j in 0..NPoints {
    if (NPoints-j-1) / StreamingWidth == 0 {
      fp_output_bundle{2*j} = fp_out{j}{0};
      fp_output_bundle{2*j+1} = fp_out{j}{1};
    } else {
      s1 := new Shift[32, (NPoints-j-1)/StreamingWidth]<'G+L+1+j/StreamingWidth>(fp_out{j}{0});
      s2 := new Shift[32, (NPoints-j-1)/StreamingWidth]<'G+L+1+j/StreamingWidth>(fp_out{j}{1});

      fp_output_bundle{2*j} = s1.out;
      fp_output_bundle{2*j+1} = s2.out;
    }
  }

  fpw := new ConcatBundle[32, NPoints*2]<'G+L+1+(NPoints-1)/StreamingWidth>(fp_output_bundle{0..NPoints*2});
  out = fpw.out;
}