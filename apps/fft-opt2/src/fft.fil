import "primitives/signed.fil";
import "helpers.fil";
import "butterfly.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";

/// FFT that takes in a single wire and outputs a single wire
/// Wraps the normal bundle-based fft component
comp BundledFFT[NStages, N, ?Iterative=1]<'G: II>(
  go: interface['G],
  in: ['G, 'G+1] NPoints*2*32, // input bundle
) -> (
  out: ['G+L, 'G+L+1] NPoints*2*32 // output wire
) with {
  let NPoints = pow2(NStages);
  some II where II > 0;
  some L where L >= II;
} where
  NPoints % (2*N) == 0,
  N > 0,
  N * 2 <= NPoints,
  NStages > 0,
  II > 0,
  L >= II
{
  in_split := new SplitWire[32, NPoints*2]<'G>(in);

  bundle input_bundle[NPoints][2]: ['G, 'G+1] 32;

  for i in 0..NPoints {
    input_bundle{i}{0} = in_split.out{2*i};
    input_bundle{i}{1} = in_split.out{2*i+1};
  }

  // hook up pipelined fft
  if Iterative == 1 {
    FP := new IterativePeaseFFT[NStages, N];
    fp := FP<'G>(input_bundle{0..NPoints}{0..2});

    bundle fp_output_bundle[NPoints*2]: ['G+FP::L, 'G+FP::L+1] 32;

    for i in 0..NPoints {
      fp_output_bundle{2*i} = fp.out{i}{0};
      fp_output_bundle{2*i+1} = fp.out{i}{1};
    }

    fpw := new ConcatBundle[32, NPoints*2]<'G+FP::L>(fp_output_bundle{0..NPoints*2});
    out = fpw.out;

    L := FP::L;
    II := FP::L;
  } else {
    assume NStages > 2;
    FP := new StreamingPeaseFFT[NStages];
    fp := FP<'G>(input_bundle{0..NPoints}{0..2});

    bundle fp_output_bundle[NPoints*2]: ['G+FP::L, 'G+FP::L+1] 32;

    for i in 0..NPoints {
      fp_output_bundle{2*i} = fp.out{i}{0};
      fp_output_bundle{2*i+1} = fp.out{i}{1};
    }

    fpw := new ConcatBundle[32, NPoints*2]<'G+FP::L>(fp_output_bundle{0..NPoints*2});
    out = fpw.out;

    L := FP::L;
    II := 1;
  }
}

/// Implements an streaming PEASE fft.
comp StreamingPeaseFFT[NStages]<'G: 1>(
  in[NPoints][2]: ['G, 'G+1] W
) -> (
  out[NPoints][2]: ['G+L, 'G+L+1] W
) with {
  let NPoints = pow2(NStages);

  some L where L > 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} where
  NPoints % 2 == 0,
  NStages > 2
{
  assume pow2(NStages-1) == NPoints/2;

  bitrev := new BitRev[NStages, W]<'G>(in{0..NPoints}{0..2});

  CASx := new ComplexAddSub[W, E, M];
  TMx := new TwiddleMul[0, NPoints, W, E, M];
  assume TMx::L == 0; // we know this because of the internal implementation
  TMx1 := new TwiddleMul[1, NPoints, W, E, M];
  let stage_latency = TMx1::L + CASx::L;
  let multiplyless_latency = TMx::L + CASx::L;

  bundle data[NStages-1][NPoints][2]: for<sdii> ['G + sdii*stage_latency + 2 * multiplyless_latency, 'G + sdii*stage_latency + 1 + 2 * multiplyless_latency] W;

  // stage 1-2 input data
  bundle data_12[2][NPoints][2]: for<sd12ii> ['G + sd12ii*multiplyless_latency, 'G + sd12ii*multiplyless_latency + 1] W;
  data_12{0}{0..NPoints}{0..2} = bitrev.out{0..NPoints}{0..2};

  /// ------------ hook up registers and butterfly components. ------------

  // first stage
  bundle s1_butterfly_out[NPoints][2]: ['G + multiplyless_latency, 'G + multiplyless_latency + 1] W;
  for s1_j in 0..NPoints/2 {
    // stage 1, no twiddle multiplier necessary as all twiddles are 1
    TM := new TwiddleMul[0, NPoints, W, E, M]<'G>(data_12{0}{2*s1_j+1}{0..2});
    assume TM::L == 0; // we know this because of the internal implementation
    CAS := new ComplexAddSub[W, E, M]<'G>(data_12{0}{2*s1_j}{0..2}, TM.out{0..2});

    s1_butterfly_out{2*s1_j}{0..2} = CAS.out0{0..2};
    s1_butterfly_out{2*s1_j+1}{0..2} = CAS.out1{0..2};
  }
  s1_sp := new StridePermutation[NStages, W]<'G + multiplyless_latency>(s1_butterfly_out{0..NPoints}{0..2});
  data_12{1}{0..NPoints}{0..2} = s1_sp.out{0..NPoints}{0..2};
  // second stage
  bundle s2_butterfly_out[NPoints][2]: ['G + multiplyless_latency * 2, 'G + multiplyless_latency * 2 + 1] W;
  for s2_j in 0..NPoints/2 {
    // stage 2, first half of twiddles are 1, second half are -1
    let twiddle_idx = (s2_j / (NPoints/4)) * (NPoints/4);
    TM := new TwiddleMul[twiddle_idx, NPoints, W, E, M]<'G+multiplyless_latency>(data_12{1}{2*s2_j+1}{0..2});
    assume TM::L == 0; // we know this because of the internal implementation
    CAS := new ComplexAddSub[W, E, M]<'G+multiplyless_latency>(data_12{1}{2*s2_j}{0..2}, TM.out{0..2});

    s2_butterfly_out{2*s2_j}{0..2} = CAS.out0{0..2};
    s2_butterfly_out{2*s2_j+1}{0..2} = CAS.out1{0..2};
  }
  s2_sp := new StridePermutation[NStages, W]<'G + multiplyless_latency * 2>(s2_butterfly_out{0..NPoints}{0..2});
  data{0}{0..NPoints}{0..2} = s2_sp.out{0..NPoints}{0..2};

  for i in 2..NStages {
    let stage_start = (i-2) * stage_latency + 2 * multiplyless_latency;
    bundle butterfly_out[NPoints][2]: ['G + stage_start + stage_latency, 'G + stage_start + stage_latency + 1] W;

    // For this stage, there will be pow2(i) unique twiddle factors
    // Each twiddle factor is used NPoints/pow2(i)/2 times
    for j in 0..NPoints/2 {
      let twiddle_idx = (j / pow2(NStages - i - 1)) * pow2(NStages - i - 1);
      assume twiddle_idx >= 0;
      assume twiddle_idx*2 < NPoints;

      // shift first input
      s01 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j}{0});
      s02 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j}{1});

      bundle in0[2]: ['G + stage_start + TMx1::L, 'G + stage_start + TMx1::L + 1] W;
      bundle in1[2]: ['G + stage_start + TMx1::L, 'G + stage_start + TMx1::L + 1] W+2;
      in0{0} = s01.out{0};
      in0{1} = s02.out{0};

      if (twiddle_idx * 4) % NPoints == 0 {
        TM := new TwiddleMul[twiddle_idx, NPoints, W, E, M];
        assume TM::L == 0; // we know this because of the internal implementation
        // need to shift the inputs here before doing twiddle mult
        s1 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j+1}{0});
        s2 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j+1}{1});

        bundle inp[2]: ['G + stage_start + TMx1::L, 'G + stage_start + TMx1::L + 1] W;
        inp{0} = s1.out{0};
        inp{1} = s2.out{0};

        tm := TM<'G + stage_start + TMx1::L>(inp{0..2});

        in1{0} = tm.out{0};
        in1{1} = tm.out{1};
      } else {
        TM := new TwiddleMul[twiddle_idx, NPoints, W, E, M];
        assume TM::L == TMx1::L;// We know this because of the internal implementation

        tm := TM<'G + stage_start>(data{i-2}{2*j+1}{0..2});
        in1{0} = tm.out{0};
        in1{1} = tm.out{1};
      }

      CAS := new ComplexAddSub[W, E, M]<'G + stage_start + TMx1::L>(in0{0..2}, in1{0..2});

      butterfly_out{2*j}{0..2} = CAS.out0{0..2};
      butterfly_out{2*j+1}{0..2} = CAS.out1{0..2};
    }
    sp := new StridePermutation[NStages, W]<'G + stage_start + stage_latency>(butterfly_out{0..NPoints}{0..2});
    data{i-1}{0..NPoints}{0..2} = sp.out{0..NPoints}{0..2};
  } 

  out{0..NPoints}{0..2} = data{NStages-2}{0..NPoints}{0..2};
  L := stage_latency * (NStages-2) + 2 * multiplyless_latency;
}

/// Implements an iterative PEASE fft.
/// Uses `N` butterflies
comp IterativePeaseFFT[NStages, N]<'G: L>(
  go: interface['G],
  in[NPoints][2]: ['G, 'G+1] W
) -> (
  out[NPoints][2]: ['G+L, 'G+L+1] W
) with {
  let NPoints = pow2(NStages);
  some L where L > 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} where
  // number of butterflies (N) must divide the total number of butterflies per stage (NPoints/2)
  NPoints % (2*N) == 0,
  N > 0,
  N * 2 <= NPoints,
  NStages > 0
{
  assume pow2(NStages-1) == NPoints/2;

  bitrev := new BitRev[NStages, W]<'G>(in{0..NPoints}{0..2});
  // butterfly components
  B := new Butterflies[N, W, E, M];
  // number of times we have to reuse the butterflies per stage
  let reuses = NPoints / (2*N);
  let stage_latency = B::II * reuses + B::L + 1; // + 1 here is for the extra delay cycle necessary to transfer values between stages
  let latency = stage_latency * NStages;
  
  // twiddle factor that stays alive for the whole computation
  twiddle := new TwiddleFactor[NPoints, latency]<'G>();

  // contains all the twiddle stage data as an always-alive constant matrix
  bundle twiddle_in[NStages][NPoints/2][2]: ['G, 'G + latency] W;

  for twiddle_i in 0..NStages {
    twiddle_stage := new TwiddleStage[NStages, twiddle_i, W, latency]<'G>(twiddle.out{0..NPoints/2}{0..2});
    twiddle_in{twiddle_i}{0..NPoints/2}{0..2} = twiddle_stage.out{0..NPoints/2}{0..2};
  }

  // Synchronized data (happens between each stage, inputs and outputs to stride permutation)
  // Separated by the input and output to and from the registers.
  // There are Nstages of these (one for input and one for output for each stage)
  bundle sync_data_in[NStages+1][NPoints][2]: for<sdii> ['G + sdii*stage_latency, 'G + sdii*stage_latency + 1] W;
  bundle sync_data_out[NStages][NPoints][2]:  for<sdoi> ['G + (sdoi+1) * stage_latency - 1, 'G + (sdoi+1) * stage_latency] W;

  // Unsynchronized data (happens within each stage, input to and ouptut from the butterfly calculations)
  // There are `reuses` blocks within each stage, each separated by `B::L`.
  // `i % (NPoints*2)` is the progress within the stage, and there are `4*N` inputs per butterfly chunk
  // Each butterfly takes B::L cycles to complete
  // no bundles for this as they can be stored temprorarily in registers


  // Dataflow for one register looks like this:
  // Synchronized in -> hold till butterfly -> unsync in -> butterfly -> unsync out -> hold till sync -> sync out -> stride permutation -> sync in

  // hook up inputs
  sync_data_in{0}{0..NPoints}{0..2} = bitrev.out{0..NPoints}{0..2};
  

  /// ------------ hook up registers and butterfly components. ------------
  // for every reuse of a butterfly
  for reg_i in 0..reuses {
    // one big register storing all the inputs and outputs of one butterfly chunk
    R := new PassThroughRegister[W * 4 * N] in ['G, 'G+latency], ['G+1, 'G+latency+1];

    for r_stage in 0..NStages {
      let sync_in_t = r_stage * stage_latency; // start stage here
      let sync_out_t = (r_stage + 1) * stage_latency; // end stage here

      let usync_in_t = sync_in_t + reg_i * B::II; // start butterfly here
      let usync_in_end_t = usync_in_t + B::II; // end butterfly inputs here
      let usync_out_t = usync_in_t + B::L; // end butterfly here

      let start = reg_i*2*N;
      let end = (reg_i+1)*2*N;

      // sync in -> unsync in
      c1 := new CombineButterflyBundle[N, W]<'G + sync_in_t>(sync_data_in{r_stage}{start..end}{0..2});
      r1 := R<'G + sync_in_t, 'G + usync_in_end_t>(c1.out);
      s1 := new SplitButterflyBundle[N, W, usync_in_end_t-usync_in_t]<'G + usync_in_t>(r1.out);
      // unsync in -> butterfly
      b := B<'G + usync_in_t>(s1.out{0..2*N}{0..2}, twiddle_in{r_stage}{reg_i*N..(reg_i+1)*N}{0..2});
      // unsync out -> sync out
      c2 := new CombineButterflyBundle[N, W]<'G + usync_out_t>(b.out{0..2*N}{0..2});
      r2 := R<'G + usync_out_t, 'G + sync_out_t>(c2.out);
      s2 := new SplitButterflyBundle[N, W]<'G + sync_out_t-1>(r2.out);

      // store sync out
      sync_data_out{r_stage}{start..end}{0..2} = s2.out{0..2*N}{0..2};
    }
  }

  // --------------- STRIDE PERMUTATIONS ----------------
  SP := new StridePermutation[NStages, W] in ['G+stage_latency-1, 'G+latency];
  
  // A delay is necessary for between stages so the pass-through register
  // isn't used twice at the same time
  D := new Delay[W*NPoints*2];


  // hook up stride permutations
  for stage in 0..NStages {
    let sync_out_t = (stage + 1) * stage_latency - 1;
    stride := SP<'G + sync_out_t>(sync_data_out{stage}{0..NPoints}{0..2});

    // delay between stages
    c1 := new CombineButterflyBundle[NPoints/2, W]<'G + sync_out_t>(stride.out{0..NPoints}{0..2});
    d1 := D<'G + sync_out_t>(c1.out);
    s1 := new SplitButterflyBundle[NPoints/2, W]<'G + sync_out_t + 1>(d1.out);

    sync_data_in{stage+1}{0..NPoints}{0..2} = s1.out{0..NPoints}{0..2};
  }

  out{0..NPoints}{0..2} = sync_data_in{NStages}{0..NPoints}{0..2};
  L := latency;
}

/// Computes N butterflies at once.
comp Butterflies[N, W, E, ?M=W-E-1]<'G: II>(
  go: interface['G],
  in[N*2][2]: ['G, 'G+II] W, // Each butterfly takes 2 complex numbers
  twiddle[N][2]: ['G, 'G+II] W // twiddle factor for each butterfly
) -> (
  out[N*2][2]: ['G+L, 'G+L+1] W
) with {
  some II where II > 0;
  some L where L >= II;
} where
    N > 0,
    W == E + M + 1,
    E > 1,
    M > 1,
    L >= II,
    II > 0
{
  // We use the fact here that a butterfly has the same existential L if it has the same parameters.
  // Therefore, we instantiate a dummy butterfly here in order to access its L parameter.
  Bx := new Butterfly[W, E, M];
  L := Bx::L;
  II := Bx::II;

  for i in 0..N {
    b := new Butterfly[W, E, M]<'G>(in{2*i}{0..2}, in{2*i+1}{0..2}, twiddle{i}{0..2});
    out{2*i}{0..2} = b.out0{0..2};
    out{2*i+1}{0..2} = b.out1{0..2};
  }
}

/// Combines output of the Butterflies component into a single wire
comp CombineButterflyBundle[N, W, ?L=1]<'G: L>(
  in[N*2][2]: ['G, 'G+L] W
) -> (
  out: ['G, 'G+L] W*4*N
) where
    N > 0,
    W > 0,
    L > 0
{
  bundle outb[N*4]: ['G, 'G+L] W;
  for i in 0..N*2 {
    outb{i*2} = in{i}{0};
    outb{i*2+1} = in{i}{1};
  }
  
  cb := new ConcatBundle[W, N*4, L]<'G>(outb{0..N*4});
  
  out = cb.out;
}

/// Splits output of the Butterflies component into a bundle
comp SplitButterflyBundle[N, W, ?L=1]<'G: L>(
  in: ['G, 'G+L] W*4*N
) -> (
  out[N*2][2]: ['G, 'G+L] W
) where
    N > 0,
    W > 0,
    L > 0
{
  sw := new SplitWire[W, N*4, L]<'G>(in);
  for i in 0..N*2 {
    out{i}{0} = sw.out{i*2};
    out{i}{1} = sw.out{i*2+1};
  }
}