import "primitives/signed.fil";
import "helpers.fil";
import "butterfly.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";

comp MultiplylessButterfly[twiddle_idx, N, E, M]<'G: 1>(
  in0[2]: ['G, 'G+1] W,
  in1[2]: ['G, 'G+1] W,
) -> (
  out0[2]: ['G+L, 'G+L+1] W,
  out1[2]: ['G+L, 'G+L+1] W
) with {
  some W where W > 0;
  some L where L >= 0;
} where
  (twiddle_idx * 4) % N == 0,
  twiddle_idx >= 0,
  N > twiddle_idx*2,
  N > 2,
  N > 2,
  E > 1,
  M > 1
{
  // instantiations for latency access
  FM := new AbstractFPMult[E, M];
  FA := new AbstractFPAdd[E, M];
  FS := new AbstractFPSub[E, M];
  FN := new AbstractFPNeg[E, M];

  assume FM::W == FA::W;
  assume FM::W == FS::W;
  assume FM::W == FN::W;

  W := FM::W;

  assume FA::L == FS::L;

  bundle tm_out[2]: ['G, 'G + 1] FM::W;

  if twiddle_idx == 0 { // twiddle = 1
    tm_out{0} = in1{0};
    tm_out{1} = in1{1};
  } else {
    if twiddle_idx * 4 == N { // twiddle = ii
      // (a + bi) * -i = b - ai
      // negate a
      neg0 := new AbstractFPNeg[E, M]<'G>(in1{0});
      tm_out{0} = in1{1};
      tm_out{1} = neg0.R;
    } else {
      // these cases shouldn't happen
      assert 1 == 0;
    }
  }
  

  // in0 + (w * in1)
  out00 := new AbstractFPAdd[E, M]<'G>(in0{0}, tm_out{0}); // re
  out01 := new AbstractFPAdd[E, M]<'G>(in0{1}, tm_out{1}); // im
  
  // in0 - (w * in1)
  out10 := new AbstractFPSub[E, M]<'G>(in0{0}, tm_out{0}); // re
  out11 := new AbstractFPSub[E, M]<'G>(in0{1}, tm_out{1}); // im
  
  out0{0} = out00.R;
  out0{1} = out01.R;
  out1{0} = out10.R;
  out1{1} = out11.R;

  L := FA::L;
}

comp MultiplylessStage[i, NStages, E, M]<'G: 1>(
  in[N][2]: ['G, 'G+1] W
) -> (
  out[N][2]: ['G+L, 'G+L+1] W
) with {
  some W where W > 0;
  let N = pow2(NStages);
  some L where L >= 0;
} where
  NStages > i,
  NStages >= 2,
  i >= 0,
  i < 2,
  E > 1,
  M > 1
{
  // if i != 0, we should register the inputs
  let start_delay = 0;
  MBx := new MultiplylessButterfly[0, N, E, M];

  bundle in_d[N][2]: ['G+start_delay, 'G+start_delay+1] MBx::W;
  for j in 0..N {
    d1 := new Shift[MBx::W, start_delay]<'G>(in{j}{0});
    d2 := new Shift[MBx::W, start_delay]<'G>(in{j}{1});

    in_d{j}{0} = d1.out{0};
    in_d{j}{1} = d2.out{0};
  }

  assume N > 2;
  for j in 0..N/2 {
    let twiddle_idx = (j / pow2(NStages - i - 1)) * pow2(NStages - i - 1);
    assume twiddle_idx >= 0;
    assume twiddle_idx*2 < N;
    assume (twiddle_idx * 4) % N == 0;

    MB := new MultiplylessButterfly[twiddle_idx, N, E, M];
    assume MB::L == MBx::L; // we know this because of the internal implementation
    assume MB::W == MBx::W; // we know this because of the internal implementation
    mb := MB<'G+start_delay>(in_d{2*j}{0..2}, in_d{2*j+1}{0..2});
    out{2*j}{0..2} = mb.out0{0..2};
    out{2*j+1}{0..2} = mb.out1{0..2};
  }

  L := MBx::L + start_delay;
  W := MBx::W;
}

comp StreamingStage[i, NStages, E, M]<'G: 1>(
  in[N][2]: ['G, 'G+1] W
) -> (
  out[N][2]: ['G+L, 'G+L+1] W
) with {
  some W where W > 0;
  let N = pow2(NStages);
  some L where L >= 0;
} where
  NStages > i,
  NStages >= 2,
  i >= 2,
  E > 1,
  M > 1
{
  SBx := new StreamingButterfly[1, N, E, M];
  assume N > 2;
  for j in 0..N/2 {
    let twiddle_idx = (j / pow2(NStages - i - 1)) * pow2(NStages - i - 1);
    assume twiddle_idx >= 0;
    assume twiddle_idx*2 < N;

    SB := new StreamingButterfly[twiddle_idx, N, E, M];
    assume SB::L == SBx::L; // we know this because of the internal implementation
    assume SB::W == SBx::W; // we know this because of the internal implementation
    sb := SB<'G>(in{2*j}{0..2}, in{2*j+1}{0..2});
    out{2*j}{0..2} = sb.out0{0..2};
    out{2*j+1}{0..2} = sb.out1{0..2};
  }

  L := SBx::L;
  W := SBx::W;
}

/// Implements an streaming PEASE fft.
comp StreamingPeaseFFT[NStages]<'G: 1>(
  in[NPoints][2]: ['G, 'G+1] W
) -> (
  out[NPoints][2]: ['G+L, 'G+L+1] W
) with {
  let NPoints = pow2(NStages);

  some L where L >= 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} where
  NPoints % 2 == 0,
  NStages > 2
{
  assume pow2(NStages-1) == NPoints/2;

  bitrev := new BitRev[NStages, W]<'G>(in{0..NPoints}{0..2});

  MSx := new MultiplylessStage[0, NStages, E, M];
  SSx := new StreamingStage[2, NStages, E, M];
  ABFx := new AbstractFPfromIEEE[E, M];
  ABTx := new AbstractFPtoIEEE[E, M];
  let stage_latency = SSx::L;
  let multiplyless_latency = MSx::L;

  let inner_width = SSx::W;
  assume SSx::W == MSx::W;
  assume SSx::W == ABFx::W;
  assume SSx::W == ABTx::W;

  // stage 1-2 input data
  let stage2_start = 2 * multiplyless_latency + 1;
  bundle data[NStages-1][NPoints][2]: for<sdii> ['G + sdii*stage_latency + stage2_start, 'G + sdii*stage_latency + stage2_start+1] inner_width;

  bundle data_12[2][NPoints][2]: for<sd12ii> ['G + sd12ii*multiplyless_latency+1, 'G + sd12ii*multiplyless_latency + 2] inner_width;
  // Use AbstractFPfromIEEE to convert the input to internal format
  for i in 0..NPoints {
    ab1 := new AbstractFPfromIEEE[E, M]<'G>(bitrev.out{i}{0});
    ab2 := new AbstractFPfromIEEE[E, M]<'G>(bitrev.out{i}{1});
    d1 := new Delay[inner_width]<'G>(ab1.R);
    d2 := new Delay[inner_width]<'G>(ab2.R);
    data_12{0}{i}{0} = d1.out;
    data_12{0}{i}{1} = d2.out;
  }

  /// ------------ hook up registers and butterfly components. ------------

  // first stage
  MS0 := new MultiplylessStage[0, NStages, E, M];
  ms0 := MS0<'G+1>(data_12{0}{0..NPoints}{0..2});
  s1_sp := new StridePermutation[NStages, inner_width]<'G + multiplyless_latency+1>(ms0.out{0..NPoints}{0..2});
  data_12{1}{0..NPoints}{0..2} = s1_sp.out{0..NPoints}{0..2};
  // second stage
  MS1 := new MultiplylessStage[1, NStages, E, M];
  ms1 := MS1<'G + multiplyless_latency+1>(data_12{1}{0..NPoints}{0..2});
  s2_sp := new StridePermutation[NStages, inner_width]<'G + multiplyless_latency * 2 + 1>(ms1.out{0..NPoints}{0..2});
  data{0}{0..NPoints}{0..2} = s2_sp.out{0..NPoints}{0..2};
  assume MS0::L == MS1::L; // we know this because of the internal implementation
  assume MS0::W == MS1::W; // we know this because of the internal implementation

  for i in 2..NStages {
    let stage_start = (i-2) * stage_latency + 2 * multiplyless_latency + 1;
    
    SS := new StreamingStage[i, NStages, E, M];
    assume SS::L == SSx::L; // we know this because of the internal implementation
    assume SS::W == SSx::W; // we know this because of the internal implementation
    ss := SS<'G + stage_start>(data{i-2}{0..NPoints}{0..2});

    sp := new StridePermutation[NStages, inner_width]<'G + stage_start + stage_latency>(ss.out{0..NPoints}{0..2});
    data{i-1}{0..NPoints}{0..2} = sp.out{0..NPoints}{0..2};
  } 

  // Convert the output to IEEE format
  for i in 0..NPoints {
    ab1 := new AbstractFPtoIEEE[E, M]<'G + (NStages-2) * stage_latency + 2 * multiplyless_latency + 1>(data{NStages-2}{i}{0});
    ab2 := new AbstractFPtoIEEE[E, M]<'G + (NStages-2) * stage_latency + 2 * multiplyless_latency + 1>(data{NStages-2}{i}{1});
    out{i}{0} = ab1.R;
    out{i}{1} = ab2.R;
  }

  L := stage_latency * (NStages-2) + 2 * multiplyless_latency + 1;
}