import "primitives/signed.fil";
import "helpers.fil";
import "butterfly.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";
import "primitives/flopoco/def.fil";
import "primitives/math/complex.fil";
import "primitives/math/float.fil";
import "float.fil";

/// Implements an streaming PEASE fft.
comp StreamingPeaseFFT[NStages]<'G: 1>(
  in[NPoints][2]: ['G, 'G+1] W
) -> (
  out[NPoints][2]: ['G+L, 'G+L+1] W
) with {
  let NPoints = pow2(NStages);

  some L where L > 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} where
  NPoints % 2 == 0,
  NStages > 2
{
  assume pow2(NStages-1) == NPoints/2;

  bitrev := new BitRev[NStages, W]<'G>(in{0..NPoints}{0..2});

  CASx := new ComplexAddSub[W, E, M];
  TMx := new TwiddleMul[0, NPoints, W, E, M];
  assume TMx::L == 0; // we know this because of the internal implementation
  TMx1 := new TwiddleMul[1, NPoints, W, E, M];
  let stage_latency = TMx1::L + CASx::L;
  let multiplyless_latency = TMx::L + CASx::L;

  bundle data[NStages-1][NPoints][2]: for<sdii> ['G + sdii*stage_latency + 2 * multiplyless_latency, 'G + sdii*stage_latency + 1 + 2 * multiplyless_latency] W;

  // stage 1-2 input data
  bundle data_12[2][NPoints][2]: for<sd12ii> ['G + sd12ii*multiplyless_latency, 'G + sd12ii*multiplyless_latency + 1] W;
  data_12{0}{0..NPoints}{0..2} = bitrev.out{0..NPoints}{0..2};

  /// ------------ hook up registers and butterfly components. ------------

  // first stage
  bundle s1_butterfly_out[NPoints][2]: ['G + multiplyless_latency, 'G + multiplyless_latency + 1] W;
  for s1_j in 0..NPoints/2 {
    // stage 1, no twiddle multiplier necessary as all twiddles are 1
    TM := new TwiddleMul[0, NPoints, W, E, M];
    tm := TM<'G>(data_12{0}{2*s1_j+1}{0..2});
    assume TM::L == 0; // we know this because of the internal implementation
    CAS := new ComplexAddSub[W, E, M];
    cas := CAS<'G>(data_12{0}{2*s1_j}{0..2}, tm.out{0..2});
    assume TM::W == CAS::W;

    s1_butterfly_out{2*s1_j}{0..2} = cas.out0{0..2};
    s1_butterfly_out{2*s1_j+1}{0..2} = cas.out1{0..2};
  }
  s1_sp := new StridePermutation[NStages, W]<'G + multiplyless_latency>(s1_butterfly_out{0..NPoints}{0..2});
  data_12{1}{0..NPoints}{0..2} = s1_sp.out{0..NPoints}{0..2};
  // second stage
  bundle s2_butterfly_out[NPoints][2]: ['G + multiplyless_latency * 2, 'G + multiplyless_latency * 2 + 1] W;
  for s2_j in 0..NPoints/2 {
    // stage 2, first half of twiddles are 1, second half are -1
    let twiddle_idx = (s2_j / (NPoints/4)) * (NPoints/4);
    TM := new TwiddleMul[twiddle_idx, NPoints, W, E, M];
    tm := TM<'G+multiplyless_latency>(data_12{1}{2*s2_j+1}{0..2});
    assume TM::L == 0; // we know this because of the internal implementation
    CAS := new ComplexAddSub[W, E, M];
    cas := CAS<'G+multiplyless_latency>(data_12{1}{2*s2_j}{0..2}, tm.out{0..2});
    assume TM::W == CAS::W;

    s2_butterfly_out{2*s2_j}{0..2} = cas.out0{0..2};
    s2_butterfly_out{2*s2_j+1}{0..2} = cas.out1{0..2};
  }
  s2_sp := new StridePermutation[NStages, W]<'G + multiplyless_latency * 2>(s2_butterfly_out{0..NPoints}{0..2});
  data{0}{0..NPoints}{0..2} = s2_sp.out{0..NPoints}{0..2};

  for i in 2..NStages {
    let stage_start = (i-2) * stage_latency + 2 * multiplyless_latency;
    bundle butterfly_out[NPoints][2]: ['G + stage_start + stage_latency, 'G + stage_start + stage_latency + 1] W;

    // For this stage, there will be pow2(i) unique twiddle factors
    // Each twiddle factor is used NPoints/pow2(i)/2 times
    for j in 0..NPoints/2 {
      let twiddle_idx = (j / pow2(NStages - i - 1)) * pow2(NStages - i - 1);
      assume twiddle_idx >= 0;
      assume twiddle_idx*2 < NPoints;

      // shift first input
      s01 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j}{0});
      s02 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j}{1});

      bundle in0[2]: ['G + stage_start + TMx1::L, 'G + stage_start + TMx1::L + 1] W;
      bundle in1[2]: ['G + stage_start + TMx1::L, 'G + stage_start + TMx1::L + 1] TMx::W;
      in0{0} = s01.out{0};
      in0{1} = s02.out{0};

      if (twiddle_idx * 4) % NPoints == 0 {
        TM := new TwiddleMul[twiddle_idx, NPoints, W, E, M];
        assume TM::L == 0; // we know this because of the internal implementation
        // need to shift the inputs here before doing twiddle mult
        s1 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j+1}{0});
        s2 := new Shift[W, TMx1::L]<'G + stage_start>(data{i-2}{2*j+1}{1});

        bundle inp[2]: ['G + stage_start + TMx1::L, 'G + stage_start + TMx1::L + 1] W;
        inp{0} = s1.out{0};
        inp{1} = s2.out{0};

        tm := TM<'G + stage_start + TMx1::L>(inp{0..2});

        in1{0} = tm.out{0};
        in1{1} = tm.out{1};
        
        CAS := new ComplexAddSub[W, E, M];
        cas := CAS<'G + stage_start + TMx1::L>(in0{0..2}, in1{0..2});

        assume TM::W == CAS::W;
        assume TM::W == TMx::W;

        butterfly_out{2*j}{0..2} = cas.out0{0..2};
        butterfly_out{2*j+1}{0..2} = cas.out1{0..2};
      } else {
        TM := new TwiddleMul[twiddle_idx, NPoints, W, E, M];
        assume TM::L == TMx1::L;// We know this because of the internal implementation
        assume TM::W == TMx::W;

        tm := TM<'G + stage_start>(data{i-2}{2*j+1}{0..2});
        in1{0} = tm.out{0};
        in1{1} = tm.out{1};

        CAS := new ComplexAddSub[W, E, M];
        cas := CAS<'G + stage_start + TMx1::L>(in0{0..2}, in1{0..2});
        
        assume TM::W == CAS::W;

        butterfly_out{2*j}{0..2} = cas.out0{0..2};
        butterfly_out{2*j+1}{0..2} = cas.out1{0..2};
      }
    }
    sp := new StridePermutation[NStages, W]<'G + stage_start + stage_latency>(butterfly_out{0..NPoints}{0..2});
    data{i-1}{0..NPoints}{0..2} = sp.out{0..NPoints}{0..2};
  } 

  out{0..NPoints}{0..2} = data{NStages-2}{0..NPoints}{0..2};
  L := stage_latency * (NStages-2) + 2 * multiplyless_latency;
}

// Performs the twiddle multiplication
comp TwiddleMul[i, N, Width, E, ?M=W-E-1]<'G: 1>(
  in[2]: ['G, 'G+1] Width
) -> (
  out[2]: ['G+L, 'G+L+1] W // output in flopoco format
) with {
  some W where W > 0;
  some L where L >= 0;
} where
    Width == E + M + 1,
    E > 1,
    M > 1,
    i >= 0,
    N > i*2,
    L >= 0
{
  // instantiations for latency access
  FM := new FFTFPMult[E, M];
  FA := new FFTFPAdd[E, M];
  FS := new FFTFPSub[E, M];
  FN := new FFTFPNeg[E, M];
  II := new FFTInputIEEE[E, M];

  assume FM::W == FA::W;
  assume FM::W == FS::W;
  assume FM::W == FN::W;
  assume FM::W == II::W;

  W := FM::W;
  
  assume FA::L == FS::L; // we can assume this because we know the internal implementation of FPSub
  // convert to flopoco format
  in10 := new FFTInputIEEE[E, M]<'G>(in{0});
  in11 := new FFTInputIEEE[E, M]<'G>(in{1});

  if (i*4) % N == 0 {
    if i == 0 { // twiddle = 1
      out{0} = in10.R;
      out{1} = in11.R;
    } else {
      if i * 4 == N { // twiddle = ii
        // (a + bi) * -i = b - ai
        // negate a
        neg0 := new FFTFPNeg[E, M]<'G>(in10.R);
        out{0} = in11.R;
        out{1} = neg0.R;
      } else {
        // these cases shouldn't happen
        assert 1 == 0;
      }
    }
    L := 0;
  } else {
    // need a multiplier here

    bundle twiddle[2]: ['G, 'G+1] Width;
    twiddle0_const := new SignedConst[Width, cos_bits(i, N)]<'G>();
    twiddle1_const := new SignedConst[Width, sin_bits(i+N/2, N)]<'G>();

    twiddle{0} = twiddle0_const.out;
    twiddle{1} = twiddle1_const.out;

    twiddle0 := new FFTInputIEEE[E, M]<'G>(twiddle{0});
    twiddle1 := new FFTInputIEEE[E, M]<'G>(twiddle{1});

    // Perform w * in1
    ac := new FFTFPMult[E, M]<'G>(in10.R, twiddle0.R); // ac
    bd := new FFTFPMult[E, M]<'G>(in11.R, twiddle1.R); // bd
    re := new FFTFPSub[E, M]<'G+FM::L>(ac.R, bd.R); // ac - bd

    ad := new FFTFPMult[E, M]<'G>(in10.R, twiddle1.R); // ad
    bc := new FFTFPMult[E, M]<'G>(in11.R, twiddle0.R); // bc
    im := new FFTFPAdd[E, M]<'G+FM::L>(ad.R, bc.R); // ad + bc

    out{0} = re.R;
    out{1} = im.R;

    L := FM::L + FA::L;
  }
}

/// Complex add sub module
comp ComplexAddSub[Width, E, ?M=W-E-1]<'G: 1>(
  in0[2]: ['G, 'G+1] Width, // real and imaginary parts of input (Flopoco format)
  in1[2]: ['G, 'G+1] W
) -> (
  out0[2]: ['G+L, 'G+L+1] Width,
  out1[2]: ['G+L, 'G+L+1] Width
) with {
  some W where W > 0;
  some L where L > 0;
} where
    Width == E + M + 1,
    E > 1,
    M > 1,
    L > 0
{
  // instantiations for latency access
  FA := new FFTFPAdd[E, M];
  FS := new FFTFPSub[E, M];
  OI := new FFTOutputIEEE[E, M];
  II := new FFTInputIEEE[E, M];

  assume FA::W == FS::W;
  assume FA::W == OI::W;
  assume FA::W == II::W;

  W := FA::W;

  in00 := new FFTInputIEEE[E, M]<'G>(in0{0});
  in01 := new FFTInputIEEE[E, M]<'G>(in0{1});
  
  assume FA::L == FS::L; // we can assume this because we know the internal implementation of FPSub

  // in0 + (w * in1)
  out00 := new FFTFPAdd[E, M]<'G>(in00.R, in1{0}); // re
  out01 := new FFTFPAdd[E, M]<'G>(in01.R, in1{1}); // im
  
  // in0 - (w * in1)
  out10 := new FFTFPSub[E, M]<'G>(in00.R, in1{0}); // re
  out11 := new FFTFPSub[E, M]<'G>(in01.R, in1{1}); // im

  // convert back to IEEE
  out00_IEEE := new FFTOutputIEEE[E, M]<'G+FA::L>(out00.R);
  out01_IEEE := new FFTOutputIEEE[E, M]<'G+FA::L>(out01.R);
  out10_IEEE := new FFTOutputIEEE[E, M]<'G+FA::L>(out10.R);
  out11_IEEE := new FFTOutputIEEE[E, M]<'G+FA::L>(out11.R);

  out0{0} = out00_IEEE.R;
  out0{1} = out01_IEEE.R;
  out1{0} = out10_IEEE.R;
  out1{1} = out11_IEEE.R;

  L := FA::L;
}