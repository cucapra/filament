import "src/fft.fil";

/// FFT that takes in a single wire and outputs a single wire
/// Wraps the normal bundle-based fft component
comp BundledFFT[NStages, N]<'G: L>(
  go: interface['G],
  in: ['G, 'G+1] NPoints*2*32, // input bundle
) -> (
  out: ['G+L, 'G+L+1] NPoints*2*32 // output wire
) with {
  let NPoints = pow2(NStages);
  some L where L > 0;
} where
  NPoints % (2*N) == 0,
  N > 0,
  N * 2 <= NPoints,
  NStages > 0
{
  in_split := new SplitWire[32, NPoints*2]<'G>(in);

  bundle input_bundle[NPoints][2]: ['G, 'G+1] 32;

  for i in 0..NPoints {
    input_bundle{i}{0} = in_split.out{2*i};
    input_bundle{i}{1} = in_split.out{2*i+1};
  }

  // hook up pipelined fft
  FP := new PeaseFFT[NStages, N];
  fp := FP<'G>(input_bundle{0..NPoints}{0..2});

  bundle fp_output_bundle[NPoints*2]: ['G+FP::L, 'G+FP::L+1] 32;

  for i in 0..NPoints {
    fp_output_bundle{2*i} = fp.out{i}{0};
    fp_output_bundle{2*i+1} = fp.out{i}{1};
  }

  fpw := new ConcatBundle[32, NPoints*2]<'G+FP::L>(fp_output_bundle{0..NPoints*2});
  out = fpw.out;

  L := FP::L;
}

/// Standalone FFT module with a toplevel main component
comp main<'G: L>(
  go: interface['G],
  in: ['G, 'G+1] W*NPoints*2
) -> (
  out: ['G+L, 'G+L+1] W*NPoints*2
) with {
  let NStages = 4;
  let N = 1;
  let NPoints = pow2(NStages);
  some L where L > 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} {
  FFT := new BundledFFT[NStages, N];
  fft := FFT<'G>(in);
  L := FFT::L;
  out = fft.out;
}