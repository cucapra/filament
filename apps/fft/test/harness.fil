import "primitives/reshape.fil";
import "../src/fft.fil";

extern "spiral-fft.v" {
  // 16 point fft generated by spiral
  comp dft_top<'G: 1>(
    clk: 1,
    reset: 1,
    X0: ['G, 'G+1] 32, // real part of first input
    X1: ['G, 'G+1] 32, // imaginary part of first input
    X2: ['G, 'G+1] 32,
    X3: ['G, 'G+1] 32,
    X4: ['G, 'G+1] 32,
    X5: ['G, 'G+1] 32,
    X6: ['G, 'G+1] 32,
    X7: ['G, 'G+1] 32,
    X8: ['G, 'G+1] 32,
    X9: ['G, 'G+1] 32,
    X10: ['G, 'G+1] 32,
    X11: ['G, 'G+1] 32,
    X12: ['G, 'G+1] 32,
    X13: ['G, 'G+1] 32,
    X14: ['G, 'G+1] 32,
    X15: ['G, 'G+1] 32,
    X16: ['G, 'G+1] 32,
    X17: ['G, 'G+1] 32,
    X18: ['G, 'G+1] 32,
    X19: ['G, 'G+1] 32,
    X20: ['G, 'G+1] 32,
    X21: ['G, 'G+1] 32,
    X22: ['G, 'G+1] 32,
    X23: ['G, 'G+1] 32,
    X24: ['G, 'G+1] 32,
    X25: ['G, 'G+1] 32,
    X26: ['G, 'G+1] 32,
    X27: ['G, 'G+1] 32,
    X28: ['G, 'G+1] 32,
    X29: ['G, 'G+1] 32,
    X30: ['G, 'G+1] 32,
    X31: ['G, 'G+1] 32
  ) -> (
    Y0: ['G+65, 'G+66] 32, // outputs happen 65 cycles after inputs
    Y1: ['G+65, 'G+66] 32,
    Y2: ['G+65, 'G+66] 32,
    Y3: ['G+65, 'G+66] 32,
    Y4: ['G+65, 'G+66] 32,
    Y5: ['G+65, 'G+66] 32,
    Y6: ['G+65, 'G+66] 32,
    Y7: ['G+65, 'G+66] 32,
    Y8: ['G+65, 'G+66] 32,
    Y9: ['G+65, 'G+66] 32,
    Y10: ['G+65, 'G+66] 32,
    Y11: ['G+65, 'G+66] 32,
    Y12: ['G+65, 'G+66] 32,
    Y13: ['G+65, 'G+66] 32,
    Y14: ['G+65, 'G+66] 32,
    Y15: ['G+65, 'G+66] 32,
    Y16: ['G+65, 'G+66] 32,
    Y17: ['G+65, 'G+66] 32,
    Y18: ['G+65, 'G+66] 32,
    Y19: ['G+65, 'G+66] 32,
    Y20: ['G+65, 'G+66] 32,
    Y21: ['G+65, 'G+66] 32,
    Y22: ['G+65, 'G+66] 32,
    Y23: ['G+65, 'G+66] 32,
    Y24: ['G+65, 'G+66] 32,
    Y25: ['G+65, 'G+66] 32,
    Y26: ['G+65, 'G+66] 32,
    Y27: ['G+65, 'G+66] 32,
    Y28: ['G+65, 'G+66] 32,
    Y29: ['G+65, 'G+66] 32,
    Y30: ['G+65, 'G+66] 32,
    Y31: ['G+65, 'G+66] 32
  );
}

/// FFT that takes in a single wire and outputs a single wire
comp BundledFFT[NStages, N]<'G: L>(
  go: interface['G],
  in[NPoints*2]: ['G, 'G+1] 32, // input bundle
) -> (
  out: ['G+L, 'G+L+1] NPoints*2*32 // output wire
) with {
  let NPoints = pow2(NStages);
  some L where L > 0;
} where
  NPoints % (2*N) == 0,
  N > 0,
  N * 2 <= NPoints,
  NStages > 0
{
  bundle input_bundle[NPoints][2]: ['G, 'G+1] 32;

  for i in 0..NPoints {
    input_bundle{i}{0} = in{2*i};
    input_bundle{i}{1} = in{2*i+1};
  }

  // hook up pipelined fft
  FP := new PeaseFFT[NStages, N];
  fp := FP<'G>(input_bundle{0..NPoints}{0..2});

  bundle fp_output_bundle[NPoints*2]: ['G+FP::L, 'G+FP::L+1] 32;

  for i in 0..NPoints {
    fp_output_bundle{2*i} = fp.out{i}{0};
    fp_output_bundle{2*i+1} = fp.out{i}{1};
  }

  fpw := new ConcatBundle[32, NPoints*2]<'G+FP::L>(fp_output_bundle{0..NPoints*2});
  out = fpw.out;

  L := FP::L;
}

comp main<'G: L>(
  go: interface['G],
  in: ['G, 'G+1] NPoints*2*32 // 16 complex numbers bundled together
) -> (
  spiral: ['G+65, 'G+66] NPoints*2*32, // output from spiral
  fil_pipelined_1: ['G+FP_1L, 'G+FP_1L+1] NPoints*2*32, // output from pipelined pease fft with 1 butterfly
  fil_pipelined_2: ['G+FP_2L, 'G+FP_2L+1] NPoints*2*32, // output from pipelined pease fft with 2 butterflies
  fil_pipelined_4: ['G+FP_4L, 'G+FP_4L+1] NPoints*2*32, // output from pipelined pease fft with 4 butterflies
  fil_pipelined_8: ['G+FP_8L, 'G+FP_8L+1] NPoints*2*32, // output from pipelined pease fft with 8 butterflies
) with {
  let NStages = 4;
  let NPoints = pow2(NStages);

  some FP_8L where FP_8L > 0;
  some FP_4L where FP_4L > 0;
  some FP_2L where FP_2L > 0;
  some FP_1L where FP_1L > 0;

  some L where L > 0, L >= FP_8L, L >= FP_4L, L >= FP_2L, L >= FP_1L;
} where
  L > 0
{
  // needed to typecheck
  assume pow2(4) == 16;

  // split input into bundle
  split := new SplitWire[32, NPoints*2]<'G>(in);

  FP_1 := new BundledFFT[4, 1]<'G>(split.out{0..NPoints*2});
  FP_1L := FP_1::L;
  fil_pipelined_1 = FP_1.out;
  FP_2 := new BundledFFT[4, 2]<'G>(split.out{0..NPoints*2});
  FP_2L := FP_2::L;
  fil_pipelined_2 = FP_2.out;
  FP_4 := new BundledFFT[4, 4]<'G>(split.out{0..NPoints*2});
  FP_4L := FP_4::L;
  fil_pipelined_4 = FP_4.out;
  FP_8 := new BundledFFT[4, 8]<'G>(split.out{0..NPoints*2});
  FP_8L := FP_8::L;
  fil_pipelined_8 = FP_8.out;

  // the more butterflies, the faster
  assume FP_1::L >= FP_2::L;
  assume FP_2::L >= FP_4::L;
  assume FP_4::L >= FP_8::L; 

  L := FP_1::L;

  // hook up spiral dft
  spdft := new dft_top<'G>(
    split.out{0},
    split.out{1},
    split.out{2},
    split.out{3},
    split.out{4},
    split.out{5},
    split.out{6},
    split.out{7},
    split.out{8},
    split.out{9},
    split.out{10},
    split.out{11},
    split.out{12},
    split.out{13},
    split.out{14},
    split.out{15},
    split.out{16},
    split.out{17},
    split.out{18},
    split.out{19},
    split.out{20},
    split.out{21},
    split.out{22},
    split.out{23},
    split.out{24},
    split.out{25},
    split.out{26},
    split.out{27},
    split.out{28},
    split.out{29},
    split.out{30},
    split.out{31}
  );

  bundle spiral_bundle[32]: ['G+65, 'G+66] 32;
  spiral_bundle{0} = spdft.Y0;
  spiral_bundle{1} = spdft.Y1;
  spiral_bundle{2} = spdft.Y2;
  spiral_bundle{3} = spdft.Y3;
  spiral_bundle{4} = spdft.Y4;
  spiral_bundle{5} = spdft.Y5;
  spiral_bundle{6} = spdft.Y6;
  spiral_bundle{7} = spdft.Y7;
  spiral_bundle{8} = spdft.Y8;
  spiral_bundle{9} = spdft.Y9;
  spiral_bundle{10} = spdft.Y10;
  spiral_bundle{11} = spdft.Y11;
  spiral_bundle{12} = spdft.Y12;
  spiral_bundle{13} = spdft.Y13;
  spiral_bundle{14} = spdft.Y14;
  spiral_bundle{15} = spdft.Y15;
  spiral_bundle{16} = spdft.Y16;
  spiral_bundle{17} = spdft.Y17;
  spiral_bundle{18} = spdft.Y18;
  spiral_bundle{19} = spdft.Y19;
  spiral_bundle{20} = spdft.Y20;
  spiral_bundle{21} = spdft.Y21;
  spiral_bundle{22} = spdft.Y22;
  spiral_bundle{23} = spdft.Y23;
  spiral_bundle{24} = spdft.Y24;
  spiral_bundle{25} = spdft.Y25;
  spiral_bundle{26} = spdft.Y26;
  spiral_bundle{27} = spdft.Y27;
  spiral_bundle{28} = spdft.Y28;
  spiral_bundle{29} = spdft.Y29;
  spiral_bundle{30} = spdft.Y30;
  spiral_bundle{31} = spdft.Y31;

  spiral_wire := new ConcatBundle[32, 32]<'G+65>(spiral_bundle{0..32});
  spiral = spiral_wire.out;
}