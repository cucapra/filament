import "primitives/comb.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";
import "primitives/math/math.fil";

comp Zeroes[W, N]<'G:1>() -> (out[N]: ['G, 'G+1] W) {
  for i in 0..N {
    zero := new Const[W, 0]<'G>();
    out{i} = zero.out;
  }
}

// Pads an image with one extra pixel each side
comp Pad[W, N]<'G:1>(in[N][N]: ['G, 'G+1] W) -> (
  out[N+2][N+2]: ['G, 'G+1] W
) where W > 0 {
  out{1..N+1}{1..N+1} = in{0..N}{0..N};

  // top and bottom pad
  zeroN_2 := new Zeroes[W, N+2]<'G>();
  out{0}{0..N+2} = zeroN_2.out{0..N+2};
  out{N+1}{0..N+2} = zeroN_2.out{0..N+2};

  // left and right pad
  zeroN := new Zeroes[W, N]<'G>();
  out{1..N+1}{0} = zeroN.out{0..N};
  out{1..N+1}{N+1} = zeroN.out{0..N};
}

// Performs a guassian blur on 4x4 input and returns 2x2 center pixels.
comp Conv4x4[W]<'G: II>(
    valid_up: interface['G],
    in[4][4]: ['G, 'G+1] W
) -> (
    out[2][2]: ['G+L, 'G+L+1] W
) with {
    /// The latency of the module
    some L where L > 0;
    /// The initiation interval of the module
    some II where II > 0, II < 8;
} where W > 0 {
  zero := new Const[W, 0]<'G+10>();
  out{0}{0} = zero.out;
  out{0}{1} = zero.out;
  out{1}{0} = zero.out;
  out{1}{1} = zero.out;
  L := 10;
  II := 4;
}

// Use the concrete convolution module to convolve a larger image.
// XXX: It should be possible to change the interface of this module
// so that we can guarantee that some tiles in a set of 2x2 rows can
// be provided before the rest of the matrix is ready to be used.
// However, writing that down will be painful (probably).
comp BlurAbs[W, D]<'G:L>(
  en: interface['G],
  in[D][D]: ['G, 'G+L] W
) -> (
  out[D-2][D-2]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
} where W > 0, D > 2, D % 2 == 0 {

  C := new Conv4x4[W];
  let B = D-2;

  // This shows the types of the values produced in the loop below.
  // bundle tiles[B][B][2][2]: for<i, j>
  // ['G+C::II*(6*i+j)+C::L, 'G+C::II*(6*i+j)+C::L+1] W;

  let Max = C::II*B*B + C::L + 1;

  for i in 0..(D-2)/2 {
    for j in 0..(D-2)/2 {
      let ii = 2*i;
      let jj = 2*j;

      let Idx = B*i+j; // Idx of the top-left pixel
      let Start = C::II * Idx;
      let End = Start + C::L;
      conv := C<'G+Start>(in{ii..ii+4}{jj..jj+4});

      // This is essentially a 2-D deserializer.
      // It extracts values from the deserializer and delays them
      // to the last cycle.
      for ti in 0..2 {
        for tj in 0..2 {
          r := new Register[W]<'G+End, 'G+Max+1>(conv.out{ti}{tj});
          out{ii+ti}{jj+tj} = r.out;
        }
      }
    }
  }

  L := Max;
}

/*
// Blurs an 8x8 image for the first level
comp BlurLarge[W]<'G:II>(
  en: interface['G],
  in[10][10]: ['G, 'G+800] W
) -> (
  out[8][8]: ['G+L, 'G+L+1] W
) with {
  some N where N > 0, N <= 16;
  some Chunks where Chunks > 0, Chunks <= 16, Chunks * N == 16;
  some L where L > 0;
  some II where II == 800;
} where W > 0 {
  C := new Conv4x4[W];

  let I = 8;
  let B = I-2;

  // This shows the types of the values produced in the loop below.
  // bundle tiles[D][D][2][2]: for<i, j> ['G+C::II*(6*i+j)+C::L,
  // 'G+C::II*(6*i+j)+C::L+1] W;

  let Max = C::II*B*B+C::L+1;
  for i in 0..B {
    for j in 0..B {
      let Idx = B*i+j; // Idx of the top-left pixel
      let Start = C::II*Idx;
      let End = Start + C::L;
      assert Max > End;
      conv := C<'G+Start>(in{i..i+4}{j..j+4});
      // tiles{i}{j}{0..2}{0..2} = conv.out{0..2}{0..2};

      // This is essentially a deserializer.
      for ti in 0..2 {
        for tj in 0..2 {
          r := new Register[W]<'G+End, 'G+Max+1>(conv.out{ti}{tj});
          out{i+ti}{j+tj} = r.out;
        }
      }
    }
  }

  II := 800;
  L := Max;
}

// Blurs an 4x4 image for the first level
comp BlurSmall[W]<'G:1>(
  en: interface['G],
  in[6][6]: ['G, 'G+1] W
) -> (
  out[4][4]: ['G+L, 'G+L+1] W
) with { some L where L > 0; } where W > 0 {

}
*/

// The upsample step adds zeroes to the quadrant around a pixel.
comp Upsample[W]<'G:1>(
  en: interface['G],
  in[4][4]: ['G, 'G+1] W
) -> (
  out[8][8]: ['G, 'G+1] W
) where W > 0 {

  zero := new Const[W, 0]<'G>();
  for i in 0..4 {
    for j in 0..4 {
      let ii = 2*i; let jj = 2*j;
      out{ii}{jj} = in{i}{j};
      out{ii+1}{jj} = zero.out;
      out{ii}{jj+1} = zero.out;
      out{ii+1}{jj+1} = zero.out;
    }
  }
}

// Downsample the input stream.
comp Downsample2[W]<'G:1>(
  en: interface['G],
  in[8][8]: ['G, 'G+1] W
) -> (
  out[4][4]: ['G, 'G+1] W,
) where W > 0 {
  for i in 0..4 {
    for j in 0..4 {
      out{i}{j} = in{2*i}{2*j};
    }
  }
}

comp ThreeQuarters[W]<'G:1>(
  in: ['G, 'G+1] W
) -> (
  out: ['G+3, 'G+4] W
) where W > 0 {
  three := new Const[W, 3]<'G>();
  times_three := new FastMult[W]<'G>(in, three.out);
  two := new Const[W, 2]<'G+3>();
  shifted := new ShiftRight[W]<'G+3>(times_three.out, two.out);
  out = shifted.out;
}

// Blend together the two levels of the pyramid into one output stream.
// Performs 0.75 * level0 + 0.25 * level1
comp Blend[W]<'G:1>(
  en: interface['G],
  level0[8][8]: ['G, 'G+1] W,
  level1[8][8]: ['G, 'G+1] W
) -> (
  out[8][8]: ['G+L, 'G+L+1] W
) with { some L where L > 0; } where W > 0 {
  for i in 0..8 {
    for j in 0..8 {
      three_quart := new ThreeQuarters[W]<'G>(level0{i}{j});
      delayed := new Shift[W, 3]<'G>(level1{i}{j});
      two := new Const[W, 2]<'G+3>();
      shifted := new ShiftRight[W]<'G+3>(delayed.out, two.out);
      add := new Add[W]<'G+3>(three_quart.out, shifted.out);
      out{i}{j} = add.out;
    }
  }

  L := 3;
}

comp PackImage[W, D0, D1]<'G:1>(
  in[D0][D1]: ['G, 'G+1] W
) -> (
  out: ['G, 'G+1] Out
) with { some Out where Out == D0 * D1 * W; }
  where W > 0, D0 > 0, D1 > 0 {

  bundle dim1[D0]: ['G, 'G+1] D1*W;
  for i in 0..D0 {
    concat := new ConcatBundle[W, D1]<'G>(in{i}{0..D1});
    dim1{i} = concat.out;
  }
  concat_all := new ConcatBundle[W*D1, D0]<'G>(dim1{0..D0});
  out = concat_all.out;

  Out := D0 * D1 * W;
}

comp UnpackImage[W, D0, D1]<'G:1>(
  in: ['G, 'G+1] W*D0*D1
) -> (
  out[D0][D1]: ['G, 'G+1] W
) where W > 0, D0 > 0, D1 > 0 {

  bundle dim1[D0]: ['G, 'G+1] D1*W;
  split := new SplitWire[W*D1, D0]<'G>(in);
  dim1{0..D0} = split.out{0..D0};

  bundle dim2[D0][D1]: ['G, 'G+1] W;
  for i in 0..D0 {
    split_inner := new SplitWire[W, D1]<'G>(dim1{i});
    dim2{i}{0..D1} = split_inner.out{0..D1};
  }
  out{0..D0}{0..D1} = dim2{0..D0}{0..D1};
}

comp Strech2D[W, D0, D1, H]<'G:H>(
  en: interface['G],
  in[D0][D1]: ['G, 'G+1] W
) -> (
  out[D0][D1]: ['G+1, 'G+H+1] W
) where W > 0, D0 > 0, D1 > 0, H > 0 {
  for i in 0..D0 {
    for j in 0..D1 {
      r := new Register[W]<'G, 'G+H+1>(in{i}{j});
      out{i}{j} = r.out;
    }
  }
}

comp Shift2D[W, D0, D1, N]<'G:1>(
  in[D0][D1]: ['G, 'G+1] W
) -> (
  out[D0][D1]: ['G+N, 'G+N+1] W
) where W > 0, D0 > 0, D1 > 0, N > 0 {
  for i in 0..D0 {
    for j in 0..D1 {
      s := new Shift[W, N]<'G>(in{i}{j});
      out{i}{j} = s.out;
    }
  }
}

// A pyramid module takes an 8x8 input to perform the pyramid guass blur and
// returns an output in the same format.
comp Pyramid[W]<'G:II>(
  en: interface['G],
  in[8][8]: ['G, 'G+1] W
) -> (
  out[8][8]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
  some II where II > 0;
} where W > 0 {
  // Level 0
  Pad0 := new Pad[W, 8];
  Blur0 := new BlurAbs[W, 10];
  Stretch0 := new Strech2D[W, 10, 10, Blur0::L];

  pad0 := Pad0<'G>(in{0..8}{0..8});
  stretched0 := Stretch0<'G>(pad0.out{0..10}{0..10});
  level0_pre := Blur0<'G+1>(stretched0.out{0..10}{0..10});

  // Level 1
  let Stage1 = Blur0::L + 1;
  Down := new Downsample2[W];
  Pad1 := new Pad[W, 4];
  Blur1 := new BlurAbs[W, 6];
  Stretch1 := new Strech2D[W, 6, 6, Blur1::L];

  downsampled := Down<'G+Stage1>(level0_pre.out{0..8}{0..8});
  pad1 := Pad1<'G+Stage1>(downsampled.out{0..4}{0..4});
  stretched1 := Stretch1<'G+Stage1>(pad1.out{0..6}{0..6});
  blurred1 := Blur1<'G+Stage1+1>(stretched1.out{0..6}{0..6});

  // Upsampling: fill with zeros and apply a gaussian blur.
  let AfterBlur = Stage1 + Blur1::L + 1;
  Up1 := new Upsample[W];
  PadUp := new Pad[W, 8];
  BlurUp := new BlurAbs[W, 10];
  StretchUp := new Strech2D[W, 10, 10, BlurUp::L];

  up := Up1<'G+AfterBlur>(blurred1.out{0..4}{0..4});
  pad_up := PadUp<'G+AfterBlur>(up.out{0..8}{0..8});
  stretch_up := StretchUp<'G+AfterBlur>(pad_up.out{0..10}{0..10});
  level1 := BlurUp<'G+AfterBlur+1>(stretch_up.out{0..10}{0..10});

  // Blending
  let BlendStart = AfterBlur + BlurUp::L + 1;
  BlendTwo := new Blend[W];
  Level0_Shift := new Shift2D[W, 8, 8, BlendStart - Blur0::L - 1];

  level0 := Level0_Shift<'G+Blur0::L+1>(level0_pre.out{0..8}{0..8});
  blended := BlendTwo<'G+BlendStart>(
    level0.out{0..8}{0..8}, level1.out{0..8}{0..8});

  // Output
  out{0..8}{0..8} = blended.out{0..8}{0..8};

  // Assignments for output parameters bindings.
  L := BlendStart + BlendTwo::L;
  II := if Blur0::L > Blur1::L { Blur0::L } else { Blur1::L };
}

comp main<'G: II>(
  en: interface['G],
  in0_0: ['G, 'G+1] 32,
  in0_1: ['G, 'G+1] 32,
  in0_2: ['G, 'G+1] 32,
  in0_3: ['G, 'G+1] 32,
  in0_4: ['G, 'G+1] 32,
  in0_5: ['G, 'G+1] 32,
  in0_6: ['G, 'G+1] 32,
  in0_7: ['G, 'G+1] 32,
  in1_0: ['G, 'G+1] 32,
  in1_1: ['G, 'G+1] 32,
  in1_2: ['G, 'G+1] 32,
  in1_3: ['G, 'G+1] 32,
  in1_4: ['G, 'G+1] 32,
  in1_5: ['G, 'G+1] 32,
  in1_6: ['G, 'G+1] 32,
  in1_7: ['G, 'G+1] 32,
  in2_0: ['G, 'G+1] 32,
  in2_1: ['G, 'G+1] 32,
  in2_2: ['G, 'G+1] 32,
  in2_3: ['G, 'G+1] 32,
  in2_4: ['G, 'G+1] 32,
  in2_5: ['G, 'G+1] 32,
  in2_6: ['G, 'G+1] 32,
  in2_7: ['G, 'G+1] 32,
  in3_0: ['G, 'G+1] 32,
  in3_1: ['G, 'G+1] 32,
  in3_2: ['G, 'G+1] 32,
  in3_3: ['G, 'G+1] 32,
  in3_4: ['G, 'G+1] 32,
  in3_5: ['G, 'G+1] 32,
  in3_6: ['G, 'G+1] 32,
  in3_7: ['G, 'G+1] 32,
  in4_0: ['G, 'G+1] 32,
  in4_1: ['G, 'G+1] 32,
  in4_2: ['G, 'G+1] 32,
  in4_3: ['G, 'G+1] 32,
  in4_4: ['G, 'G+1] 32,
  in4_5: ['G, 'G+1] 32,
  in4_6: ['G, 'G+1] 32,
  in4_7: ['G, 'G+1] 32,
  in5_0: ['G, 'G+1] 32,
  in5_1: ['G, 'G+1] 32,
  in5_2: ['G, 'G+1] 32,
  in5_3: ['G, 'G+1] 32,
  in5_4: ['G, 'G+1] 32,
  in5_5: ['G, 'G+1] 32,
  in5_6: ['G, 'G+1] 32,
  in5_7: ['G, 'G+1] 32,
  in6_0: ['G, 'G+1] 32,
  in6_1: ['G, 'G+1] 32,
  in6_2: ['G, 'G+1] 32,
  in6_3: ['G, 'G+1] 32,
  in6_4: ['G, 'G+1] 32,
  in6_5: ['G, 'G+1] 32,
  in6_6: ['G, 'G+1] 32,
  in6_7: ['G, 'G+1] 32,
  in7_0: ['G, 'G+1] 32,
  in7_1: ['G, 'G+1] 32,
  in7_2: ['G, 'G+1] 32,
  in7_3: ['G, 'G+1] 32,
  in7_4: ['G, 'G+1] 32,
  in7_5: ['G, 'G+1] 32,
  in7_6: ['G, 'G+1] 32,
  in7_7: ['G, 'G+1] 32,
) -> (
  o0_0: ['G+L, 'G+L+1] 32,
  o0_1: ['G+L, 'G+L+1] 32,
  o0_2: ['G+L, 'G+L+1] 32,
  o0_3: ['G+L, 'G+L+1] 32,
  o0_4: ['G+L, 'G+L+1] 32,
  o0_5: ['G+L, 'G+L+1] 32,
  o0_6: ['G+L, 'G+L+1] 32,
  o0_7: ['G+L, 'G+L+1] 32,
  o1_0: ['G+L, 'G+L+1] 32,
  o1_1: ['G+L, 'G+L+1] 32,
  o1_2: ['G+L, 'G+L+1] 32,
  o1_3: ['G+L, 'G+L+1] 32,
  o1_4: ['G+L, 'G+L+1] 32,
  o1_5: ['G+L, 'G+L+1] 32,
  o1_6: ['G+L, 'G+L+1] 32,
  o1_7: ['G+L, 'G+L+1] 32,
  o2_0: ['G+L, 'G+L+1] 32,
  o2_1: ['G+L, 'G+L+1] 32,
  o2_2: ['G+L, 'G+L+1] 32,
  o2_3: ['G+L, 'G+L+1] 32,
  o2_4: ['G+L, 'G+L+1] 32,
  o2_5: ['G+L, 'G+L+1] 32,
  o2_6: ['G+L, 'G+L+1] 32,
  o2_7: ['G+L, 'G+L+1] 32,
  o3_0: ['G+L, 'G+L+1] 32,
  o3_1: ['G+L, 'G+L+1] 32,
  o3_2: ['G+L, 'G+L+1] 32,
  o3_3: ['G+L, 'G+L+1] 32,
  o3_4: ['G+L, 'G+L+1] 32,
  o3_5: ['G+L, 'G+L+1] 32,
  o3_6: ['G+L, 'G+L+1] 32,
  o3_7: ['G+L, 'G+L+1] 32,
  o4_0: ['G+L, 'G+L+1] 32,
  o4_1: ['G+L, 'G+L+1] 32,
  o4_2: ['G+L, 'G+L+1] 32,
  o4_3: ['G+L, 'G+L+1] 32,
  o4_4: ['G+L, 'G+L+1] 32,
  o4_5: ['G+L, 'G+L+1] 32,
  o4_6: ['G+L, 'G+L+1] 32,
  o4_7: ['G+L, 'G+L+1] 32,
  o5_0: ['G+L, 'G+L+1] 32,
  o5_1: ['G+L, 'G+L+1] 32,
  o5_2: ['G+L, 'G+L+1] 32,
  o5_3: ['G+L, 'G+L+1] 32,
  o5_4: ['G+L, 'G+L+1] 32,
  o5_5: ['G+L, 'G+L+1] 32,
  o5_6: ['G+L, 'G+L+1] 32,
  o5_7: ['G+L, 'G+L+1] 32,
  o6_0: ['G+L, 'G+L+1] 32,
  o6_1: ['G+L, 'G+L+1] 32,
  o6_2: ['G+L, 'G+L+1] 32,
  o6_3: ['G+L, 'G+L+1] 32,
  o6_4: ['G+L, 'G+L+1] 32,
  o6_5: ['G+L, 'G+L+1] 32,
  o6_6: ['G+L, 'G+L+1] 32,
  o6_7: ['G+L, 'G+L+1] 32,
  o7_0: ['G+L, 'G+L+1] 32,
  o7_1: ['G+L, 'G+L+1] 32,
  o7_2: ['G+L, 'G+L+1] 32,
  o7_3: ['G+L, 'G+L+1] 32,
  o7_4: ['G+L, 'G+L+1] 32,
  o7_5: ['G+L, 'G+L+1] 32,
  o7_6: ['G+L, 'G+L+1] 32,
  o7_7: ['G+L, 'G+L+1] 32,
) with {
  some II where II > 0;
  some L where L > 0;
} {
  Pyr := new Pyramid[32];

  bundle in[8][8]: ['G, 'G+1] 32;
  pyr := Pyr<'G>(in{0..8}{0..8});

  bundle o[8][8]: ['G+Pyr::L, 'G+Pyr::L+1] 32;
  o{0..8}{0..8} = pyr.out{0..8}{0..8};

  L := Pyr::L;
  II := Pyr::II;

  in{0}{0} = in0_0; in{0}{1} = in0_1; in{0}{2} = in0_2; in{0}{3} = in0_3;
  in{0}{4} = in0_4; in{0}{5} = in0_5; in{0}{6} = in0_6; in{0}{7} = in0_7;
  in{1}{0} = in1_0; in{1}{1} = in1_1; in{1}{2} = in1_2; in{1}{3} = in1_3;
  in{1}{4} = in1_4; in{1}{5} = in1_5; in{1}{6} = in1_6; in{1}{7} = in1_7;
  in{2}{0} = in2_0; in{2}{1} = in2_1; in{2}{2} = in2_2; in{2}{3} = in2_3;
  in{2}{4} = in2_4; in{2}{5} = in2_5; in{2}{6} = in2_6; in{2}{7} = in2_7;
  in{3}{0} = in3_0; in{3}{1} = in3_1; in{3}{2} = in3_2; in{3}{3} = in3_3;
  in{3}{4} = in3_4; in{3}{5} = in3_5; in{3}{6} = in3_6; in{3}{7} = in3_7;
  in{4}{0} = in4_0; in{4}{1} = in4_1; in{4}{2} = in4_2; in{4}{3} = in4_3;
  in{4}{4} = in4_4; in{4}{5} = in4_5; in{4}{6} = in4_6; in{4}{7} = in4_7;
  in{5}{0} = in5_0; in{5}{1} = in5_1; in{5}{2} = in5_2; in{5}{3} = in5_3;
  in{5}{4} = in5_4; in{5}{5} = in5_5; in{5}{6} = in5_6; in{5}{7} = in5_7;
  in{6}{0} = in6_0; in{6}{1} = in6_1; in{6}{2} = in6_2; in{6}{3} = in6_3;
  in{6}{4} = in6_4; in{6}{5} = in6_5; in{6}{6} = in6_6; in{6}{7} = in6_7;
  in{7}{0} = in7_0; in{7}{1} = in7_1; in{7}{2} = in7_2; in{7}{3} = in7_3;
  in{7}{4} = in7_4; in{7}{5} = in7_5; in{7}{6} = in7_6; in{7}{7} = in7_7;

  o0_0 = o{0}{0}; o0_1 = o{0}{1}; o0_2 = o{0}{2}; o0_3 = o{0}{3};
  o0_4 = o{0}{4}; o0_5 = o{0}{5}; o0_6 = o{0}{6}; o0_7 = o{0}{7};
  o1_0 = o{1}{0}; o1_1 = o{1}{1}; o1_2 = o{1}{2}; o1_3 = o{1}{3};
  o1_4 = o{1}{4}; o1_5 = o{1}{5}; o1_6 = o{1}{6}; o1_7 = o{1}{7};
  o2_0 = o{2}{0}; o2_1 = o{2}{1}; o2_2 = o{2}{2}; o2_3 = o{2}{3};
  o2_4 = o{2}{4}; o2_5 = o{2}{5}; o2_6 = o{2}{6}; o2_7 = o{2}{7};
  o3_0 = o{3}{0}; o3_1 = o{3}{1}; o3_2 = o{3}{2}; o3_3 = o{3}{3};
  o3_4 = o{3}{4}; o3_5 = o{3}{5}; o3_6 = o{3}{6}; o3_7 = o{3}{7};
  o4_0 = o{4}{0}; o4_1 = o{4}{1}; o4_2 = o{4}{2}; o4_3 = o{4}{3};
  o4_4 = o{4}{4}; o4_5 = o{4}{5}; o4_6 = o{4}{6}; o4_7 = o{4}{7};
  o5_0 = o{5}{0}; o5_1 = o{5}{1}; o5_2 = o{5}{2}; o5_3 = o{5}{3};
  o5_4 = o{5}{4}; o5_5 = o{5}{5}; o5_6 = o{5}{6}; o5_7 = o{5}{7};
  o6_0 = o{6}{0}; o6_1 = o{6}{1}; o6_2 = o{6}{2}; o6_3 = o{6}{3};
  o6_4 = o{6}{4}; o6_5 = o{6}{5}; o6_6 = o{6}{6}; o6_7 = o{6}{7};
  o7_0 = o{7}{0}; o7_1 = o{7}{1}; o7_2 = o{7}{2}; o7_3 = o{7}{3};
  o7_4 = o{7}{4}; o7_5 = o{7}{5}; o7_6 = o{7}{6}; o7_7 = o{7}{7};
}
