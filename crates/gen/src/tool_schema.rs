//! Defines the schema for a tool configuration file
use itertools::Itertools;
use serde::Deserialize;
use std::{collections::HashMap, hash::Hash, path::PathBuf};

#[derive(Clone, Debug, Deserialize)]
/// A tool that can generate external modules for Filament
pub struct Tool {
    /// The name of the tool
    pub name: String,
    /// Location of the tool binary
    pub path: String,
    /// The tool can take ${OUT_FILE} parameter and use that generate the module
    /// in the given file.
    pub requires_out_file: Option<bool>,
    /// Mapping that is globablly available to all modules
    pub globals: HashMap<String, String>,
    /// Definitions of modules
    modules: HashMap<String, Module>,
}

impl Tool {
    /// Return a module with the given name
    pub fn get_module(&self, name: &str) -> Option<&Module> {
        self.modules.get(name)
    }

    /// Validate the definition of the tool
    pub fn validate(&self) {
        let path: PathBuf = self.path.as_str().into();
        assert!(
            path.exists(),
            "tool `{}' does not exist at path `{}'",
            self.name,
            self.path
        );

        let mut params = self.globals.clone().into_iter().collect_vec();
        // The NAME_FORMAT parameter is always available.
        params.push(("NAME_FORMAT".into(), "".into()));
        if let Some(true) = self.requires_out_file {
            params.push(("OUT_FILE".into(), "".into()));
        }

        for (name, m) in &self.modules {
            // Fake bindings for parameters to make sure we can parse things
            let params = m
                .parameters
                .iter()
                .map(|p| (p.clone(), "".to_string()))
                .chain(params.clone())
                .collect_vec();
            if let Err(e) = m.name(&params) {
                panic!(
                    "[tool `{}'] Invalid name format for module `{name}': {e}",
                    self.name
                );
            }

            if let Err(e) = m.cli(&params) {
                panic!(
                    "[tool `{}'] Invalid CLI command for module `{name}': {e}",
                    self.name
                );
            }
        }
    }
}

#[derive(Clone, Debug, Deserialize)]
/// A module that can be generated by a tool
pub struct Module {
    /// The parameters used in the module
    pub parameters: Vec<String>,
    /// Format string for generating the name of the module from the parameters
    pub name_format: String,
    /// Format string to invoke the tool
    pub cli_format: String,
    /// The output parameters generated by the tool invocation
    pub outputs: HashMap<String, String>,
}

impl Module {
    /// Substitutes the parameter values in the format string.
    /// A parameter of the form ${param} is replaced with the value of the
    /// parameter.
    /// If a mentioned parameter does not have a value, the function returns an
    /// error with the name of missing parameter.
    fn subst_params(
        fmt_string: String,
        params: &[(String, String)],
    ) -> Result<String, String> {
        let mut result = String::new();
        let mut chars = fmt_string.chars();
        while let Some(c) = chars.next() {
            if c != '$' {
                result.push(c);
                continue;
            }

            // Next character should be {
            assert!(
                chars.by_ref().next() == Some('{'),
                "Expected `{{' after `$'"
            );

            // Parse the next word as the parameter name until we see '}'
            let mut param = String::new();
            while let Some(c) = chars.by_ref().next() {
                if c == '}' {
                    break;
                }
                param.push(c);
            }

            // No word after $
            if param.is_empty() {
                return Err("Expected parameter name after $".to_string());
            }

            // Find the parameter value
            let Some(val) = params.iter().find_map(|(p, val)| {
                if p == &param {
                    Some(val)
                } else {
                    None
                }
            }) else {
                return Err(format!(
                    "Unknown parameter `${param}' in `{fmt_string}'",
                ));
            };
            result.push_str(&val.to_string());
        }
        Ok(result)
    }

    /// The generated name for a tool invocation with specific values of the parameters
    pub fn name(&self, params: &[(String, String)]) -> Result<String, String> {
        Self::subst_params(self.name_format.clone(), params)
    }

    /// The CLI call for a tool invocation with specific values of the parameters
    pub fn cli(&self, params: &[(String, String)]) -> Result<String, String> {
        Self::subst_params(self.cli_format.clone(), params)
    }
}

/// A manifest representing modules to be generated by a tool invocation
#[derive(Clone, Debug, Deserialize)]
pub struct Manifest {
    /// Modules to generated by the tool
    pub modules: Vec<Instance>,
}

/// A particular module to be generated by a tool invocation
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash)]
pub struct Instance {
    /// The name of the module
    pub name: String,
    /// The parameters used in the module
    pub parameters: Vec<String>,
}

impl std::fmt::Display for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}[{}]",
            self.name,
            self.parameters.iter().map(|v| v.to_string()).join(", ")
        )
    }
}

/// The output from a tool invocation
#[derive(Clone, Debug, Deserialize, Default)]
pub struct ToolOutput {
    /// Name of the generated module
    pub name: String,
    /// The file that contains the generated module
    pub file: PathBuf,
    /// The outputs generated by the module
    pub exist_params: HashMap<String, String>,
}
