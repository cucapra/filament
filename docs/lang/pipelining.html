<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pipelining with Filament - Filament</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../start.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">The Filament Language</li><li class="chapter-item expanded "><a href="../lang/tutorial.html"><strong aria-hidden="true">2.</strong> Your First Filament Program</a></li><li class="chapter-item expanded "><a href="../lang/run.html"><strong aria-hidden="true">3.</strong> Running Filament Designs</a></li><li class="chapter-item expanded "><a href="../lang/pipelining.html" class="active"><strong aria-hidden="true">4.</strong> Pipelining with Filament</a></li><li class="chapter-item expanded "><a href="../lang/external.html"><strong aria-hidden="true">5.</strong> Using Verilog Modules in Filament</a></li><li class="chapter-item expanded affix "><li class="part-title">Metaprogramming with Filament</li><li class="chapter-item expanded "><a href="../meta/overview.html"><strong aria-hidden="true">6.</strong> Metaprogramming Overview</a></li><li class="chapter-item expanded "><a href="../meta/loops-and-bundles.html"><strong aria-hidden="true">7.</strong> Loops and Bundles</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Filament</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pipelining-with-filament"><a class="header" href="#pipelining-with-filament">Pipelining with Filament</a></h1>
<p>While we've designed <a href="./tutorial.html">a correct ALU</a>, it is quite slow: it processes one input completely before moving on to the next.
Such a hardware design is called a &quot;fully sequential&quot;.
A standard technique to improve throughput of the design is <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/pipelining/index.html">pipelining</a>, which allows a hardware module to process multiple inputs at the same time.</p>
<p>Filament is designed so that check that a pipeline can support the throughput specified in its interface.
We'll take our <a href="./tutorial.html#a-correct-implementation">sequential ALU</a> design and use Filament's type system to guide us to a correctly pipelined design.
Before that, however, let's run the design and see how it performs:</p>
<pre><code class="language-bash">fud e --to cocotb-out examples/tut-seq.fil \
      -s cocotb.data examples/data.json \
      -s calyx.flags ' -d canonicalize'
</code></pre>
<p>Which generates the following output:</p>
<pre><code>{&quot;out&quot;: {&quot;0&quot;: [28], &quot;1&quot;: [10], &quot;2&quot;: [66], &quot;3&quot;: [16]}, &quot;cycles&quot;: 12}
</code></pre>
<p>Note that this sequential design takes 12 cycles to process 4 inputs.</p>
<p>We'll start with pipelining our program:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;./sequential.fil&quot;;

/// ANCHOR: sig
comp main&lt;G: 3&gt;(
/// ANCHOR_END: sig
    @interface[G] go: 1,
    @[G, G+3] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+2, G+3] out: 32)
{
    A := new Add[32];
    M := new Mult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+3&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<h2 id="delays-and-throughput"><a class="header" href="#delays-and-throughput">Delays and Throughput</a></h2>
<p>Filament uses an event's <em>delay</em> to determine when the module is can accept new inputs.</p>
<pre><code class="language-filament">comp main&lt;G: 3&gt;(
</code></pre>
<p>Note that the delay for the event <code>G</code> is <code>3</code> which indicates to Filament that the ALU process new inputs every three cycles.
We can tell Filament that we instead want a module that can process new inputs every cycle by changing the delay to <code>1</code>:</p>
<pre><code class="language-filament">comp main&lt;G: 1&gt;(
</code></pre>
<p>And run the compiler:</p>
<pre><code>cargo run -- alu.fil
</code></pre>
<p>However, much to our dismay, Filament tells us that this program cannot be pipelined to achieve throughput 1.
However, being the nice type checker it is, it will tell us <em>exactly why</em> the design cannot be pipelined in the form of type errors.</p>
<p>Let's work through each error and see how we can fix it.</p>
<h3 id="availability-intervals-of-ports"><a class="header" href="#availability-intervals-of-ports">Availability Intervals of Ports</a></h3>
<p>The first error message points out that one of the inputs is required for three cycles, but the module may re-execute every cycle:</p>
<pre><code>error: delay must be longer than the length of the signal
  ┌─ examples/tut-pipe-wrong-1.fil:8:5
  │
5 │ comp main&lt;G: 1&gt;(
  │           - interface allows event to trigger every 1 cycle(s)
  ·
8 │     @[G, G+3] op: 1,
  │     ^^^^^^^^^ signal lasts for 3 cycle(s)

error: event provided to invocation triggers more often that invocation's event's delay allows
</code></pre>
<p>This is problematic because <code>op</code> represents a <em>physical wire</em>; it is incapable of holding multiple values.
Our request to process inputs every cycle <em>and</em> have <code>op</code> last for three cycles is physically impossible.
The fix is easy: looking at our original design, we see that <code>op</code> is only used by the multiplexer in the interval [G+2, G+3) so we can change the availability interval of <code>op</code> to be [G+2, G+3).</p>
<blockquote>
<p>Note: If this step feel like divine insight, another way to reach the same conclusion is by changing the availability interval of <code>op</code> to be [G, G+1) which will cause the compiler to point out all availability intervals where <code>op</code> is used.</p>
</blockquote>
<h3 id="delays-of-subcomponents"><a class="header" href="#delays-of-subcomponents">Delays of Subcomponents</a></h3>
<p>The second error message points out that the ALU component may execute every cycle but the multiplier we used can only execute every two cycles:</p>
<pre><code>error: event provided to invocation triggers more often that invocation's event's delay allows
   ┌─ examples/tut-pipe-wrong-1.fil:15:13
   │
 5 │ comp main&lt;G: 1&gt;(
   │              - this event triggers every 1 cycles
   ·
15 │     m0 := M&lt;G&gt;(left, right);
   │             ^ event provided to invoke triggers too often
   │
   ┌─ examples/./sequential.fil:3:18
   │
 3 │ comp Mult[#W]&lt;G: 2&gt;(
   │                  - invocation's event is allowed to trigger every 2 cycles
</code></pre>
<p>Yet again, our request is physically impossible to satisfy: our multiplier circuit is fundamentally incapable of executing every cycle.
Thankfully for us, the <code>primitives/math.fil</code> file provides a component called <code>FastMult</code> which does have delay 1:</p>
<pre><code class="language-filament">/// Implementation of a multiplier with initiation interval 1 and latency 3.
/// Written in a way to allow Vivado to infer a DSP.
comp FastMult[#W]&lt;G: 1&gt;(
  @[G, G+1] left: #W,
  @[G, G+1] right: #W,
) -&gt; (
  @[G+3, G+4] out: #W,
) where #W &gt; 0
</code></pre>
<p>We can change out program to use this component instead:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;./sequential.fil&quot;;

comp main&lt;G: 1&gt;(
    @interface[G] go: 1,
    @[G+2, G+3] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+2, G+3] out: 32)
{
    A := new Add[32];
    M := new FastMult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+3&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<p>However, in making this change, we've created a new problem for ourselves:</p>
<pre><code>error: source port must be available longer than the destination port requires
    ┌─ examples/tut-pipe-wrong-2.fil:18:40
    │
 18 │     mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    │                                        ^^^^^^ source is available for @[G+3, G+4]
    │
    ┌─ ./primitives/./comb.fil:170:13
    │
170 │     @[G, L] in1: #WIDTH,
    │             --- destination's requirement @[G+2, G+3]
</code></pre>
<p>Filament tells us that <code>FastMult</code>'s <code>out</code> port is available in the interval [G+3, G+4) instead of [G+2, G+3) for <code>Mult</code>, i.e., the latency of <code>FastMult</code> is different from the latency of <code>Mult</code>.</p>
<p>Filament catching this bug is important-it would be very easy to miss such a mistake in a Verilog program.
Fixing it is quite mechanical:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;./sequential.fil&quot;;

comp main&lt;G: 1&gt;(
    @interface[G] go: 1,
    @[G+3, G+4] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+3, G+4] out: 32)
{
    A := new Add[32];
    M := new FastMult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+4&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+3&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<h3 id="registers-that-hold-on-for-too-long"><a class="header" href="#registers-that-hold-on-for-too-long">Registers that Hold on for too Long</a></h3>
<p>The final problem is quite similar to the previous one:</p>
<pre><code>error: event provided to invocation triggers more often that invocation's event's delay allows
   ┌─ examples/tut-pipe-wrong-3.fil:16:28
   │
 4 │ comp main&lt;G: 1&gt;(
   │              - this event triggers every 1 cycles
   ·
16 │     r0 := new Register[32]&lt;G, G+4&gt;(a0.out);
   │                            ^ event provided to invoke triggers too often
   │
   ┌─ ./primitives/./state.fil:4:28
   │
 4 │   comp Register[#WIDTH]&lt;G: L-(G+1), L: 1&gt;(
   │                            ------- invocation's event is allowed to trigger every 3 cycles

Compilation failed with 1 errors.
</code></pre>
<p>The compiler is telling us the register's delay is 3 cycles.
However, unlike the multiplier, this is a consequence of our decision: we make the register hold on to its value for three cycles which increases its delay.
The last line of the error message points to the problem: the delay of a register <em>depends on how we use it</em>; this means that if we make it hold onto a value for exactly one cycle, its delay is reduced to one.</p>
<p>However, the problem is that we need the computation from the adder to be available three cycles from when it starts.
To get both the pipelining and correctness we want, we need to instantiate a <em>chain of registers</em> that feed values forward.</p>
<p>The intuition behind this is that because we want our ALU to process inputs every cycle, we need to &quot;save&quot; the computation in every cycle and push it forward.</p>
<p>The final program will look like this:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;./sequential.fil&quot;;

comp main&lt;G: 1&gt;(
    @interface[G] go: 1,
    @[G+3, G+4] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+3, G+4] out: 32) {
    A := new Add[32];
    M := new FastMult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    r0 := new Register[32]&lt;G, G+2&gt;(a0.out);
    r1 := new Register[32]&lt;G+1, G+3&gt;(r0.out);
    r2 := new Register[32]&lt;G+2, G+4&gt;(r1.out);
    mx := new Mux[32]&lt;G+3&gt;(op, r2.out, m0.out);
    out = mx.out;
}
</code></pre>
<h2 id="running-the-pipelined-design"><a class="header" href="#running-the-pipelined-design">Running the Pipelined Design</a></h2>
<p>Now to the moment of truth: let's run the design and see how it performs:</p>
<pre><code class="language-bash">fud e --to cocotb-out examples/tut-pipe.fil \
      -s cocotb.data examples/data.json \
      -s calyx.flags ' -d canonicalize'
</code></pre>
<p>We get the following output which shows that the design took only 7 cycles to process 4 inputs:</p>
<pre><code>{&quot;out&quot;: {&quot;0&quot;: [28], &quot;1&quot;: [10], &quot;2&quot;: [66], &quot;3&quot;: [16]}, &quot;cycles&quot;: 7}
</code></pre>
<p>If you're still not convinced, try adding <a href="./run.html#data-format">another transaction</a> to the data file in <code>examples/data.json</code> and see how the cycle count for the original sequential and pipelined designs change.</p>
<h2 id="something-remarkable"><a class="header" href="#something-remarkable">Something Remarkable</a></h2>
<p>During the process of pipelining, we all of our time looking at type errors.
Once the program type checked, it produced the correct output <em>and</em> was correctly pipelined.
Filament supports many other features but at its heart, this is the guarantee it provides: if your program type checks, it is correctly pipelined.
Fast and correct, you can have both!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../lang/run.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../lang/external.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../lang/run.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../lang/external.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>
        <script src="../static/custom-highlight.js"></script>


    </div>
    </body>
</html>
