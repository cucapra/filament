import "primitives/core.fil";

// XXX: We need #L because we can't say #W-1
comp Next[#W, #L]<G: 1>(
  @[G, G+1] acc: #W+1,
  @[G, G+1] right: #W,
  @[G, G+1] quotient: #W,
) -> (
  @[G, G+1] acc_next: #W+1,
  @[G, G+1] quotient_next: #W,
) where #W > 0, #W = #L + 1 {

  /*
  assign right_ext = {1'b0, right};
  assign check = acc >= right_ext;

  // True branch
  assign sub = acc - right;
  assign c = check ? {sub[7:0], quotient, 1'b1} : ({acc, quotient} << 1);

  assign quotient_next = c[7:0];
  assign acc_next = c[16:8];
  */

  right_ext := new ZeroExtend[#W, #W+1]<G>(right);
  check := new Gte[#W+1]<G>(acc, right_ext.out);

  // True branch
  sub := new Sub[#W+1]<G>(acc, right_ext.out);
  sub_slice := new Slice[#W+1, #L, 0, #W]<G>(sub.out);
  one_1 := new Const[1, 1]<G>();
  true_con_0 := new Concat[#W, 1, #W+1]<G>(quotient, one_1.out);
  true_con := new Concat[#W, #W+1, #W+#W+1]<G>(sub_slice.out, true_con_0.out);

  // False branch
  fal_con := new Concat[#W+1, #W, #W+#W+1]<G>(acc, quotient);
  one_WW1 := new Const[#W+#W+1, 1]<G>();
  fal_sh := new ShiftLeft[#W+#W+1]<G>(fal_con.out, one_WW1.out);

  c := new Mux[#W+#W+1]<G>(check.out, true_con.out, fal_sh.out);

  acc_slice := new Slice[#W+#W+1, #W+#W, #W, #W+1]<G>(c.out);
  q_slice := new Slice[#W+#W+1, #W, 0, #W]<G>(c.out);

  quotient_next = q_slice.out;
  acc_next = acc_slice.out;
}

comp Init[#W]<G: 1>(
  @[G, G+1] left: #W,
) -> (
  @[G, G+1] acc: #W+1,
  @[G, G+1] quotient: #W,
) where #W > 0 {
  zero_one := new Const[1, 0]<G>();
  c := new Concat[#W, 1, #W+1]<G>(left, zero_one.out);
  c_ext := new ZeroExtend[#W+1, #W+#W+1]<G>(c.out);
  acc_slice := new Slice[#W+#W+1, #W+#W, #W, #W+1]<G>(c_ext.out);
  q_slice := new Slice[#W+#W+1, #W, 0, #W]<G>(c_ext.out);

  acc = acc_slice.out;
  quotient = q_slice.out;
}

comp CombNoShareIterDiv<G: 1>(
  @interface[G] go: 1,
  @[G, G+1] left: 8,
  @[G, G+1] right: 8
) -> (
  @[G, G+1] quotient: 8
) {
  i := new Init[8]<G>(left);
  s0 := new Next[8, 7]<G>(i.acc, right, i.quotient);
  // Iterate 7 more times
  s1 := new Next[8, 7]<G>(s0.acc_next, right, s0.quotient_next);
  s2 := new Next[8, 7]<G>(s1.acc_next, right, s1.quotient_next);
  s3 := new Next[8, 7]<G>(s2.acc_next, right, s2.quotient_next);
  s4 := new Next[8, 7]<G>(s3.acc_next, right, s3.quotient_next);
  s5 := new Next[8, 7]<G>(s4.acc_next, right, s4.quotient_next);
  s6 := new Next[8, 7]<G>(s5.acc_next, right, s5.quotient_next);
  s7 := new Next[8, 7]<G>(s6.acc_next, right, s6.quotient_next);
  quotient = s7.quotient_next;
}

comp ShareIterDiv<G: 7>(
  @interface[G] go: 1,
  @[G, G+1] left: 8,
  @[G, G+1] right: 8,
) -> (
  @[G+7, G+8] quotient: 8
) {
  i := new Init[8]<G>(left);
  s0 := new Next[8, 7]<G>(i.acc, right, i.quotient);

  N := new Next[8, 7];
  Acc := new Register[9];
  QN := new Register[8];
  R := new Register[8];

  acc0 := Acc<G, G+2>(s0.acc_next);
  qn0 := QN<G, G+2>(s0.quotient_next);
  r0 := R<G, G+2>(right);
  s1 := N<G+1>(acc0.out, r0.out, qn0.out);

  acc1 := Acc<G+1, G+3>(s1.acc_next);
  qn1 := QN<G+1, G+3>(s1.quotient_next);
  r1 := R<G+1, G+3>(r0.out);
  s2 := N<G+2>(acc1.out, r1.out, qn1.out);

  acc2 := Acc<G+2, G+4>(s2.acc_next);
  qn2 := QN<G+2, G+4>(s2.quotient_next);
  r2 := R<G+2, G+4>(r1.out);
  s3 := N<G+3>(acc2.out, r2.out, qn2.out);

  acc3 := Acc<G+3, G+5>(s3.acc_next);
  qn3 := QN<G+3, G+5>(s3.quotient_next);
  r3 := R<G+3, G+5>(r2.out);
  s4 := N<G+4>(acc3.out, r3.out, qn3.out);

  acc4 := Acc<G+4, G+6>(s4.acc_next);
  qn4 := QN<G+4, G+6>(s4.quotient_next);
  r4 := R<G+4, G+6>(r3.out);
  s5 := N<G+5>(acc4.out, r4.out, qn4.out);

  acc5 := Acc<G+5, G+7>(s5.acc_next);
  qn5 := QN<G+5, G+7>(s5.quotient_next);
  r5 := R<G+5, G+7>(r4.out);
  s6 := N<G+6>(acc5.out, r5.out, qn5.out);

  acc6 := Acc<G+6, G+8>(s6.acc_next);
  qn6 := QN<G+6, G+8>(s6.quotient_next);
  r6 := R<G+6, G+8>(r5.out);
  s7 := N<G+7>(acc6.out, r6.out, qn6.out);

  // Iterate 7 more times
  quotient = s7.quotient_next;
}

comp PipeIterDiv<G: 1>(
  @interface[G] go: 1,
  @[G, G+1] left: 8,
  @[G, G+1] right: 8,
) -> (
  @[G+7, G+8] quotient: 8
) {
  i := new Init[8]<G>(left);
  s0 := new Next[8, 7]<G>(i.acc, right, i.quotient);

  acc0 := new Register[9]<G, G+2>(s0.acc_next);
  qn0 := new Register[8]<G, G+2>(s0.quotient_next);
  r0 := new Register[8]<G, G+2>(right);
  s1 := new Next[8, 7]<G+1>(acc0.out, r0.out, qn0.out);

  acc1 := new Register[9]<G+1, G+3>(s1.acc_next);
  qn1 := new Register[8]<G+1, G+3>(s1.quotient_next);
  r1 := new Register[8]<G+1, G+3>(r0.out);
  s2 := new Next[8, 7]<G+2>(acc1.out, r1.out, qn1.out);

  acc2 := new Register[9]<G+2, G+4>(s2.acc_next);
  qn2 := new Register[8]<G+2, G+4>(s2.quotient_next);
  r2 := new Register[8]<G+2, G+4>(r1.out);
  s3 := new Next[8, 7]<G+3>(acc2.out, r2.out, qn2.out);

  acc3 := new Register[9]<G+3, G+5>(s3.acc_next);
  qn3 := new Register[8]<G+3, G+5>(s3.quotient_next);
  r3 := new Register[8]<G+3, G+5>(r2.out);
  s4 := new Next[8, 7]<G+4>(acc3.out, r3.out, qn3.out);

  acc4 := new Register[9]<G+4, G+6>(s4.acc_next);
  qn4 := new Register[8]<G+4, G+6>(s4.quotient_next);
  r4 := new Register[8]<G+4, G+6>(r3.out);
  s5 := new Next[8, 7]<G+5>(acc4.out, r4.out, qn4.out);

  acc5 := new Register[9]<G+5, G+7>(s5.acc_next);
  qn5 := new Register[8]<G+5, G+7>(s5.quotient_next);
  r5 := new Register[8]<G+5, G+7>(r4.out);
  s6 := new Next[8, 7]<G+6>(acc5.out, r5.out, qn5.out);

  acc6 := new Register[9]<G+6, G+8>(s6.acc_next);
  qn6 := new Register[8]<G+6, G+8>(s6.quotient_next);
  r6 := new Register[8]<G+6, G+8>(r5.out);
  s7 := new Next[8, 7]<G+7>(acc6.out, r6.out, qn6.out);

  // Iterate 7 more times
  quotient = s7.quotient_next;
}
