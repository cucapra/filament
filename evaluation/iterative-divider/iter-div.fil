import "primitives/core.fil";

// XXX: We need #L because we can't say #W-1
comp Next[#W, #L]<G: 1>(
  @[G, G+1] acc: #W+1,
  @[G, G+1] right: #W,
  @[G, G+1] quotient: #W,
) -> (
  @[G, G+1] acc_next: #W+1,
  @[G, G+1] quotient_next: #W,
) where #W > 0, #W = #L + 1 {

  /*
  assign right_ext = {1'b0, right};
  assign check = acc >= right_ext;

  // True branch
  assign sub = acc - right;
  assign c = check ? {sub[7:0], quotient, 1'b1} : ({acc, quotient} << 1);

  assign quotient_next = c[7:0];
  assign acc_next = c[16:8];
  */

  right_ext := new ZeroExtend[#W, #W+1]<G>(right);
  check := new Gte[#W+1]<G>(acc, right_ext.out);

  // True branch
  sub := new Sub[#W+1]<G>(acc, right_ext.out);
  sub_slice := new Slice[#W+1, #L, 0, #W]<G>(sub.out);
  one_1 := new Const[1, 1]<G>();
  true_con_0 := new Concat[#W, 1, #W+1]<G>(quotient, one_1.out);
  true_con := new Concat[#W, #W+1, #W+#W+1]<G>(sub_slice.out, true_con_0.out);

  // False branch
  fal_con := new Concat[#W+1, #W, #W+#W+1]<G>(acc, quotient);
  one_WW1 := new Const[#W+#W+1, 1]<G>();
  fal_sh := new ShiftLeft[#W+#W+1]<G>(fal_con.out, one_WW1.out);

  c := new Mux[#W+#W+1]<G>(check.out, true_con.out, fal_sh.out);

  acc_slice := new Slice[#W+#W+1, #W+#W, #W, #W+1]<G>(c.out);
  q_slice := new Slice[#W+#W+1, #W, 0, #W]<G>(c.out);

  quotient_next = q_slice.out;
  acc_next = acc_slice.out;
}

comp Init[#W]<G: 1>(
  @[G, G+1] left: #W,
) -> (
  @[G, G+1] acc: #W+1,
  @[G, G+1] quotient: #W,
) where #W > 0 {
  zero_one := new Const[1, 0]<G>();
  c := new Concat[#W, 1, #W+1]<G>(left, zero_one.out);
  c_ext := new ZeroExtend[#W+1, #W+#W+1]<G>(c.out);
  acc_slice := new Slice[#W+#W+1, #W+#W, #W, #W+1]<G>(c_ext.out);
  q_slice := new Slice[#W+#W+1, #W, 0, #W]<G>(c_ext.out);

  acc = acc_slice.out;
  quotient = q_slice.out;
}

comp CombNoShareIterDiv[#W, #L]<G: 1>(
  @interface[G] go: 1,
  @[G, G+1] left: #W,
  @[G, G+1] right: #W,
) -> (
  @[G, G+1] quotient: #W
) where #W > 0, #W = #L + 1 {
  bundle acc[#W+1]: for<#i> @[G, G+1] #W+1;
  bundle quotient_next[#W+1]: for<#i> @[G, G+1] #W;

  // Initialize the accumulator and quotient
  init := new Init[#W]<G>(left);
  acc{0} = init.acc;
  quotient_next{0} = init.quotient;

  for #i in 0..#W {
    s := new Next[#W, #L]<G>(acc{#i}, right, quotient_next{#i});
    acc{#i+1} = s.acc_next;
    quotient_next{#i+1} = s.quotient_next;
  }

  quotient = quotient_next{#W};
}

comp ShareIterDiv[#W, #L]<G: #W>(
  @interface[G] go: 1,
  @[G, G+1] left: #W,
  @[G, G+1] right: #W,
) -> (
  @[G+#W, G+#W+1] quotient: #W
) where #W > 0, #W = #L + 1 {
  bundle acc[#W+1]: for<#i> @[G+#i, G+#i+1] #W+1;
  bundle qn[#W+1]: for<#i> @[G+#i, G+#i+1] #W;
  bundle r[#W+1]: for<#i> @[G+#i, G+#i+1] #W;

  i := new Init[#W]<G>(left);
  acc{0} = i.acc;
  qn{0} = i.quotient;
  r{0} = right;

  N := new Next[#W, #L];
  Acc := new Delay[#W+1];
  QN := new Delay[#W];
  R := new Delay[#W];

  for #i in 0..#W {
    s := N<G+#i>(acc{#i}, r{#i}, qn{#i});
    acc_reg := Acc<G+#i>(s.acc_next);
    acc{#i+1} = acc_reg.out;
    qn_reg := QN<G+#i>(s.quotient_next);
    qn{#i+1} = qn_reg.out;
    r_reg := R<G+#i>(r{#i});
    r{#i+1} = r_reg.out;
  }

  // Iterate 7 more times
  quotient = qn{#W};
}

comp PipeIterDiv[#W, #L]<G: 1>(
  @interface[G] go: 1,
  @[G, G+1] left: #W,
  @[G, G+1] right: #W,
) -> (
  @[G+#W, G+#W+1] quotient: #W
) where #W > 0, #W = #L + 1 {
  bundle acc[#W+1]: for<#i> @[G+#i, G+#i+1] #W+1;
  bundle qn[#W+1]: for<#i> @[G+#i, G+#i+1] #W;
  bundle r[#W+1]: for<#i> @[G+#i, G+#i+1] #W;

  i := new Init[#W]<G>(left);
  acc{0} = i.acc;
  qn{0} = i.quotient;
  r{0} = right;

  for #i in 0..#W {
    s := new Next[#W, #L]<G+#i>(acc{#i}, r{#i}, qn{#i});
    acc_reg := new Delay[#W+1]<G+#i>(s.acc_next);
    acc{#i+1} = acc_reg.out;
    qn_reg := new Delay[#W]<G+#i>(s.quotient_next);
    qn{#i+1} = qn_reg.out;
    r_reg := new Delay[#W]<G+#i>(r{#i});
    r{#i+1} = r_reg.out;
  }

  // This unecessarily registers the last value of the quotient increasing the
  // latency by 1 increasing the latency by 1.

  quotient = qn{#W};
}
