//! Defines the schema for a tool configuration file
use serde::Deserialize;
use std::{collections::HashMap, path::PathBuf};

#[derive(Clone, Debug, Deserialize)]
/// A tool that can generate external modules for Filament
pub struct Tool {
    /// The name of the tool
    pub name: String,
    /// Location of the tool binary
    pub path: PathBuf,
    /// Definitions of modules
    pub modules: HashMap<String, Module>,
}

#[derive(Clone, Debug, Deserialize)]
/// A module that can be generated by a tool
pub struct Module {
    /// The parameters used in the module
    pub parameters: Vec<String>,
    /// Format string for generating the name of the module from the parameters
    pub name_format: String,
    /// Format string to invoke the tool
    pub cli_format: String,
    /// The output parameters generated by the tool invocation
    pub outputs: HashMap<String, String>,
}

impl Module {
    /// Substitutes the parameter values in the format string.
    /// A parameter of the form $param is replaced with the value of the
    /// parameter.
    /// If a mentioned parameter does not have a value, the function returns an
    /// error with the name of missing parameter.
    fn subst_params(
        fmt_string: String,
        params: &[(String, u64)],
    ) -> Result<String, String> {
        let mut result = String::new();
        let mut chars = fmt_string.chars();
        while let Some(c) = chars.next() {
            if c != '$' {
                result.push(c);
                continue;
            }

            // Parse the next word
            let mut param = String::new();
            let mut last_char = None;
            for c in chars.by_ref() {
                if c.is_alphanumeric() {
                    param.push(c);
                } else {
                    last_char = Some(c);
                    break;
                }
            }

            // No word after $
            if param.is_empty() {
                return Err("Expected parameter name after $".to_string());
            }

            // Find the parameter value
            let Some(val) = params.iter().find_map(|(p, val)| {
                if p == &param {
                    Some(val)
                } else {
                    None
                }
            }) else {
                return Err(format!("Unknown parameter `${}'", param));
            };
            result.push_str(&val.to_string());
            result.push(last_char.unwrap());
        }
        Ok(result)
    }

    /// The generated name for a tool invocation with specific values of the parameters
    pub fn name(&self, params: &[(String, u64)]) -> Result<String, String> {
        Self::subst_params(self.name_format.clone(), params)
    }

    /// The CLI call for a tool invocation with specific values of the parameters
    pub fn cli(&self, params: &[(String, u64)]) -> Result<String, String> {
        Self::subst_params(self.cli_format.clone(), params)
    }
}

/// A manifest representing modules to be generated by a tool invocation
#[derive(Clone, Debug, Deserialize)]
pub struct Manifest {
    /// Modules to generated by the tool
    pub modules: Vec<Instance>,
}

/// A particular module to be generated by a tool invocation
#[derive(Clone, Debug, Deserialize)]
pub struct Instance {
    /// The name of the module
    pub name: String,
    /// The parameters used in the module
    pub parameters: Vec<u64>,
}

/// The output from a tool invocation
#[derive(Clone, Debug, Deserialize)]
pub struct ToolOutput {
    /// The file that contains the generated module
    pub file: PathBuf,
    /// The outputs generated by the module
    pub info: HashMap<String, String>,
}
