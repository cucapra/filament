component RightShifter_32<"nointerface"=1>(@data in: 32, @data shamt: 32, @data isArith: 1, @reset reset: 1, @clk clk: 1) -> (@data out: 32) {
  cells {
    @data SRA = ArithShiftRight(32);
    @data SRL = ShiftRight(32);
    @data MUX = Mux(32);
  }
  wires {
    SRA.in = in;
    SRA.shift = shamt;
    SRL.in = in;
    SRL.shift = shamt;
    MUX.sel = isArith;
    MUX.in0 = SRA.out;
    MUX.in1 = SRL.out;
    out = MUX.out;
  }

  control {}
}


extern "../src/extras/extras.sv" {
  primitive OneHotMux[WIDTH](@data sel: 8, @data in0: WIDTH, @data in1: WIDTH, @data in2: WIDTH, @data in3: WIDTH, @data in4: WIDTH, @data in5: WIDTH, @data in6: WIDTH, @data in7: WIDTH) -> (@data out: WIDTH);
}

extern "../../primitives/state.sv" {
  primitive Register[WIDTH](@data in: WIDTH, @fil_event write_en: 1, @clk clk: 1, @reset reset: 1) -> (@data out: WIDTH);
  primitive Delay[WIDTH](@data in: WIDTH, @clk clk: 1, @reset reset: 1) -> (@data out: WIDTH);
  primitive Prev[WIDTH, SAFE](@data in: WIDTH, @fil_event write_en: 1, @clk clk: 1, @reset reset: 1) -> (@data prev: WIDTH);
  primitive ContPrev[WIDTH, SAFE](@data in: WIDTH, @clk clk: 1, @reset reset: 1) -> (@data prev: WIDTH);
}

extern "../../primitives/comb.sv" {
  primitive Const[WIDTH, VALUE]() -> (@data out: WIDTH);
  primitive Add[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: WIDTH);
  primitive Sub[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: WIDTH);
  primitive MultComb[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: WIDTH);
  primitive And[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: WIDTH);
  primitive Or[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: WIDTH);
  primitive Xor[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: WIDTH);
  primitive Not[WIDTH](@data in: WIDTH) -> (@data out: WIDTH);
  primitive Eq[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: 1);
  primitive Gt[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: 1);
  primitive Lt[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: 1);
  primitive Lte[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: 1);
  primitive Gte[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (@data out: 1);
  primitive ZeroExtend[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (@data out: OUT_WIDTH);
  primitive Concat[LEFT, RIGHT, OUT](@data left: LEFT, @data right: RIGHT) -> (@data out: OUT);
  primitive Select[WIDTH, POS](@data in: WIDTH) -> (@data out: 1);
  primitive Slice[IN_WIDTH, MSB, LSB, OUT_WIDTH](@data in: IN_WIDTH) -> (@data out: OUT_WIDTH);
  primitive ReduceAnd[WIDTH](@data in: WIDTH) -> (@data out: 1);
  primitive ReduceOr[WIDTH](@data in: WIDTH) -> (@data out: 1);
  primitive ShiftLeft[WIDTH](@data in: WIDTH, @data shift: WIDTH) -> (@data out: WIDTH);
  primitive ShiftRight[WIDTH](@data in: WIDTH, @data shift: WIDTH) -> (@data out: WIDTH);
  primitive ArithShiftRight[WIDTH](@data in: WIDTH, @data shift: WIDTH) -> (@data out: WIDTH);
  primitive Mux[WIDTH](@data sel: 1, @data in0: WIDTH, @data in1: WIDTH) -> (@data out: WIDTH);
  primitive Extend[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (@data out: OUT_WIDTH);
}

extern "../src/regfile.sv" {
  primitive RegFile(@reset @data reset: 1, @data en: 1, @data rd: 5, @data data: 32, @data rin1: 5, @data rin2: 5, @clk clk: 1) -> (@data rs1: 32, @data rs2: 32);
}


