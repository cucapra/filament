import "primitives/core.fil";

// ALU

// comp main<G:1> (
//   @[G,G+1] inA:32,
//   @[G,G+1] inB:32,
//   @[G,G+1] funct:8,
//   @[G,G+1] isAdd:1,
//   @[G,G+1] isArith:1
// ) -> (
//   @[G,G+1] out:32
// ) {
//   alu := new alu<G>(inA, inB, funct, isAdd, isArith);
//   out = alu.out;
// }

comp alu<G: L-(G), ?L: 1=G+1> (
  @[G,G+1] inA:32,
  @[G,G+1] inB:32,
  @[G,G+1] funct:8, // one-hot encoding
  @[G,G+1] isAdd:1, // 1 if add, 0 if sub
  @[G,G+1] isArith:1, // 0 if log, 1 if arith
) -> (
  @[G,L] out:32
) {
  oneConst_1b := new Const[1,1]<G>();
  oneConst_33b := new Const[33,1]<G>();
  zeroConst_1b := new Const[1,0]<G>();

  // add / sub
  notInB := new Not[32]<G>(inB);
  concat0 := new Concat[1,32,33]<G>(oneConst_1b.out, notInB.out);
  concat1 := new Concat[1,32,33]<G>(zeroConst_1b.out, inA);
  inA31 := new Select[32,31]<G>(inA);
  inB31 := new Select[32,31]<G>(inB);

  // use a 33 bit subtract to compute comparisons

  add0 := new Add[33]<G>(concat0.out, concat1.out);
  aluMinus := new Add[33]<G>(add0.out, oneConst_33b.out);
  sub := new Slice[33,31,0,32]<G>(aluMinus.out);
  add := new Add[32]<G>(inA, inB);

  selAddSub := new Ternary[32]<G>(isAdd, add.out, sub.out);
  
  xor := new Xor[32]<G>(inA, inB);
  or := new Or[32]<G>(inA, inB);
  and := new And[32]<G>(inA, inB);
  sr := new rightshifter[32]<G>(inA, inB, isArith);
  sll := new ShiftLeft[32]<G>(inA, inB);

  aluMinus32 := new Select[33,32]<G>(aluMinus.out);
  
  ltguard := new Xor[1]<G>(inA31.out, inB31.out);
  ltTernary := new Ternary[1]<G>(ltguard.out, inA31.out, aluMinus32.out);
  lt := new ZeroExtend[1,32]<G>(ltTernary.out);
  ltu := new ZeroExtend[1,32]<G>(aluMinus32.out);

  mux := new onehotmux[32]<G>(funct, selAddSub.out, lt.out, ltu.out, xor.out, or.out, and.out, sll.out, sr.out);
  out = mux.out;
}

// extra components to make ALU simpler to write
extern "extras.sv" {
  comp onehotmux[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] sel:8,
    @[G,L] in0: #WIDTH,
    @[G,L] in1: #WIDTH,
    @[G,L] in2: #WIDTH,
    @[G,L] in3: #WIDTH,
    @[G,L] in4: #WIDTH,
    @[G,L] in5: #WIDTH,
    @[G,L] in6: #WIDTH,
    @[G,L] in7: #WIDTH
  ) -> (
    @[G,L] out: #WIDTH
  ) where L > G, #WIDTH > 0;

  comp rightshifter[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] in: #WIDTH,
    @[G,L] shamt: #WIDTH,
    @[G,L] isArith:1
  ) -> (
    @[G,L] out:#WIDTH
  ) where L > G, #WIDTH > 0;

  comp addsub[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] inA: #WIDTH,
    @[G,L] inB: #WIDTH,
    @[G,L] isAdd:1, // 1 if add, 0 if sub
  ) -> (
    @[G,L] out: #WIDTH
  ) where L > G, #WIDTH > 0;

  comp Ternary[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] guard:1,
    @[G,L] opTrue: #WIDTH,
    @[G,L] opFalse: #WIDTH
  ) -> (
    @[G,L] out: #WIDTH
  ) where L > G, #WIDTH > 0;
}