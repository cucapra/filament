import "primitives/core.fil";

// ALU

comp alu<G:1> (
  @[G,G+1] inA:32,
  @[G,G+1] inB:32,
  @[G,G+1] funct:8, // one-hot encoding
  @[G,G+1] isAdd:1, // 1 if add, 0 if sub
  @[G,G+1] isArith:1, // 0 if log, 1 if arith
) -> (
  @[G,G+1] out:32
) {
  // used for adds and subs
  add := new addsub[32]<G>(inA, inB, isAdd);
  lt := new Lt[32]<G>(inA, inB);
  // add ltu
  xor := new Xor[32]<G>(inA, inB);
  or := new Xor[32]<G>(inA, inB);
  and := new And[32]<G>(inA, inB);
  sr := new rightshifter[32]<G>(inA, inB, shtype);
  sll := new ShiftLeft[32]<G>(inA, inB);
  mux := new onehotmux[32]<G>(funct,add.out, lt.out, /* ltu.out */ xor.out, or.out, and.out, sll.out, sr.out);
  out = mux.out;
}

// extra components to make ALU simpler to write
extern "extras.sv" {
  comp onehotmux[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] sel:8,
    @[G,L] in0: #WIDTH,
    @[G,L] in1: #WIDTH,
    @[G,L] in2: #WIDTH,
    @[G,L] in3: #WIDTH,
    @[G,L] in4: #WIDTH,
    @[G,L] in5: #WIDTH,
    @[G,L] in6: #WIDTH,
    @[G,L] in7: #WIDTH
  ) -> (
    @[G,L] out: #WIDTH
  ) where L > G, #WIDTH > 0;

  comp rightshifter[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] in: #WIDTH,
    @[G,L] shamt: #WIDTH,
    @[G,L] isArith:1
  ) -> (
    @[G,L] out:#WIDTH
  ) where L > G, #WIDTH > 0;

  comp addsub[#WIDTH]<G:L-(G),?L:1=G+1>(
    @[G,L] inA: #WIDTH,
    @[G,L] inB: #WIDTH,
    @[G,L] isAdd:1, // 1 if add, 0 if sub
  ) -> (
    @[G,L] out: #WIDTH
  ) where L > G, #WIDTH > 0;
}