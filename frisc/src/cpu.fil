import "frisc/src/alu.fil";
import "frisc/src/decode.fil";
import "frisc/src/regfile.fil";
import "frisc/src/extras/extras.fil";
import "frisc/src/pc.fil";
import "primitives/core.fil";

comp CPU<G:1> (
  clk:1,
  @[G,G+1] reset:1,
  @[G,G+1] instr:32,
  @[G,G+1] pcin:32,
) -> (
  @[G,G+1] pc:32,
  @[G,G+1] nextpc:32,
  @[G,G+1] isLoad:1,
  @[G,G+1] isStore:1,
  @[G,G+1] out:32,
) {
  rd := new Slice[32,11,7,5]<G>(instr);
  rs1 := new Slice[32,19,15,5]<G>(instr);
  rs2 := new Slice[32,24,20,5]<G>(instr);

  decoder := new Decode<G>(instr);
  rf := new RegFile<G>(reset, decoder.rf_write, rd.out, alu.out, rs1.out, rs2.out);

  aluInBGuard := new Or[1]<G>(decoder.isBranch, decoder.isALUReg);
  aluInB := new Mux[32]<G>(aluInBGuard.out, rf.rs2, decoder.Iimm);

  alu := new ALU<G>(rf.rs1, aluInB.out, decoder.funct, decoder.isAdd, decoder.isArith);

 /* ================ PC ======================= */

  pc := new PC<G>(reset, pcin);

  // nextPC = isJAL ? Jimm : isAUIPC ? Uimm : Bimm
  // for jumps
  pcAdderImm := new Add[32];

  // not jumps
  pcAdder := new Add[32];

  // Compute what we add to PC
  // isJAL ? Jimm : isAUIPC ? Uimm : Bimm
  t0 := new Mux[32]<G>(decoder.isAUIPC, decoder.Uimm, decoder.Bimm);
  t1 := new Mux[32]<G>(decoder.isJAL, decoder.Jimm, t0.out);

  // No jumps - next instr
  const1 := new Const[32,1]<G>();

  // compute nextPC
  pcPlusImm := pcAdderImm<G>(pc.pc, t1.out);
  pcPlus4 := pcAdder<G>(pc.pc, const1.out);

  // isBranch || isJAL || isAUIPC
  branchJmp := new Or[1]<G>(decoder.isBranch, decoder.isJAL);
  useImm := new Or[1]<G>(branchJmp.out, decoder.isAUIPC);

  nextPC := new Mux[32]<G>(useImm.out, pcPlusImm.out, pcPlus4.out);

  out = alu.out;
  nextpc = nextPC.out;
  pc = pc.pc;
}