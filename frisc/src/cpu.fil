import "frisc/src/alu.fil";
import "frisc/src/decode.fil";
import "frisc/src/regfile.fil";
import "frisc/src/extras/extras.fil";
import "frisc/src/pc.fil";
import "primitives/memories.fil";
import "primitives/core.fil";

comp CPU<G:1> (
  clk:1,
  @[G,G+1] reset:1,
  @[G,G+1] instr:32,
  @[G,G+1] pcin:32,
) -> (
  @[G,G+1] pc:32,
  @[G,G+1] nextpc:32,
  @[G,G+1] isLoad:1,
  @[G,G+1] isStore:1,
  @[G,G+1] out:32,
  @[G,G+1] memAddr:32,
) {

  /* ============================================================ */
  /*  DECODER
  /* ============================================================ */  

  rd := new Slice[32,11,7,5]<G>(instr);
  rs1 := new Slice[32,19,15,5]<G>(instr);
  rs2 := new Slice[32,24,20,5]<G>(instr);

  decoder := new Decode<G>(instr);

  /* ============================================================ */
  /*  REGISTER FILE
  /* ============================================================ */

  // Set register file data in - use 1-hot encoding bc why not
  // {isLUI, isALU, isAUIPC, isJ, isLoad}

  // 00000001 -> isLoad, so use memDataIn
  // 00000010 -> isJ, so use pcPlus4
  // 00000100 -> isAUIPC, so use pcPlusImm
  // 00001000 -> isALU, so use alu.out
  // 00010000 -> isLUI, so use decoder.Uimm

  const0 := new Const[32,0]<G>();
  isALU := new Or[1]<G>(decoder.isALUImm, decoder.isALUReg);
  isJ := new Or[1]<G>(decoder.isJALR, decoder.isJAL);

  c0 := new Concat[1,1,2]<G>(decoder.isLUI, isALU.out);
  c1 := new Concat[1,1,2]<G>(decoder.isAUIPC, isJ.out);
  c2 := new Concat[2,1,3]<G>(c1.out, decoder.isLoad);
  c3 := new Concat[2,3,5]<G>(c0.out, c2.out);
  dInSel := new ZeroExtend[5,8]<G>(c3.out);

  rfData := new OneHotMux[32]<G>(dInSel.out, dataMem.read_data, pcPlus4.out, pcPlusImm.out, alu.out, 
    decoder.Uimm, const0.out, const0.out, const0.out);

  rf := new RegFile<G>(reset, decoder.rf_write, rd.out, alu.out, rs1.out, rs2.out);

  /* ============================================================ */
  /*  LOAD/STORE
  /* ============================================================ */

  addrAdder := new Add[32];
  addrImm := new Mux[32]<G>(decoder.isStore, decoder.Simm, decoder.Iimm);
  loadStoreAddr := addrAdder<G>(rf.rs1, addrImm.out);

  /* ============================================================ */
  /*  DATA MEMORY
  /* ============================================================ */

  dataMem := new StdMem1D[32, 256, 32]<G>(loadStoreAddr.out, rf.rs2, decoder.isStore);

  /* ============================================================ */
  /*  ALU
  /* ============================================================ */

  aluInBGuard := new Or[1]<G>(decoder.isBranch, decoder.isALUReg);
  aluInB := new Mux[32]<G>(aluInBGuard.out, rf.rs2, decoder.Iimm);

  alu := new ALU<G>(rf.rs1, aluInB.out, decoder.funct, decoder.isAdd, decoder.isArith);

  /* ============================================================ */
  /*  PROGRAM COUNTER
  /* ============================================================ */

  pc := new PC<G>(reset, pcin);

  // nextPC = isJAL ? Jimm : isAUIPC ? Uimm : Bimm
  // for jumps
  pcAdderImm := new Add[32];

  // not jumps
  pcAdder := new Add[32];

  // Compute what we add to PC
  // isJAL ? Jimm : isAUIPC ? Uimm : Bimm
  t0 := new Mux[32]<G>(decoder.isAUIPC, decoder.Uimm, decoder.Bimm);
  t1 := new Mux[32]<G>(decoder.isJAL, decoder.Jimm, t0.out);

  // No jumps - next instr
  const1 := new Const[32,1]<G>();

  // compute nextPC
  pcPlusImm := pcAdderImm<G>(pc.pc, t1.out);
  pcPlus4 := pcAdder<G>(pc.pc, const1.out);

  // isBranch || isJAL || isAUIPC
  branchJmp := new Or[1]<G>(decoder.isBranch, decoder.isJAL);
  useImm := new Or[1]<G>(branchJmp.out, decoder.isAUIPC);

  nextPC := new Mux[32]<G>(useImm.out, pcPlusImm.out, pcPlus4.out);

  /* ============================================================ */
  /*  OUTPUTS
  /* ============================================================ */

  out = alu.out;
  nextpc = nextPC.out;
  pc = pc.pc;
  memAddr = loadStoreAddr.out;
  isLoad = decoder.isLoad;
  isStore = decoder.isStore;
}