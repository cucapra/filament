import "frisc/src/alu.fil";
import "frisc/src/decode.fil";
import "frisc/src/regfile.fil";
import "frisc/src/extras/extras.fil";
import "frisc/src/pc.fil";
//import "primitives/memories.fil";
//import "primitives/core.fil";

comp CPU<G:1> (
  clk:1,
  reset:1,
  @[G,G+1] instr:32,
  @[G,G+1] pcin:32,
  @[G,G+1] dataIn:32,
  @[G,G+1] rfDataIn:32,
) -> (
  @[G,G+1] pc:32,          // current instr
  @[G,G+1] nextpc:32,      // next instr to fetch
  @[G,G+1] out:32,         // output of ALU
  @[G,G+1] memAddr:32,     // memory address
  @[G,G+1] memData:32,     // data to write to mem
  @[G,G+1] memWriteMask:4, // 4 bytes in a word
  @[G,G+1] rfDataOut:32
) {

  /* ============================================================ */
  /*  DECODER
  /* ============================================================ */  

  rd := new Slice[32,11,7,5]<G>(instr);
  rs1 := new Slice[32,19,15,5]<G>(instr);
  rs2 := new Slice[32,24,20,5]<G>(instr);

  decoder := new Decode<G>(instr);

  /* ============================================================ */
  /*  REGISTER FILE
  /* ============================================================ */

  // Set register file data in - use 1-hot encoding bc why not
  // {0, 0, 0, isLUI, isALU, isAUIPC, isJ, isLoad}

  // 00000001 -> isLoad, so use memDataIn
  // 00000010 -> isJ, so use pcPlus4
  // 00000100 -> isAUIPC, so use pcPlusImm
  // 00001000 -> isALU, so use alu.out
  // 00010000 -> isLUI, so use decoder.Uimm

  const0 := new Const[32,0]<G>();
  isALU := new Or[1]<G>(decoder.isALUImm, decoder.isALUReg);
  isJ := new Or[1]<G>(decoder.isJALR, decoder.isJAL);

  c0 := new Concat[1,1,2]<G>(decoder.isLUI, isALU.out);
  c1 := new Concat[1,1,2]<G>(decoder.isAUIPC, isJ.out);
  c2 := new Concat[2,1,3]<G>(c1.out, decoder.isLoad);
  c3 := new Concat[2,3,5]<G>(c0.out, c2.out);
  dInSel := new ZeroExtend[5,8]<G>(c3.out);

  rfData := new OneHotMux[32]<G>(dInSel.out, loadData.out, pcPlus4.out, pcPlusImm.out, alu.out, 
    decoder.Uimm, const0.out, const0.out, const0.out);

  rf := new RegFile<G>(decoder.rf_write, rd.out, rfDataIn, rs1.out, rs2.out);

  /* ============================================================ */
  /*  LOAD/STORE
  /* ============================================================ */

  // LOADS
  const0_2 := new Const[2,0]<G>();
  const1_2 := new Const[2,1]<G>();

  instr13_12 := new Slice[32,13,12,2]<G>(instr);
  instr14 := new Select[32,14]<G>(instr);
  byteAccess := new Eq[2]<G>(instr13_12.out, const0_2.out);
  hwAccess := new Eq[2]<G>(instr13_12.out, const1_2.out);

  hwSign := new Select[16,15]<G>(hw.out);
  bSign := new Select[8,7]<G>(byte.out);

  accessSign := new Mux[1]<G>(byteAccess.out, bSign.out, hwSign.out);
  not14 := new Not[1]<G>(instr14.out);
  loadSign := new And[1]<G>(not14.out, accessSign.out);

  loadByteSign := new Extend[1,24]<G>(loadSign.out);
  loadHWSign := new Extend[1,16]<G>(loadSign.out);

  loadHW := new Concat[16,16,32]<G>(loadHWSign.out, hw.out);
  loadByte := new Concat[24,8,32]<G>(loadByteSign.out, byte.out);

  hwOrW := new Mux[32]<G>(hwAccess.out, loadHW.out, dataIn);
  loadData := new Mux[32]<G>(byteAccess.out, loadByte.out, hwOrW.out);

  addr1 := new Select[32,1]<G>(loadStoreAddr.out);
  dataInUpper := new Slice[32,31,16,16]<G>(dataIn);
  dataInLower := new Slice[32,15,0,16]<G>(dataIn);
  hw := new Mux[16]<G>(addr1.out, dataInUpper.out, dataInLower.out);

  addr0 := new Select[32,0]<G>(loadStoreAddr.out);
  loadHUpper := new Slice[16,15,8,8]<G>(hw.out);
  loadHLower := new Slice[16,7,0,8]<G>(hw.out);
  byte := new Mux[8]<G>(addr0.out, loadHUpper.out, loadHLower.out);

  addrAdder := new Add[32];
  addrImm := new Mux[32]<G>(decoder.isStore, decoder.Simm, decoder.Iimm);
  loadStoreAddr := addrAdder<G>(rf.rs1, addrImm.out);

  // STORES
  rs2_7_0 := new Slice[32,7,0,8]<G>(rf.rs2);
  rs2_15_8 := new Slice[32,15,8,8]<G>(rf.rs2);
  rs2_23_16 := new Slice[32,23,16,8]<G>(rf.rs2);
  rs2_31_24 := new Slice[32,31,24,8]<G>(rf.rs2);

  memAddr_0 := new Select[32,0]<G>(loadStoreAddr.out);
  memAddr_1 := new Select[32,1]<G>(loadStoreAddr.out);

  memData_15_8 := new Mux[8]<G>(memAddr_0.out,rs2_7_0.out, rs2_15_8.out);
  memData_23_16 := new Mux[8]<G>(memAddr_1.out, rs2_7_0.out, rs2_23_16.out);

  _mux0 := new Mux[8]<G>(memAddr_1.out, rs2_15_8.out, rs2_31_24.out);
  memData_31_24 := new Mux[8]<G>(memAddr_0.out, rs2_7_0.out, _mux0.out);

  memData_31_16 := new Concat[8,8,16]<G>(memData_31_24.out, memData_23_16.out);
  memData_15_0 := new Concat[8,8,16]<G>(memData_15_8.out, rs2_7_0.out);
  memData_31_0 := new Concat[16,16,32]<G>(memData_31_16.out, memData_15_0.out);

  // WRITE MASK
  // 1111                   -> write a whole word
  // 0011 or 1100           -> write a halfword
  // 0001, 0010, 0100, 1000 -> write a byte

  maskWord := new Const[4,15]<G>();  // 1111
  maskHWUp := new Const[4, 12]<G>(); // 1100
  maskHWLow := new Const[4,3]<G>();  // 0011
  maskByte0 := new Const[4,1]<G>();  // 0001
  maskByte1 := new Const[4,2]<G>();  // 0010
  maskByte2 := new Const[4,4]<G>();  // 0100
  maskByte3 := new Const[4,8]<G>();  // 1000

  _muxHW_HL := new Mux[4]<G>(memAddr_1.out, maskHWUp.out, maskHWLow.out);
  _muxHW := new Mux[4]<G>(hwAccess.out, _muxHW_HL.out, maskWord.out);

  _muxB_3_2 := new Mux[4]<G>(memAddr_0.out, maskByte3.out, maskByte2.out);
  _muxB_1_0 := new Mux[4]<G>(memAddr_0.out, maskByte1.out, maskByte0.out);
  _muxB_HL := new Mux[4]<G>(memAddr_1.out, _muxB_3_2.out, _muxB_1_0.out);

  writeMask := new Mux[4]<G>(byteAccess.out, _muxB_HL.out, _muxHW.out);

  /* ============================================================ */
  /*  DATA MEMORY
  /* ============================================================ */

  //dataMem := new StdMem1D[32, 256, 32]<G>(reset, loadStoreAddr.out, rf.rs2, decoder.isStore);

  /* ============================================================ */
  /*  ALU
  /* ============================================================ */

  aluInBGuard := new Or[1]<G>(decoder.isBranch, decoder.isALUReg);
  aluInB := new Mux[32]<G>(aluInBGuard.out, rf.rs2, decoder.Iimm);

  alu := new ALU<G>(rf.rs1, aluInB.out, decoder.funct, decoder.isAdd, decoder.isArith);

  /* ============================================================ */
  /*  PROGRAM COUNTER
  /* ============================================================ */

  pc := new PC<G>(pcin);

  // nextPC = isJAL ? Jimm : isAUIPC ? Uimm : Bimm
  // for jumps
  pcAdderImm := new Add[32];

  // not jumps
  pcAdder := new Add[32];

  // Compute what we add to PC
  // isJAL ? Jimm : isAUIPC ? Uimm : Bimm
  t0 := new Mux[32]<G>(decoder.isAUIPC, decoder.Uimm, decoder.Bimm);
  t1 := new Mux[32]<G>(decoder.isJAL, decoder.Jimm, t0.out);

  // No jumps - next instr
  const1 := new Const[32,1]<G>();

  // compute nextPC
  pcPlusImm := pcAdderImm<G>(pc.pc, t1.out);
  pcPlus4 := pcAdder<G>(pc.pc, const1.out);

  // isBranch || isJAL || isAUIPC
  branchJmp := new Or[1]<G>(decoder.isBranch, decoder.isJAL);
  useImm := new Or[1]<G>(branchJmp.out, decoder.isAUIPC);

  nextPC := new Mux[32]<G>(useImm.out, pcPlusImm.out, pcPlus4.out);

  /* ============================================================ */
  /*  OUTPUTS
  /* ============================================================ */

  out = alu.out;
  nextpc = nextPC.out;
  pc = pc.pc;
  memAddr = loadStoreAddr.out;
  memData = memData_31_0.out;
  memWriteMask = writeMask.out;
  rfDataOut = rfData.out;
}
