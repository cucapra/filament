extern "core.sv" {
  // A register that can extend the lifetime of a signal to any required length.
  component Latch<G, L>(
    clk: 1,
    reset: 1,
    // -- base ports --
    @interface<G, 1> write_en: 1,
    @[G, G+1] in: 32
  ) -> (
    @[G+1, L] out: 32
  ) where L > G+1;

  // Merge two signals with disjoint lifetimes to generate a new signal available
  // for the union of their lifetimes
  // Implemented using a temporal mux that switches from signal `in1` to `in2`
  // on event L.
  // The signals `in1` and `in2` might exist for more their specified lifetime
  // in this function's signature but that is okay because inputs only require
  // signals to be active for at least as long as the requirement
  component Merge<G, L, E>(
    @[G, L] in1: 32,
    @[L, E] in2: 32,
  ) -> (
    @[G, E] out: 32,
  ) where L > G, E > L;
}

extern "binary.sv" {
  // ============= Combinational =================
  component Add<G>(
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
  ) -> (
    @[G, G+1] out: 32,
  );

  component MultComb<G>(
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
  ) -> (
    @[G, G+1] out: 32,
  );
}

// ============= Sequential =================
component Mult<G>(
  clk: 1,
  reset: 1,
  // -- base ports --
  @interface<G, 3> go: 1,
  @[G, G+1] left: 32,
  @[G, G+1] right: 32,
) -> (
  @[G+2, G+3] out: 32,
) {
  LL := new Latch;
  LR := new Latch;

  ll := LL<G, G+3>(left);
  lr := LL<G, G+3>(right);

  M := new MultComb;
  m := M<G+2>(ll.out, lr.out);
  out = m.out;
}
