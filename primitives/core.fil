extern "core.sv" {
  // A register that can extend the lifetime of a signal to any required length.
  component Latch<G, S, L>(
    clk: 1,
    reset: 1,
    // -- base ports --
    @interface[G, G+1] write_en: 1,
    @interface[S, L] _go_S: 1, // unused
    @[G, G+1] in: 32
  ) -> (
    @[S, L] out: 32
  ) where S = G+1, L > S;

  // A multiplexer that chooses between two signals. It has the following requirements:
  // 1. The inputs must be available for longer than the select signal.
  // 2. The output is available for as long as the select signal.
  component Mux<G, E>(
    @interface[G, E] _go: 1,
    @[G, E] sel: 1,
    @[G, E] in0: 32,
    @[G, E] in1: 32,
  ) -> (
    @[G, E] out: 32
  ) where E > G;
}

extern "binary.sv" {
  // ============= Combinational =================
  component Add<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
  ) -> (
    @[G, G+1] out: 32,
  );

  component MultComb<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
  ) -> (
    @[G, G+1] out: 32,
  );
}

// ============= Sequential =================
component Mult<G>(
  @interface[G, G+3] go_G: 1,
  @[G, G+1] left: 32,
  @[G, G+1] right: 32,
) -> (
  @[G+2, G+3] out: 32,
) {
  LL := new Latch;
  LR := new Latch;

  ll := LL<G, G+1, G+3>(left);
  lr := LR<G, G+1, G+3>(right);

  M := new MultComb;
  m := M<G+2>(ll.out, lr.out);
  out = m.out;
}
