extern "state.sv" {
  // A register that can extend the lifetime of a signal to any required length.
  component Register[WIDTH]<G, L, ?S = G+1>(
    clk: 1,
    reset: 1,
    @interface[G, G+1] write_en: 1,
    // Fake port to get the right delay for `G` which is |G+1 - L|
    @interface[S, L] @phantom go_S: 1,
    @[G, G+1] in: WIDTH,
  ) -> (
    @[S, L] out: WIDTH,
  ) where S = G+1, L > S;

  // A component that delays `in` by one cycle. Exactly the same as a register
  // but does not require component to provide `go` signal. If the component
  // additionally has no resource sharing, it can elide FSM generation.
  component Delay[WIDTH]<G>(
    clk: 1,
    reset: 1,
    @interface[G, G+1] @phantom go: 1,
    @[G, G+1] in: WIDTH,
  ) -> (
    @[G+1, G+2] out: WIDTH,
  );

  // A component that allows access to its previous stored value.
  // Backend by a simple register
  component Prev[WIDTH, SAFE]<G>(
    clk: 1,
    reset: 1,
    @interface[G, G+1] write_en: 1,
    @[G, G+1] in: WIDTH,
  ) -> (
    @[G, G+1] prev: WIDTH,
  );
}

extern "comb.sv" {
  // ============= Combinational =================

  component Const[WIDTH, VALUE]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component Add[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component Sub[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component MultComb[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component And[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component Or[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component Xor[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component Not[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] in: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component Eq[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component Gt[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component Lt[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component Lte[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component Gte[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: WIDTH,
    @[G, L] right: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component ZeroExtend[IN_WIDTH, OUT_WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] in: IN_WIDTH,
  ) -> (
    @[G, L] out: OUT_WIDTH,
  ) where L > G;

  component Concat[LEFT, RIGHT, OUT]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] left: LEFT,
    @[G, L] right: RIGHT,
  ) -> (
    @[G, L] out: OUT,
  ) where L > G;

  component Select[WIDTH, POS]<G, ?L=G+1>(
   @interface[G, L] @phantom go: 1,
    @[G, L] in: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component Slice[IN_WIDTH, MSB, LSB, OUT_WIDTH]<G, ?L=G+1>(
   @interface[G, L] @phantom go: 1,
    @[G, L] in: IN_WIDTH,
  ) -> (
    @[G, L] out: OUT_WIDTH,
  ) where L > G;

  component ReduceAnd[WIDTH]<G, ?L=G+1>(
   @interface[G, L] @phantom go: 1,
    @[G, L] in: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component ReduceOr[WIDTH]<G, ?L=G+1>(
   @interface[G, L] @phantom go: 1,
    @[G, L] in: WIDTH,
  ) -> (
    @[G, L] out: 1,
  ) where L > G;

  component ShiftLeft[WIDTH]<G, ?L=G+1>(
   @interface[G, L] @phantom go: 1,
    @[G, L] in: WIDTH,
    @[G, L] shift: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component ShiftRight[WIDTH]<G, ?L=G+1>(
   @interface[G, L] @phantom go: 1,
    @[G, L] in: WIDTH,
    @[G, L] shift: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;

  component Mux[WIDTH]<G, ?L=G+1>(
    @interface[G, L] @phantom go: 1,
    @[G, L] sel: 1,
    @[G, L] in0: WIDTH,
    @[G, L] in1: WIDTH,
  ) -> (
    @[G, L] out: WIDTH,
  ) where L > G;
}