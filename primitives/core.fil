extern "core.sv" {
  // A register that can extend the lifetime of a signal to any required length.
  component Register[WIDTH]<G, S, L>(
    clk: 1,
    reset: 1,
    // -- base ports --
    @interface[G, G+1] write_en: 1,
    @interface[S, L] _go_S: 1, // unused
    @[G, G+1] in: WIDTH,
  ) -> (
    @[S, L] out: WIDTH,
    @[G, G+1] prev: WIDTH,
  ) where S = G+1, L > S;

  component Mux[WIDTH]<G>(
    @interface[G, G+1] _go: 1,
    @[G, G+1] sel: 1,
    @[G, G+1] in0: WIDTH,
    @[G, G+1] in1: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );
}

extern "binary.sv" {
  // ============= Combinational =================

  component Const[WIDTH, VALUE]<G>(
    @interface[G, G+1] _go: 1,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component Add[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component Sub[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component MultComb[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component And[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component Or[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component Xor[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component Not[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component Eq[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component Gt[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component Lt[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component Lte[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component Gte[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: WIDTH,
    @[G, G+1] right: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component ZeroExtend[IN_WIDTH, OUT_WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: IN_WIDTH,
  ) -> (
    @[G, G+1] out: OUT_WIDTH,
  );

  component Concat[LEFT, RIGHT, OUT]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] left: LEFT,
    @[G, G+1] right: RIGHT,
  ) -> (
    @[G, G+1] out: OUT,
  );

  component Select[WIDTH, POS]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component Slice[IN_WIDTH, MSB, LSB, OUT_WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: IN_WIDTH,
  ) -> (
    @[G, G+1] out: OUT_WIDTH,
  );

  component ReduceAnd[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component ReduceOr[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: WIDTH,
  ) -> (
    @[G, G+1] out: 1,
  );

  component ShiftLeft[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: WIDTH,
    @[G, G+1] shift: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );

  component ShiftRight[WIDTH]<G>(
    @interface[G, G+1] _go: 1, // unused
    @[G, G+1] in: WIDTH,
    @[G, G+1] shift: WIDTH,
  ) -> (
    @[G, G+1] out: WIDTH,
  );
}

// ============= Sequential =================
component Mult<G>(
  @interface[G, G+2] go_G: 1,
  @[G, G+1] left: 32,
  @[G, G+1] right: 32,
) -> (
  @[G+2, G+3] out: 32,
) {
  ll := new Register[32]<G, G+1, G+3>(left);
  lr := new Register[32]<G, G+1, G+3>(right);
  m := new MultComb[32]<G+2>(ll.out, lr.out);
  out = m.out;
}
