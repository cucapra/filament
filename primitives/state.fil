extern "state.sv" {
  // A register that can extend the lifetime of a signal to any required length.
  comp Register[#WIDTH]<G: L-(G+1), L: 1>(
    clk: 1,
    reset: 1,
    @interface[G] write_en: 1,
    @[G, G+1] in: #WIDTH,
  ) -> (
    @[G+1, L] out: #WIDTH,
  ) where L > G+1;

  // A comp that delays `in` by one cycle. Exactly the same as a register
  // but does not require comp to provide `go` signal. If the comp
  // additionally has no resource sharing, it can elide FSM generation.
  comp Delay[#WIDTH]<G: 1>(
    clk: 1,
    reset: 1,
    @[G, G+1] in: #WIDTH,
  ) -> (
    @[G+1, G+2] out: #WIDTH,
  );

  // A comp that allows access to its previous stored value.
  // Backend by a simple register
  comp Prev[#WIDTH, #SAFE]<G: 1>(
    clk: 1,
    reset: 1,
    @interface[G] write_en: 1,
    @[G, G+1] in: #WIDTH,
  ) -> (
    @[G, G+1] prev: #WIDTH,
  );

  // Prev comp that continuously updates its value
  comp ContPrev[#WIDTH, #SAFE]<G: 1>(
    clk: 1,
    reset: 1,
    @[G, G+1] in: #WIDTH,
  ) -> (
    @[G, G+1] prev: #WIDTH,
  );
}

// A component that delays `in` by N cycles.
// Uses the Delay component under the hood.
comp Shift[#W, #N]<G: 1>(
    @[G, G+1] in: #W
) -> (
    @[G+#N, G+#N+1] out: #W
) {
    bundle f[#N+1]: for<#i> @[G+#i, G+#i+1] #W;

    f{0} = in;
    for #i in 0..#N {
        d := new Delay[#W]<G+#i>(f{#i});
        f{#i+1} = d.out;
    }
    out = f{#N};
}
