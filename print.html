<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Filament</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="start.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">The Filament Language</li><li class="chapter-item expanded "><a href="lang/tutorial.html"><strong aria-hidden="true">2.</strong> Your First Filament Program</a></li><li class="chapter-item expanded "><a href="lang/run.html"><strong aria-hidden="true">3.</strong> Running Filament Designs</a></li><li class="chapter-item expanded "><a href="lang/pipelining.html"><strong aria-hidden="true">4.</strong> Pipelining with Filament</a></li><li class="chapter-item expanded "><a href="lang/external.html"><strong aria-hidden="true">5.</strong> Using Verilog Modules in Filament</a></li><li class="chapter-item expanded affix "><li class="part-title">Metaprogramming with Filament</li><li class="chapter-item expanded "><a href="meta/overview.html"><strong aria-hidden="true">6.</strong> Metaprogramming Overview</a></li><li class="chapter-item expanded "><a href="meta/loops-and-bundles.html"><strong aria-hidden="true">7.</strong> Loops and Bundles</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Filament</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Filament is a programming language for Fearless Hardware Design. It aims to enable software programmers without much hardware background to start designing performant hardware. At its heart, Filament uses a type system to encode properties important for designing efficient hardware. This guide helps you install the various tools to make Filament work.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="minimal-build"><a class="header" href="#minimal-build">Minimal Build</a></h3>
<p>The following commands are sufficient to build the Filament compiler and have it generate <a href="https://calyxir.org">Calyx IR</a>. First, we need to configure the Calyx compiler which acts as the backend for Filament.</p>
<ul>
<li>Clone the <a href="https://github.com/cucapra/calyx">Calyx repository</a>: <code>git clone https://github.com/cucapra/calyx.git</code></li>
<li>Clone this repository: <code>git clone https://github.com/cucapra/filament.git</code></li>
<li>Both repositories <strong>must</strong> be contained in the same parent folder such that they are sibling folders.</li>
</ul>
<p>Next, we can install the dependencies for the Filament compiler:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a> which will configure the <code>cargo</code> tool.</li>
<li>Install <a href="https://github.com/Z3Prover/z3">z3</a>.
<ul>
<li>On Mac OS: <code>brew install z3</code>.</li>
<li>On Ubuntu: <code>apt install z3</code></li>
</ul>
</li>
<li>Build the compiler by running: <code>cargo build</code> in the root of the folder.</li>
</ul>
<p>To check that the compiler works, run the following command:</p>
<pre><code>cargo run -- tests/compile/par.fil
</code></pre>
<p>Which should generate the Calyx IR for the program.</p>
<h3 id="full-build"><a class="header" href="#full-build">Full Build</a></h3>
<p>In order to generate Verilog, run the test suite, and simulate Filament programs, we need a couple more tools:</p>
<ul>
<li>Install <a href="https://docs.calyxir.org/fud/index.html"><code>fud</code></a> which manages hardware tools and makes it easy to test Filament programs.
<ul>
<li>Install <a href="https://flit.pypa.io/en/stable/">flit</a>: <code>python3 -m pip install flit</code></li>
<li>Install <a href="https://docs.calyxir.org/fud/index.html">fud</a>: <code>cd calyx/fud &amp;&amp; flit install -s</code></li>
<li>Check <code>fud</code> was installed: <code>fud check</code>. It will report some tools are missing. This is expected.</li>
</ul>
</li>
<li>Install <a href="https://iverilog.fandom.com/wiki/Installation_Guide">Icarus Verilog</a> and <a href="https://docs.calyxir.org/fud/index.html#icarus-verilog">configure <code>fud</code> to use it</a>.
<ul>
<li>Running <code>fud check</code> again should report that <code>icarus-verilog</code> was installed correctly.</li>
</ul>
</li>
<li>Install <a href="https://www.cocotb.org/">cocotb</a>: <code>python3 -m pip install cocotb</code>.
<ul>
<li>Cocotb install can often fail. Check it was installed correctly by running <code>python3 -c &quot;import cocotb; print(cocotb.__version__)&quot;</code>. If this command fails, see <a href="start.html#debugging-cocotb-installation">Debugging Cocotb Installation</a>.</li>
</ul>
</li>
<li>Register Filament's fud stages by running the command in the filament repository: <code>fud register -p fud/filament.py filament</code>
<ul>
<li>Run <code>fud check</code> to make sure that the filament stages are correctly installed.</li>
</ul>
</li>
<li>Install <a href="https://github.com/cucapra/runt"><code>runt</code></a>: <code>cargo install runt</code></li>
<li>Install [<code>jq</code>][jq]
<ul>
<li>On Mac OS: <code>brew install jq</code></li>
<li>On Ubuntu: <code>apt install jq</code></li>
</ul>
</li>
</ul>
<p>For a sanity check, run <code>fud check</code>. It should report that <code>iverilog</code>, <code>jq</code>, <code>filament</code>, <code>futil</code>, <code>cocotb</code> are correctly installed.</p>
<p>Once all tools are installed, running the following command should print out the test report:</p>
<pre><code>runt -j 1
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that we have installed the Filament compiler and accompanying tools, we can start using Filament. Use the following links to learn more about Filament:</p>
<ul>
<li>Writing your <a href="./lang/tutorial.html">first Filament Program</a>.</li>
<li>Overview of the <a href="./lang/index.html">Filament Language</a>.</li>
</ul>
<h2 id="debugging-cocotb-installation"><a class="header" href="#debugging-cocotb-installation">Debugging Cocotb Installation</a></h2>
<p>Cocotb requires the python shared library <code>libpython.so</code>/<code>libpython.dylib</code> (Mac OS) to work correctly. A common reason for a cocotb installation not working is when this library is missing.</p>
<p>To check if cocotb is able to find the shared library install <code>find_libpython</code>: <code>python3 -m pip install find_libpython</code>.</p>
<p>Next, run the following:</p>
<pre><code>python3 -c &quot;import find_libpython; print(find_libpython.find())&quot;
</code></pre>
<p>If the above command does not print out anything, that means that the python library was not found and the python installation needs to be rebuilt.</p>
<p>If you use <a href="https://github.com/pyenv/pyenv"><code>pyenv</code></a>, the following command will install a python version with the shared library:</p>
<pre><code>env PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; pyenv install 3.10
</code></pre>
<p>Rerun the command to check that <code>libpython</code> was found after installing a new python version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-design-for-the-curious-developer"><a class="header" href="#hardware-design-for-the-curious-developer">Hardware Design for the Curious Developer</a></h1>
<p>Filament is a low-level hardware description language. This means that it does not have a lot of primitive constructs and essentially requires us to build up our hardware from scratch. However, Filament's type system helps us build small reusable components and guarantees that composing them generated efficient and correct hardware.</p>
<blockquote>
<p>This tutorial is written for folks with no hardware design background. If you're familiar with hardware design, head to our &quot;Introduction to Filament for Cool Architects&quot; (<strong>TK</strong>).</p>
</blockquote>
<h2 id="building-an-arithmetic-logic-unit"><a class="header" href="#building-an-arithmetic-logic-unit">Building an Arithmetic Logic Unit</a></h2>
<p>Arithmetic Logic Units (ALUs) are a key component of most processors. In a nutshell, they perform various arithmetic operations based on a given op code. We will implement a simple ALU that either performs an addition or multiplication based on the <code>op</code> boolean. At a high-level, we want to build a circuit that performs the same computation as this python program:</p>
<pre><code class="language-python">def alu(op, left, right):
    if op:
        out = left * right
    else:
        out = left + right
    return out
</code></pre>
<p>The generated hardware will look something like this:</p>
<pre class="mermaid">graph TB;
    L([left])
    R([right])
    O([op])
    A[Add]
    M[Mult]
    Mx[Mux]

    L &amp; R --&gt;A &amp; M;
    A &amp; M --&gt; Mx --&gt;out([out]);
    O---&gt;Mx;
</pre>
<p>We start by defining a Filament component which wraps all the hardware required to implement some computation:</p>
<pre><code class="language-filament">comp main&lt;G: 3&gt;(
    @interface[G] go: 1,
    @[G, G+1] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G, G+1] out: 32)
</code></pre>
<p>The <code>&lt;G: 1&gt;</code> syntax defined the event <code>G</code> which can be thought of as the &quot;start time&quot; of the component.
We define a module that takes the inputs <code>op</code>, <code>left</code>, and <code>right</code> and produces the output <code>out</code>.
Since we're working with hardware, we need to specify the <em>bitwidth</em> of each input and output.
Unlike other hardware description languages, Filament <em>also</em> requires us to specify exactly when we'll use the input signals and provide the outputs. The syntax <code>@[G, G+1]</code> states that the signal must be available in the half-open interval [G, G+1).</p>
<p>Next, we need to perform the computations. Since we're working with hardware designs, we don't get access to primitive operations like <code>*</code> and <code>+</code>; we must build circuits to perform these computations!</p>
<p>Thankfully, the Filament standard library defines these operations for us, so we can simply import those definitions and instantiate an adder and a multiplier:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;       // Defines Add
import &quot;primitives/sequential.fil&quot;; // Defines Mult

comp ALU&lt;G: 3&gt;(...) -&gt; (...) {
    A := new Add[32];
    M := new Mult[32];
}
</code></pre>
<p>We define two circuits <code>A</code> and <code>M</code> which represent an 32-bit adder and a multiplier respectively. The <code>Add[32]</code> syntax represents us passing the value 32 for the width parameter of the pre-defined components.</p>
<p>Next, we need to perform the two computation. In Filament, we have to specify the time when a particular computation occurs using an <em>invocation</em>:</p>
<pre><code class="language-filament">    A := new Add[32];
    M := new Mult[32];
    a0 := A&lt;G&gt;(left, right);
    m0 := M&lt;G&gt;(left, right);
</code></pre>
<p>Here, <code>a0</code> and <code>m0</code> are invocations of the adder and the multiplier that are performed when the event <code>G</code> occurs. We provide values for the input ports of the adder and the multiplier. Finally, we can use a multiplexer to select between the output signals of the two invocations:</p>
<pre><code class="language-filament">mx := new Mux[32]&lt;G&gt;(op, a0.out, m0.out);
out = mx.out
</code></pre>
<p>We make use of Filament's combined instance creation and invocation syntax to define a new multiplexer and use it when event <code>G</code> occurs. Finally, we forward the output from the multiplexer to the output signal of the component.</p>
<p>Coming from a software background, it might seem weird that we're performing both the computations first and selecting the output after the fact. However, a hardware circuit is <em>always active</em><sup class="footnote-reference"><a href="#clock-gating">1</a></sup>–the multiplier and adder are always propagating signals and performing some computation even if the inputs are nonsensical. Furthermore, constructs like <code>if</code>-<code>else</code> are not compositional.<sup class="footnote-reference"><a href="#control-comp">2</a></sup></p>
<p>The final program looks like this:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

/// ANCHOR: signature
comp main&lt;G: 3&gt;(
    @interface[G] go: 1,
    @[G, G+1] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G, G+1] out: 32)
// ANCHOR_END: signature
{
    A := new Add[32];
    M := new Mult[32];
    a0 := A&lt;G&gt;(left, right);
    m0 := M&lt;G&gt;(left, right);
    mx := new Mux[32]&lt;G&gt;(op, a0.out, m0.out);
    out = mx.out;
}
</code></pre>
<h2 id="checking-timing-behavior"><a class="header" href="#checking-timing-behavior">Checking Timing Behavior</a></h2>
<p>Filament's prime directive is to ensure that your hardware is does not violate temporal constraints.
Let's see what that means exactly by trying to compile our program.
Save the file as <code>alu.fil</code> and run the following command from the Filament repository:</p>
<pre><code>cargo run -- alu.fil
</code></pre>
<p>Filament tells us that the program is incorrect:</p>
<pre><code class="language-filament">error: source port must be available longer than the destination port requires
    ┌─ examples/tut-wrong-1.fil:17:38
    │
 17 │     mx := new Mux[32]&lt;G&gt;(op, a0.out, m0.out);
    │                                      ^^^^^^ source is available for @[G+2, G+3]
    │
    ┌─ ./primitives/core.fil:152:13
    │
152 │     @[G, L] in1: #WIDTH,
    │             --- destination's requirement @[G, G+1]

Compilation failed with 1 errors.
Run with --show-models to generate assignments for failing constraints.
</code></pre>
<p>Filament is telling us that our multiplexer expects its input during the interval [G, G+1) but the multiplier's output is only available in the interval [G+2, G+3).
What went wrong? We started our adder and the multiplier at the same time (when event <code>G</code> occurs) but the multiplier seems to take longer.
This is because multipliers are fundamentally different from adders–they require a lot more hardware and a lot more time to perform their computation.
This <em>temporal constraint</em>–that multiplier may take several cycles while adders may not–is checked by Filament to ensure that our resulting hardware only reads meaningful values.</p>
<p>In order to fix this, we need to execute the multiplexer when the signal from the multiplier is available. However, in that case, we won't have access to the signal from the adder which only provides its output in the interval [G, G+1). We need to somehow make the signal from the adder last longer as well.</p>
<h2 id="saving-values-for-the-future"><a class="header" href="#saving-values-for-the-future">Saving Values for the Future</a></h2>
<p>Registers are the primitive stateful building block for hardware designs and can extend the availability of signals. The signature of a register is complicated by interesting:</p>
<pre><code class="language-filament">  // A register that can extend the lifetime of a signal to any required length.
  comp Register[#WIDTH]&lt;G: L-(G+1), L: 1&gt;(
    clk: 1,
    reset: 1,
    @interface[G] write_en: 1,
    @[G, G+1] in: #WIDTH,
  ) -&gt; (
    @[G+1, L] out: #WIDTH,
  ) where L &gt; G+1;
</code></pre>
<p>Notice the availability for the <code>out</code> signal: it is available in the interval [G, L) where <code>L</code> is provided to the component during its invocation.
This means that a register can hold onto a value for as long as needed!
The additional <code>where</code> clause ensures that <code>out</code>'s interval is well-formed; it would be troublesome if we could say that <code>out</code> is available between [G+10, G+5).</p>
<p>Let try to fix our program by making changes:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

comp main&lt;G: 3&gt;(
    @interface[G] go: 1,
    @[G, G+1] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (
    @[G, G+1] out: 32,
) {
    A := new Add[32];
    M := new Mult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+3&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<p>We made a couple of changes to our program:</p>
<ul>
<li>Run the multiplexer when the output from the multiplier is available (at <code>G+2</code>).</li>
<li>Save the value from the adder in the register invocation <code>r0</code></li>
<li>Use the value from the register instead of the adder for multiplexing.</li>
</ul>
<p>Sadly, Filament is still angry at us:</p>
<pre><code>error: source port must be available longer than the destination port requires
    ┌─ examples/tut-wrong-2.fil:19:28
    │
 19 │     mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    │                            ^^ source is available for @[G, G+1]
    │
    ┌─ ./primitives/core.fil:150:13
    │
150 │     @[G, L] sel: 1,
    │             --- destination's requirement @[G+2, G+3]

error: source port must be available longer than the destination port requires
   ┌─ examples/tut-wrong-2.fil:20:11
   │
20 │     out = mx.out;
   │     ---   ^^^^^^ source is available for @[G+2, G+3]
   │     │      
   │     destination's requirement @[G, G+1]

Compilation failed with 2 errors.
Run with --show-models to generate assignments for failing constraints.
</code></pre>
<p>The problem is that we accept the <code>op</code> input and produce the output <code>out</code> in the interval [G, G+1). However, we know that it is not possible to produce the output as soon as we get the input because the multiplier takes two cycles to produce its output!</p>
<h2 id="a-correct-implementation"><a class="header" href="#a-correct-implementation">A Correct Implementation</a></h2>
<p>The fix is easy: we change the signature of the ALU to reflect this cruel reality</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

/// ANCHOR: sig
comp main&lt;G: 3&gt;(
/// ANCHOR_END: sig
    @interface[G] go: 1,
    @[G, G+3] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+2, G+3] out: 32)
{
    A := new Add[32];
    M := new Mult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+3&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<p>And running the compiler again generates no longer generates any errors:</p>
<pre><code>cargo run -- alu.fil
</code></pre>
<div class="footnote-definition" id="clock-gating"><sup class="footnote-definition-label">1</sup>
<p>This is not quite true since we can build circuits where the clock signal to a particular sub-circuit is disabled (or &quot;gated&quot;) based on a particular signal. However, this kind of clock-gating is generally not recommended for fine-grained usage.</p>
</div>
<div class="footnote-definition" id="control-comp"><sup class="footnote-definition-label">2</sup>
<p>While control operators like <code>if</code> and <code>for</code> are supported in languages like Verilog, they don't quite work the same in all contexts. <code>for</code> loops are compile-time constructs whereas <code>if</code> can only be used for combinational circuits like adders but not multipliers.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-filament-designs"><a class="header" href="#running-filament-designs">Running Filament Designs</a></h1>
<p>Filament designs are compiled to Verilog using the <a href="https://calyxir.org">Calyx</a> backend and simulated using tools like <a href="https://github.com/steveicarus/iverilog">Icarus Verilog</a>.
However, figuring out the right incantations to get these tools to work together and building testing harnesses can be tedious.
We use <a href="https://docs.calyxir.org/fud/index.html">fud</a> to make the process of running Filament designs seamless: the user provides a file with the test data and runs a single command to compile, simulate, and generate outputs.</p>
<h2 id="data-format"><a class="header" href="#data-format">Data Format</a></h2>
<p>The test runner's data format is a JSON file that contains the names of each port mentioned in a Filament program's <code>main</code> component.
For example, for the <a href="lang/./lang/tutorial.html#building-an-arithmetic-logic-unit">tutorial ALU</a> with the signature:</p>
<pre><code class="language-filament">comp main&lt;G: 3&gt;(
    @interface[G] go: 1,
    @[G, G+1] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G, G+1] out: 32)
</code></pre>
<p>We can have the following data file:</p>
<pre><code class="language-json">{
    &quot;op&quot;: [ 0, 1, 0, 1 ],
    &quot;left&quot;: [ 4, 5, 6, 7 ],
    &quot;right&quot;: [ 7, 5, 11, 9 ]
}
</code></pre>
<p>The test harness operates with the idea of <em>transactions</em> where each transaction is a set of inputs and outputs corresponding to the indices into the JSON file.
For example, the first transaction sends the inputs <code>op[0]</code>, <code>left[0]</code>, and <code>right[0]</code> to the Verilog design and capture outputs for <code>out[0]</code>, corresponding to the output ports of the ALU.</p>
<p>This means, that the above data file will run the design with four inputs and capture four outputs. Adding another transaction is easy: just add another set of inputs to the JSON file.</p>
<h2 id="running-designs"><a class="header" href="#running-designs">Running Designs</a></h2>
<p>Running the design is straightforward, assuming you've <a href="lang/./start.html#full-build">configured <code>fud</code></a> already:</p>
<pre><code class="language-sh">fud e --to cocotb-out examples/tut-seq.fil \
      -s cocotb.data examples/data.json \
      -s futil.flags ' -d canonicalize'
</code></pre>
<p>This instructs <code>fud</code> to compile the design to Verilog, setup the test harness, and run the simulation.
The output captures the values on the <code>out</code> port of the ALU for each transaction in the data file and tells us how many cycles it took to run the design:</p>
<pre><code>{&quot;out&quot;: {&quot;0&quot;: [28], &quot;1&quot;: [10], &quot;2&quot;: [66], &quot;3&quot;: [16]}, &quot;cycles&quot;: 12}
</code></pre>
<p>In general, the command to run designs is:</p>
<pre><code class="language-sh">fud e --to cocotb-out &lt;filament-file&gt; \
      -s cocotb.data &lt;data-file&gt; \
      -s futil.flags ' -d canonicalize'
</code></pre>
<h2 id="under-the-hood"><a class="header" href="#under-the-hood">Under the Hood</a></h2>
<blockquote>
<p>Note: If you're following the tutorial, skip to the <a href="lang/./pipelining.html">Pipelining with Filament</a> section and come back here after you've finished.</p>
</blockquote>
<p>Filament's test runner uses the signature of the <code>main</code> component to decide how long to provide inputs for, when to capture the outputs, and when to schedule the next transaction.</p>
<h3 id="providing-inputs"><a class="header" href="#providing-inputs">Providing Inputs</a></h3>
<p>The test harness holds the inputs for exactly the interval specified for each input and then provides <a href="https://stackoverflow.com/questions/69530556/what-exactly-do-x-and-z-values-represent-in-verilog"><code>'x</code> values</a> to the input.
This is done to make sure that incorrect designs that read inputs outside of their specified interval will not pass the test.</p>
<h3 id="scheduling-transactions"><a class="header" href="#scheduling-transactions">Scheduling Transactions</a></h3>
<p>Because Filament is represents hardware pipelines, new transactions can start before the previous transaction has finished.
By default, new transactions are scheduled exactly when the delay for the main event specifies.
For example, if the main event has a delay of <code>2</code>, then the next transaction will be scheduled after two cycles after starting the previous transaction.</p>
<p>However, it can be useful to change the scheduling behavior to check if there are pipelining bugs.
Our <code>fud</code>-based harness provides a way to randomize the timing of transactions by adding a random delay:</p>
<pre><code class="language-sh">fud e --to cocotb-out examples/tut-seq.fil \
      -s cocotb.data examples/data.json \
      -s cocotb.randomize 10 \
      -s futil.flags ' -d canonicalize'
</code></pre>
<p>The <code>-s cocotb.randomize 10</code> flag adds a random delay of up to 10 cycles between transactions.</p>
<blockquote>
<p>Note: A well-typed Filament program produces the same output values regardless of the scheduling of transactions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipelining-with-filament"><a class="header" href="#pipelining-with-filament">Pipelining with Filament</a></h1>
<p>While we've designed <a href="lang/./tutorial.html">a correct ALU</a>, it is quite slow: it processes one input completely before moving on to the next.
Such a hardware design is called a &quot;fully sequential&quot;.
A standard technique to improve throughput of the design is <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/pipelining/index.html">pipelining</a>, which allows a hardware module to process multiple inputs at the same time.</p>
<p>Filament is designed so that check that a pipeline can support the throughput specified in its interface.
We'll take our <a href="lang/./tutorial.html#a-correct-implementation">sequential ALU</a> design and use Filament's type system to guide us to a correctly pipelined design.
Before that, however, let's run the design and see how it performs:</p>
<pre><code class="language-bash">fud e --to cocotb-out examples/tut-seq.fil \
      -s cocotb.data examples/data.json \
      -s futil.flags ' -d canonicalize'
</code></pre>
<p>Which generates the following output:</p>
<pre><code>{&quot;out&quot;: {&quot;0&quot;: [28], &quot;1&quot;: [10], &quot;2&quot;: [66], &quot;3&quot;: [16]}, &quot;cycles&quot;: 12}
</code></pre>
<p>Note that this sequential design takes 12 cycles to process 4 inputs.</p>
<p>We'll start with pipelining our program:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

/// ANCHOR: sig
comp main&lt;G: 3&gt;(
/// ANCHOR_END: sig
    @interface[G] go: 1,
    @[G, G+3] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+2, G+3] out: 32)
{
    A := new Add[32];
    M := new Mult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+3&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<h2 id="delays-and-throughput"><a class="header" href="#delays-and-throughput">Delays and Throughput</a></h2>
<p>Filament uses an event's <em>delay</em> to determine when the module is can accept new inputs.</p>
<pre><code class="language-filament">comp main&lt;G: 3&gt;(
</code></pre>
<p>Note that the delay for the event <code>G</code> is <code>3</code> which indicates to Filament that the ALU process new inputs every three cycles.
We can tell Filament that we instead want a module that can process new inputs every cycle by changing the delay to <code>1</code>:</p>
<pre><code class="language-filament">comp main&lt;G: 1&gt;(
</code></pre>
<p>And run the compiler:</p>
<pre><code>cargo run -- alu.fil
</code></pre>
<p>However, much to our dismay, Filament tells us that this program cannot be pipelined to achieve throughput 1.
However, being the nice type checker it is, it will tell us <em>exactly why</em> the design cannot be pipelined in the form of type errors.</p>
<p>Let's work through each error and see how we can fix it.</p>
<h3 id="availability-intervals-of-ports"><a class="header" href="#availability-intervals-of-ports">Availability Intervals of Ports</a></h3>
<p>The first error message points out that one of the inputs is required for three cycles, but the module may re-execute every cycle:</p>
<pre><code>error: delay must be longer than the length of the signal
  ┌─ examples/tut-pipe-wrong-1.fil:8:5
  │
5 │ comp main&lt;G: 1&gt;(
  │           - interface allows event to trigger every 1 cycle(s)
  ·
8 │     @[G, G+3] op: 1,
  │     ^^^^^^^^^ signal lasts for 3 cycle(s)

error: event provided to invocation triggers more often that invocation's event's delay allows
</code></pre>
<p>This is problematic because <code>op</code> represents a <em>physical wire</em>; it is incapable of holding multiple values.
Our request to process inputs every cycle <em>and</em> have <code>op</code> last for three cycles is physically impossible.
The fix is easy: looking at our original design, we see that <code>op</code> is only used by the multiplexer in the interval [G+2, G+3) so we can change the availability interval of <code>op</code> to be [G+2, G+3).</p>
<blockquote>
<p>Note: If this step feel like divine insight, another way to reach the same conclusion is by changing the availability interval of <code>op</code> to be [G, G+1) which will cause the compiler to point out all availability intervals where <code>op</code> is used.</p>
</blockquote>
<h3 id="delays-of-subcomponents"><a class="header" href="#delays-of-subcomponents">Delays of Subcomponents</a></h3>
<p>The second error message points out that the ALU component may execute every cycle but the multiplier we used can only execute every two cycles:</p>
<pre><code>error: event provided to invocation triggers more often that invocation's event's delay allows
   ┌─ examples/tut-pipe-wrong-1.fil:15:13
   │
 5 │ comp main&lt;G: 1&gt;(
   │              - this event triggers every 1 cycles
   ·
15 │     m0 := M&lt;G&gt;(left, right);
   │             ^ event provided to invoke triggers too often
   │
   ┌─ ./primitives/sequential.fil:3:18
   │
 3 │ comp Mult[#W]&lt;G: 2&gt;(
   │                  - invocation's event is allowed to trigger every 2 cycles
</code></pre>
<p>Yet again, our request is physically impossible to satisfy: our multiplier circuit is fundamentally incapable of executing every cycle.
Thankfully for us, the <code>primitives/sequential.file</code> file provides a component called <code>FastMult</code> which does have delay 1:</p>
<pre><code class="language-filament">/// Implementation of a multiplier with initiation interval 1 and latency 3
comp FastMult[#W]&lt;G: 1&gt;(
  @interface[G] go_G: 1,
  @[G, G+1] left: #W,
  @[G, G+1] right: #W,
) -&gt; (
  @[G+3, G+4] out: #W,
) where #W &gt; 0
</code></pre>
<p>We can change out program to use this component instead:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

comp main&lt;G: 1&gt;(
    @interface[G] go: 1,
    @[G+2, G+3] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+2, G+3] out: 32)
{
    A := new Add[32];
    M := new FastMult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+3&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<p>However, in making this change, we've created a new problem for ourselves:</p>
<pre><code>error: source port must be available longer than the destination port requires
    ┌─ examples/tut-pipe-wrong-2.fil:18:40
    │
 18 │     mx := new Mux[32]&lt;G+2&gt;(op, r0.out, m0.out);
    │                                        ^^^^^^ source is available for @[G+3, G+4]
    │
    ┌─ ./primitives/core.fil:152:13
    │
152 │     @[G, L] in1: #WIDTH,
    │             --- destination's requirement @[G+2, G+3]
</code></pre>
<p>Filament tells us that <code>FastMult</code>'s <code>out</code> port is available in the interval [G+3, G+4) instead of [G+2, G+3) for <code>Mult</code>, i.e., the latency of <code>FastMult</code> is different from the latency of <code>Mult</code>.</p>
<p>Filament catching this bug is important-it would be very easy to miss such a mistake in a Verilog program.
Fixing it is quite mechanical:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

comp main&lt;G: 1&gt;(
    @interface[G] go: 1,
    @[G+3, G+4] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+3, G+4] out: 32)
{
    A := new Add[32];
    M := new FastMult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    // Use register to hold the adder's value
    r0 := new Register[32]&lt;G, G+4&gt;(a0.out);
    // Use the multiplexer when the mult's output is ready
    mx := new Mux[32]&lt;G+3&gt;(op, r0.out, m0.out);
    out = mx.out;
}
</code></pre>
<h3 id="registers-that-hold-on-for-too-long"><a class="header" href="#registers-that-hold-on-for-too-long">Registers that Hold on for too Long</a></h3>
<p>The final problem is quite similar to the previous one:</p>
<pre><code>error: event provided to invocation triggers more often that invocation's event's delay allows
   ┌─ examples/tut-pipe-wrong-3.fil:16:28
   │
 4 │ comp main&lt;G: 1&gt;(
   │              - this event triggers every 1 cycles
   ·
16 │     r0 := new Register[32]&lt;G, G+4&gt;(a0.out);
   │                            ^ event provided to invoke triggers too often
   │
   ┌─ ./primitives/./state.fil:4:28
   │
 4 │   comp Register[#WIDTH]&lt;G: L-(G+1), L: 1&gt;(
   │                            ------- invocation's event is allowed to trigger every 3 cycles

Compilation failed with 1 errors.
</code></pre>
<p>The compiler is telling us the register's delay is 3 cycles.
However, unlike the multiplier, this is a consequence of our decision: we make the register hold on to its value for three cycles which increases its delay.
The last line of the error message points to the problem: the delay of a register <em>depends on how we use it</em>; this means that if we make it hold onto a value for exactly one cycle, its delay is reduced to one.</p>
<p>However, the problem is that we need the computation from the adder to be available three cycles from when it starts.
To get both the pipelining and correctness we want, we need to instantiate a <em>chain of registers</em> that feed values forward.</p>
<p>The intuition behind this is that because we want our ALU to process inputs every cycle, we need to &quot;save&quot; the computation in every cycle and push it forward.</p>
<p>The final program will look like this:</p>
<pre><code class="language-filament">import &quot;primitives/core.fil&quot;;
import &quot;primitives/sequential.fil&quot;;

comp main&lt;G: 1&gt;(
    @interface[G] go: 1,
    @[G+3, G+4] op: 1,
    @[G, G+1] left: 32,
    @[G, G+1] right: 32,
) -&gt; (@[G+3, G+4] out: 32) {
    A := new Add[32];
    M := new FastMult[32];
    m0 := M&lt;G&gt;(left, right);
    a0 := A&lt;G&gt;(left, right);
    r0 := new Register[32]&lt;G, G+2&gt;(a0.out);
    r1 := new Register[32]&lt;G+1, G+3&gt;(r0.out);
    r2 := new Register[32]&lt;G+2, G+4&gt;(r1.out);
    mx := new Mux[32]&lt;G+3&gt;(op, r2.out, m0.out);
    out = mx.out;
}
</code></pre>
<h2 id="running-the-pipelined-design"><a class="header" href="#running-the-pipelined-design">Running the Pipelined Design</a></h2>
<p>Now to the moment of truth: let's run the design and see how it performs:</p>
<pre><code class="language-bash">fud e --to cocotb-out examples/tut-pipe.fil \
      -s cocotb.data examples/data.json \
      -s futil.flags ' -d canonicalize'
</code></pre>
<p>We get the following output which shows that the design took only 7 cycles to process 4 inputs:</p>
<pre><code>{&quot;out&quot;: {&quot;0&quot;: [28], &quot;1&quot;: [10], &quot;2&quot;: [66], &quot;3&quot;: [16]}, &quot;cycles&quot;: 7}
</code></pre>
<p>If you're still not convinced, try adding <a href="lang/./run.html#data-format">another transaction</a> to the data file in <code>examples/data.json</code> and see how the cycle count for the original sequential and pipelined designs change.</p>
<h2 id="something-remarkable"><a class="header" href="#something-remarkable">Something Remarkable</a></h2>
<p>During the process of pipelining, we all of our time looking at type errors.
Once the program type checked, it produced the correct output <em>and</em> was correctly pipelined.
Filament supports many other features but at its heart, this is the guarantee it provides: if your program type checks, it is correctly pipelined.
Fast and correct, you can have both!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-verilog-modules-in-filament"><a class="header" href="#using-verilog-modules-in-filament">Using Verilog Modules in Filament</a></h1>
<p>Filament is designed to make it easy to use Verilog modules in a correct and efficient manner.
In short, to use a Verilog module, a Filament program needs to:</p>
<ol>
<li>Provide the location of the Verilog module's source file</li>
<li>Provide a Filament signature for the Verilog module</li>
</ol>
<h2 id="using-extern-to-import-verilog-modules"><a class="header" href="#using-extern-to-import-verilog-modules">Using <code>extern</code> to Import Verilog Modules</a></h2>
<p>Filament's <code>extern</code> keyword allows us to specify the signatures of all Verilog modules in a source file.
For example, if we have a file <code>modules.sv</code> that defines several modules:</p>
<pre><code class="language-verilog">module Add(input [31:0] a, input [31:0] b, output [31:0] c);
...
endmodule

module Mult(input [31:0] a, input [31:0] b, output [31:0] c);
...
endmodule
</code></pre>
<p>We can use the <code>extern</code> block to specify the location of the file and provide Filament signatures for each module:</p>
<pre><code class="language-filament">extern &quot;modules.sv&quot; {
comp Add&lt;G: 1&gt;(
    @[G, G+1] a: 32, @[G, G+1] b: 32
) -&gt; (@[G, G+1] c: 32);

comp Mult&lt;G: 1&gt;(
    @[G, G+1] a: 32, @[G, G+1] b: 32
) -&gt; (@[G+2, G+3] c: 32);
}
</code></pre>
<p>Note that unlike a Filament component, the <code>comp</code> definitions do not have a body; they simply define the signature of the Verilog module.</p>
<p><strong>Note.</strong> The location of the Verilog file is determined relative to the location of the Filament file containing the <code>extern</code> block.</p>
<p>Once the definitions are specified, the Filament compiler will automatically link the Verilog modules into the final design.</p>
<h2 id="defining-the-right-interface"><a class="header" href="#defining-the-right-interface">Defining the Right Interface</a></h2>
<p>The trick with using external modules in Filament requires us to define the &quot;right&quot; interface.
For example, one way of defining a combinational component is something that produces its output in the same cycle as its inputs.
The following Filament signature captures this property</p>
<pre><code class="language-filament">extern &quot;comb.sv&quot; {
comp Add&lt;G: 1&gt;(
    @[G, G+1] left: 32, @[G, G+1] right: 32
) -&gt; (@[G, G+1] sum: 32);
}
</code></pre>
<p>The signature states that the <code>Add</code> module accepts an input in the first cycle and immediately produces the output in the same cycle.</p>
<p>However, another way to define a combinational component is something that can produce an output as long as its input is available; this means that the adder can produce the output for five or ten cycles <em>as long as</em> the input is available for <em>the same number of cycles</em>.</p>
<p>To capture such a signature, which can hold a signal for a caller defined number of cycles, we can use multiple events:</p>
<pre><code class="language-filament">comp Add&lt;G: L-(G), L: 1&gt;(
    @[G, L] left: 32,
    @[G, L] right: 32
) -&gt; (
    @[G, L] sum: 32
) where L &gt; G;
</code></pre>
<p>The above signal states that the invocation of an <code>Add</code> instance gets to decide how long the output is available for.
We require that the event <code>L</code> occurs after <code>G</code> to ensure that the intervals are well-formed.
Finally, we also require that the delay of <code>G</code> is affected by the length of the signals; if the output is held for 10 cycles, then the adder cannot be used for 10 cycles.</p>
<p>Using such an component is straightforward:</p>
<pre><code class="language-filament">A := new Add;
a := A&lt;G, G+10&gt;(l, r)
</code></pre>
<h3 id="default-binding-for-events"><a class="header" href="#default-binding-for-events">Default Binding for Events</a></h3>
<p>In the above example, the signature for <code>Add</code> is more flexible that the original one.
However, specifying the common case, where we use the adder for exactly one cycle, is a bit cumbersome:</p>
<pre><code class="language-filament">A := new Add
a := A&lt;G, G+1&gt;(l, r)
</code></pre>
<p>Instead, we can provide a default binding for the event <code>L</code> that is used when the caller does not specify a value for <code>L</code>:</p>
<pre><code class="language-filament">comp Add&lt;G: L-(G), ?L=G+1: 1&gt;(
    @[G, L] left: 32,
    @[G, L] right: 32
) -&gt; (
    @[G, L] sum: 32
) where L &gt; G;
</code></pre>
<p>The syntax <code>?L=G+1</code> tells the compiler to use the binding <code>G+1</code> for <code>L</code> when there is no binding provided for it.</p>
<blockquote>
<p><strong>Note.</strong> Events with default bindings must occur after non-default events.</p>
</blockquote>
<h2 id="optimizing-verilog-modules-using-filament-signatures"><a class="header" href="#optimizing-verilog-modules-using-filament-signatures">Optimizing Verilog Modules using Filament Signatures</a></h2>
<p>Filament's signatures are a powerful tool–if we know that a Verilog module is only going to be used in a certain way, we can optimize the module to be used in that way.
For example, if the module's interface requires that an input signal be available for multiple cycles, we don't have to save that signal in a register.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metaprogramming-overview"><a class="header" href="#metaprogramming-overview">Metaprogramming Overview</a></h1>
<p>When building hardware, it is often useful to design it <em>parameterically</em> so that we can use the same code to generate different hardware designs.
For example, it is extremely common to design modules for numerical operations, such as adders, to be parameter over the bitwidth of the operands.</p>
<pre><code class="language-verilog">module Add #(
    parameter WIDTH = 32
) (
    input [WIDTH-1:0] a,
    input [WIDTH-1:0] b,
    output [WIDTH-1:0] c
);
    assign c = a + b;
endmodule
</code></pre>
<p>The Verilog module above specifies a parameter <code>WIDTH</code> that can be used to specify the bitwidth of the operands.
User code can simply instantiate the module with the desired bitwidth:</p>
<pre><code class="language-verilog">Add #(.WIDTH(32)) adder_32(...);
Add #(.WIDTH(64)) adder_64(...);
</code></pre>
<p>Of course, this example hides the fact that metaprogramming ends up generating hardware.
This is because the <code>+</code> operation needs to be implemented differently for different bitwidths; a 32-bit adder needs a lot more circuitry than a 1-bit adder.
HDLs like Verilog provide abstractions like <a href="https://www.chipverify.com/verilog/verilog-generate-block"><code>generate</code> blocks</a> to allow users to <em>generate hardware</em> at compile time.
Languages like <a href="https://www.chisel-lang.org/">Chisel</a> go one step further to generate hardware by writing Scala programs.</p>
<p>The challenge with generative programming is ensuring that the generated code is correct.
This is harder than it seems because we don't have to ensure that one piece of code is correct; we have to ensure that <em>all possible code</em> generate-able from a module definition is correct.
Scala's strong types are useful in ensuring that code generated by <a href="https://www.chisel-lang.org/">Chisel</a> is free of some bugs, such as missing ports connections, but it misses crucial properties like correct pipelining and timing.</p>
<h3 id="filaments-promise"><a class="header" href="#filaments-promise">Filament's promise</a></h3>
<p>Our goal with Filament is to provide an expressive metaprogramming model parameteric modules that typecheck are guaranteed to generate correctly pipelined hardware.
Read on to see how we do this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-and-bundles"><a class="header" href="#loops-and-bundles">Loops and Bundles</a></h1>
<p>For now, check out this implementation:</p>
<pre><code class="language-filament">// A component that delays `in` by N cycles.
// Uses the Delay component under the hood.
comp Shift[#W, #N]&lt;G: 1&gt;(
    @[G, G+1] in: #W
) -&gt; (
    @[G+#N, G+#N+1] out: #W
) {
    bundle f[#N+1]: for&lt;#i&gt; @[G+#i, G+#i+1] #W;

    f{0} = in;
    for #i in 0..#N {
        d := new Delay[#W]&lt;G+#i&gt;(f{#i});
        f{#i+1} = d.out;
    }
    out = f{#N};
}
</code></pre>
<p><strong>TK.</strong> Explanation of how this works?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="static/custom-highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
