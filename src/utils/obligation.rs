use super::SExp;
use crate::{diagnostics::InfoIdx, errors::Error};

/// An obligation generated by during type checking.
pub struct Obligation {
    /// The constraint that needs to be satisfied
    cons: SExp,
    /// Why this obligation was created
    reason: String,
    /// Any extra information that can be used to debug the obligation
    info: Vec<InfoIdx>,
}

impl Obligation {
    /// Construct a new obligation
    pub fn new(cons: SExp, reason: String) -> Self {
        Self {
            cons,
            reason,
            info: vec![],
        }
    }

    /// Adds extra information to the obligation
    pub fn add_note(mut self, info: InfoIdx) -> Self {
        self.info.push(info);
        self
    }

    /// The constraint associated with this obligation
    pub fn constraint(&self) -> &SExp {
        &self.cons
    }

    /// Turn this Obligation into an Error
    pub fn error(self) -> Error {
        self.into()
    }
}

impl From<Obligation> for Error {
    fn from(v: Obligation) -> Self {
        let mut e = Error::misc(v.reason);
        for i in v.info {
            e = e.add_note(i);
        }
        e
    }
}
