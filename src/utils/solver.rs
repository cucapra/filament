use crate::core::{self, Time, TimeSub};
use crate::errors::{Error, FilamentResult, WithPos};
use crate::utils::GPosIdx;
use itertools::Itertools;
use rsmt2::{SmtConf, Solver};

#[derive(Clone)]
pub struct ShareConstraints {
    /// Delay bounded by the share constraint
    /// XXX: We store the event binding so that we can get the position of the binding.
    event_bind: core::EventBind,
    /// The events used to compute the minimum of start times
    starts: Vec<Time>,
    /// The (event, delay) to compute the max of start times
    ends: Vec<(Time, TimeSub)>,
    /// Additional error information
    notes: Vec<(String, GPosIdx)>,
}

impl From<core::EventBind> for ShareConstraints {
    fn from(bind: core::EventBind) -> Self {
        Self {
            starts: vec![],
            ends: vec![],
            event_bind: bind,
            notes: vec![],
        }
    }
}

impl ShareConstraints {
    pub fn add_note<S: Into<String>>(&mut self, msg: S, pos: GPosIdx) {
        self.notes.push((msg.into(), pos));
    }

    pub fn notes(self) -> Vec<(String, GPosIdx)> {
        self.notes
    }

    pub fn add_bind_info(
        &mut self,
        start: Time,
        end: (Time, TimeSub),
        pos: GPosIdx,
    ) {
        self.add_note(
            format!("Invocation active during [{start}, {}+{})", end.0, end.1),
            pos,
        );
        self.starts.push(start);
        self.ends.push(end);
    }
}
impl std::fmt::Display for ShareConstraints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let min = self.starts.iter().map(|t| t.to_string()).join(", ");
        let max = self
            .ends
            .iter()
            .map(|(t, d)| format!("{} + {}", t, d))
            .join(", ");
        let delay = &self.event_bind.delay;
        write!(f, "{delay} >= max({max}) - min({min})")
    }
}
impl From<ShareConstraints> for SExp {
    fn from(sh: ShareConstraints) -> Self {
        let min = sh
            .starts
            .into_iter()
            .map(SExp::from)
            .reduce(|a, b| SExp(format!("(min {} {})", a, b)))
            .unwrap();
        let max = sh
            .ends
            .into_iter()
            .map(|(t, d)| {
                SExp(format!("(+ {} {})", SExp::from(t), SExp::from(d)))
            })
            .reduce(|a, b| SExp(format!("(max {} {})", a, b)))
            .unwrap();

        SExp(format!(
            "(>= {} (- {max} {min}))",
            SExp::from(sh.event_bind.delay)
        ))
    }
}

/// A string that semantically represents an S-expression
#[derive(Clone)]
pub struct SExp(pub String);
impl std::fmt::Display for SExp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<u64> for SExp {
    fn from(n: u64) -> Self {
        SExp(n.to_string())
    }
}

fn define_prelude<P>(solver: &mut Solver<P>) -> FilamentResult<()> {
    solver.define_fun(
        "max",
        &[("x", "Int"), ("y", "Int")],
        "Int",
        "(ite (< x y) y x)",
    )?;
    solver.define_fun(
        "min",
        &[("x", "Int"), ("y", "Int")],
        "Int",
        "(ite (> x y) y x)",
    )?;
    solver.define_fun(
        "abs",
        &[("x", "Int")],
        "Int",
        "(ite (< x 0) (- x) x)",
    )?;
    Ok(())
}

/// A model generated by the solver: (name, args, type, value).
type Model = Vec<(String, Vec<(String, String)>, String, String)>;

/// Manager for tracking indicator variables and corresponding constraints
struct SolveManager<'a> {
    // Solver associated with this manager
    solver: &'a mut FilSolver,
    constraints: Vec<core::Constraint>,
    share_constraints: Vec<ShareConstraints>,
    // Indicator variables that need to be declared
    indicators: Vec<String>,
    // Current set of active formulas
    formulas: Vec<String>,
}

impl<'a> SolveManager<'a> {
    const FACT: &'static str = "___f";
    const SHARE: &'static str = "___s";
    const SIZE: usize = 32;

    /// Creates a new manager for the given solver
    /// Calls `push` on the base solver to create a new scope
    fn new(solver: &'a mut FilSolver) -> Self {
        solver.s.push(1).unwrap();
        Self {
            solver,
            constraints: vec![],
            share_constraints: vec![],
            indicators: vec![],
            formulas: vec![],
        }
    }

    /// Add a new constraint to the manager
    fn add_constraint(&mut self, fact: core::Constraint) {
        // Declare a new indicator variable for this constraint
        let indicator = format!("{}{}", Self::FACT, self.constraints.len());
        log::trace!("{}: {}", &indicator, &fact);
        // Add formula to relate the indicator variable to the constraint
        let formula = format!(
            "(= (= {} (_ bv1 {})) (not {}))",
            indicator,
            Self::SIZE,
            SExp::from(fact.clone())
        );
        self.constraints.push(fact);
        self.formulas.push(formula);
        self.indicators.push(indicator);
    }

    /// Add a new share constraint to the manager
    fn add_share_constraint(&mut self, share: ShareConstraints) {
        let indicator =
            format!("{}{}", Self::SHARE, self.share_constraints.len());
        log::trace!("{}: {}", &indicator, &share);
        // Add formula to relate the indicator variable to the constraint
        let formula = format!(
            "(= (= {} (_ bv1 {})) (not {}))",
            indicator,
            Self::SIZE,
            SExp::from(share.clone())
        );
        self.share_constraints.push(share);
        self.formulas.push(formula);
        self.indicators.push(indicator);
    }

    /// Assert all the constraints
    fn assert_all(&mut self) -> FilamentResult<()> {
        let solver = &mut self.solver.s;
        let sort = format!("(_ BitVec {})", Self::SIZE);
        // Declare all indicator variables
        self.indicators.iter().try_for_each(|i| {
            solver.declare_const(i, &sort)?;
            let bounded = format!(
                "(or (= (_ bv0 {}) {}) (= (_ bv1 {}) {}))",
                Self::SIZE,
                &i,
                Self::SIZE,
                &i,
            );
            solver.assert(bounded)
        })?;
        // Assert all constraints
        let all_constraints = self
            .constraints
            .iter()
            .cloned()
            .map(SExp::from)
            .chain(self.share_constraints.iter().cloned().map(SExp::from))
            .map(|c| format!("(not {})", c))
            .collect_vec();
        solver.assert(format!("(or {})", all_constraints.join(" ")))?;

        for formula in &self.formulas {
            solver.assert(formula.clone())?;
        }

        Ok(())
    }

    /// Solve the set of constraints and get all violated constraints
    fn get_all_violated(
        mut self,
    ) -> FilamentResult<(Vec<core::Constraint>, Vec<ShareConstraints>)> {
        self.assert_all()?;
        let solver = &mut self.solver.s;
        // Declare the indicator variables and assert the formula

        // Check satisfiability
        let unsat = !solver.check_sat()?;
        if unsat {
            log::trace!("No violated constraints");
            return Ok((vec![], vec![]));
        }

        // Otherwise, attempt to find a model with maximal violatations.
        // We know that there is at least one violated constraint, so we
        // can start a binary search attempting to maximize the number
        // of violated constraints.

        // Variable representing the sum of all indicator variables
        let sum = "indicator-sum";
        solver.declare_const(sum, format!("(_ BitVec {})", Self::SIZE))?;
        solver.assert(format!(
            "(= {} (bvadd {}))",
            &sum,
            self.indicators.join(" ")
        ))?;

        let mut lo = 0;
        let mut hi = self.indicators.len();
        let mut avg = (lo + hi) / 2;

        // Keep iterating till we find the maximum number of violated constraints
        while avg < hi && avg > lo {
            let act = solver.get_actlit()?;
            // Assert that the sum of the indicators is less than the average
            solver.assert_act(
                &act,
                format!("(= {} (_ bv{} {}))", &sum, avg, Self::SIZE),
            )?;
            let unsat = !solver
                .check_sat_act_or_unk([&act])?
                .unwrap_or_else(|| panic!("Returned unknown"));
            if unsat {
                log::trace!("No model with {} violations", avg);
                // If unsat, then the average is too high
                hi = avg;
            } else {
                log::trace!("Found model with {} violations", avg);
                // Otherwise, the average is too low
                lo = avg;
            }
            avg = (lo + hi + 1) / 2;
            solver.de_actlit(act)?;
        }

        // Restore the previous average
        avg = (lo + hi) / 2;

        // Get the model
        solver.assert(format!(
            "(bvuge {} (_ bv{} {}))",
            &sum,
            avg,
            Self::SIZE
        ))?;
        assert!(
            solver.check_sat()?,
            "Binary search says there is a model, but solver says unsat"
        );
        let model = solver.get_model()?;
        Ok(self.get_violated_constraints(model))
    }

    /// Get the violated constraints from the model
    fn get_violated_constraints(
        self,
        model: Model,
    ) -> (Vec<core::Constraint>, Vec<ShareConstraints>) {
        let (mut cons, mut shares) = (vec![], vec![]);
        for (name, _, _, val) in model {
            if let Some(val) = self.parse_value(&val) {
                log::trace!("{} = {}", name, val);
                if val == 1 {
                    if let Some(idx) = name.strip_prefix(Self::FACT) {
                        let idx: usize = idx.parse().unwrap();
                        cons.push(self.constraints[idx].clone())
                    } else if let Some(idx) = name.strip_prefix(Self::SHARE) {
                        let idx: usize = idx.parse().unwrap();
                        shares.push(self.share_constraints[idx].clone())
                    }
                }
            }
        }
        (cons, shares)
    }

    /// Parses a value string in the value
    fn parse_value(&self, val: &str) -> Option<usize> {
        if let Some(v) = val.strip_prefix("#b") {
            usize::from_str_radix(v, 2).ok()
        } else if let Some(v) = val.strip_prefix("#x") {
            usize::from_str_radix(v, 16).ok()
        } else {
            None
        }
    }
}

/// Drop implementation for the manager so that it correctly pops the underlying
/// solver
impl Drop for SolveManager<'_> {
    fn drop(&mut self) {
        self.solver.s.pop(1).unwrap();
    }
}

pub struct FilSolver {
    s: Solver<()>,
}

impl FilSolver {
    pub fn new() -> FilamentResult<Self> {
        let conf = SmtConf::default_z3();
        // Disable this because it doesn't seem to work with activation literals
        // conf.check_success();

        let mut solver = conf.spawn(())?;
        solver.produce_models()?;
        solver.path_tee(std::path::PathBuf::from("./model.smt"))?;

        define_prelude(&mut solver)?;
        Ok(Self { s: solver })
    }

    pub fn prove(
        &mut self,
        vars: impl Iterator<Item = core::Id>,
        assumes: Vec<core::Constraint>,
        asserts: Vec<core::Constraint>,
        sharing: Vec<ShareConstraints>,
    ) -> FilamentResult<()> {
        if asserts.is_empty() {
            return Ok(());
        }

        let mut manager = SolveManager::new(self);
        // Define all the constants
        for var in vars {
            log::trace!("Declaring constant {}", var);
            manager.solver.s.declare_const(var.to_string(), "Int")?;
        }

        // Define assumptions on constraints
        for assume in assumes {
            let sexp: SExp = assume.into();
            manager.solver.s.assert(format!("{}", sexp))?;
        }

        // Build up the full formula
        asserts
            .into_iter()
            .for_each(|fact| manager.add_constraint(fact));
        sharing.into_iter().for_each(|share| {
            manager.add_share_constraint(share);
        });

        // Get all the constraints that were violated
        let (cons, share_cons) = manager.get_all_violated()?;
        // For each violated constraint, display the error
        for cons in cons {
            log::error!("Constraint violated: {}", cons);
        }
        for share_cons in share_cons {
            log::error!("Share constraint violated: {}", share_cons);
        }

        Ok(())
    }
}
