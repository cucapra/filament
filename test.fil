comp Foo[#W]<G: 1>(
  @[G, G+1] in: #W,
) -> (
  @[G, G+1] out: #W,
) where #W > 0 {
  out = in;
}

comp TradeoffDiv[#W, #I, #K]<G: 1>(
  @interface[G] go: 1,
  @[G, G+1] left: #W,
) -> (
  @[G+#W, G+#W+1] out: #W,
) where
  #I > 0,
  #K > 0,
  #W == #I * #K
{
    i := new Foo[#W]<G>(left);
    bundle o_acc[#I+1]: for<#a> @[G+#a*#K, G+#a*#K+1] #W;
    o_acc{0} = i.out;
}