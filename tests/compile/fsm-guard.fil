// Tests the guards of an fsm.

comp test2[#DELAY]<G: #DELAY>(
    in: [G, G+#DELAY] 32,
) -> (
    out[#DELAY]: for<#i> [G+#i, G+#i+1] 32
) where #DELAY > 0 {
    for #ii in 0..#DELAY {
        out{#ii} = in;
    }
}

comp test[#DELAY, #NUM]<G: #DELAY>(
    in[#NUM]: for<#j> [G+#j*#DELAY, G+#j*#DELAY+#DELAY] 32
) -> (
    out[#NUM*#DELAY]: for<#i> [G+#i, G+#i+1] 32
) where #DELAY > 0, #NUM > 0 {
    for #ii in 0..#NUM {
        let #BASE = #ii*#DELAY;
        con := new test2[#DELAY]<G+#BASE>(in{#ii});
        out{#BASE..#BASE+#DELAY} = con.out{0..#DELAY};
    }
}

comp main<G: 9>(
    in: [G, G+9] 32,
) -> (
    out0: [G, G+1] 32,
    out1: [G+1, G+2] 32,
    out2: [G+2, G+3] 32,
    out3: [G+3, G+4] 32,
    out4: [G+4, G+5] 32,
    out5: [G+5, G+6] 32,
    out6: [G+6, G+7] 32,
    out7: [G+7, G+8] 32,
    out8: [G+8, G+9] 32
) {
    bundle inb[3]: for<#i> [G+#i*3, G+#i*3+3] 32;
    inb{0} = in;
    inb{1} = in;
    inb{2} = in;

    tester := new test[3, 3]<G>(inb{0..3});

    out0 = tester.out{0};
    out1 = tester.out{1};
    out2 = tester.out{2};
    out3 = tester.out{3};
    out4 = tester.out{4};
    out5 = tester.out{5};
    out6 = tester.out{6};
    out7 = tester.out{7};
    out8 = tester.out{8};
}