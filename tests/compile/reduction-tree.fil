import "primitives/core.fil";

// Implement a additive reduction tree
comp AddRed[#W, #N, #K]<G:1>(
    in[#N]: for<#i> @[G, G+1] #W
) -> (
    @[G+#K, G+#K+1] out: #W
) where #W > 1,
        #N >= 1,
        #N == pow2(#K),
        #K >= 0
{
    if #K == 0 {
        out = in{0};
    } else {
        // Required to make recursive calls type check.
        assume pow2(#K-1) == #N/2;
        // This is a corollary of #K != 0
        assume #N >= 2;
        // This is not true in general for integer division but
        // because #N is a power of 2 it is true.
        assume #N - #N/2 == #N/2;

        left := new AddRed[#W, #N/2, #K-1]<G>(in{0..#N/2});
        right := new AddRed[#W, #N/2, #K-1]<G>(in{#N/2..#N});
        add := new Add[#W]<G+#K-1>(left.out, right.out);
        d := new Delay[#W]<G+#K-1>(add.out);
        out = d.out;
    }
}

comp main<G:1>(
    @[G, G+1] in0: 32,
    @[G, G+1] in1: 32,
    @[G, G+1] in2: 32,
    @[G, G+1] in3: 32,
) -> (
    @[G+2, G+3] out: 32
) {
    bundle in[4]: for<#i> @[G, G+1] 32;
    in{0} = in0; in{1} = in1; in{2} = in2; in{3} = in3;
    reduce := new AddRed[32, 4, 2]<G>(in{0..4});
    out = reduce.out;
}