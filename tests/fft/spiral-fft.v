/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2005-2011 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 8 complex words per cycle
//   Throughput: one transform every 1 cycles
//   Latency: 12 cycles

//   Resources required:
//     4 multipliers (32 x 32 bit)
//     52 adders (32 x 32 bit)

// Generated on Mon Sep 25 22:29:29 UTC 2023

// Latency: 12 clock cycles
// Throughput: 1 transform every 1 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 1 cycles.  This means that
// 1 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
// on the following cycle.

// The system has a latency of 12 cycles.  This means that
// the 'next_out' will be asserted 12 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.


module dft_testbench ();
  reg clk, reset, next;
  wire next_out;
  integer i, j, k, l, m;
  reg [15:0] counter;
  reg [31:0] in[15:0];
  wire [31:0] X0;
  wire [31:0] Y0;
  wire [31:0] X1;
  wire [31:0] Y1;
  wire [31:0] X2;
  wire [31:0] Y2;
  wire [31:0] X3;
  wire [31:0] Y3;
  wire [31:0] X4;
  wire [31:0] Y4;
  wire [31:0] X5;
  wire [31:0] Y5;
  wire [31:0] X6;
  wire [31:0] Y6;
  wire [31:0] X7;
  wire [31:0] Y7;
  wire [31:0] X8;
  wire [31:0] Y8;
  wire [31:0] X9;
  wire [31:0] Y9;
  wire [31:0] X10;
  wire [31:0] Y10;
  wire [31:0] X11;
  wire [31:0] Y11;
  wire [31:0] X12;
  wire [31:0] Y12;
  wire [31:0] X13;
  wire [31:0] Y13;
  wire [31:0] X14;
  wire [31:0] Y14;
  wire [31:0] X15;
  wire [31:0] Y15;
  reg clrCnt;
  assign X0  = in[0];
  assign X1  = in[1];
  assign X2  = in[2];
  assign X3  = in[3];
  assign X4  = in[4];
  assign X5  = in[5];
  assign X6  = in[6];
  assign X7  = in[7];
  assign X8  = in[8];
  assign X9  = in[9];
  assign X10 = in[10];
  assign X11 = in[11];
  assign X12 = in[12];
  assign X13 = in[13];
  assign X14 = in[14];
  assign X15 = in[15];

  initial clk = 0;

  always #10000 clk = ~clk;


  // Instantiate top-level module of core 'X' signals are system inputs
  // and 'Y' signals are system outputs
  dft_top dft_top_instance (
      .clk(clk),
      .reset(reset),
      .next(next),
      .next_out(next_out),
      .X0(X0),
      .Y0(Y0),
      .X1(X1),
      .Y1(Y1),
      .X2(X2),
      .Y2(Y2),
      .X3(X3),
      .Y3(Y3),
      .X4(X4),
      .Y4(Y4),
      .X5(X5),
      .Y5(Y5),
      .X6(X6),
      .Y6(Y6),
      .X7(X7),
      .Y7(Y7),
      .X8(X8),
      .Y8(Y8),
      .X9(X9),
      .Y9(Y9),
      .X10(X10),
      .Y10(Y10),
      .X11(X11),
      .Y11(Y11),
      .X12(X12),
      .Y12(Y12),
      .X13(X13),
      .Y13(Y13),
      .X14(X14),
      .Y14(Y14),
      .X15(X15),
      .Y15(Y15)
  );

  // You can use this counter to verify that the gap and latency are as expected.
  always @(posedge clk) begin
    if (clrCnt) counter <= 0;
    else counter <= counter + 1;
  end


  initial begin
    @(posedge clk);
    @(posedge clk);

    // On the next cycle, begin loading input vector.
    next   <= 1;
    clrCnt <= 1;
    @(posedge clk);
    clrCnt <= 0;
    next   <= 0;

    // The 8 complex data points enter the system over 1 cycles
    for (j = 0; j < 0; j = j + 1) begin
      // Input: 8 complex words per cycle
      for (k = 0; k < 16; k = k + 1) begin
        in[k] <= j * 16 + k;
      end
      @(posedge clk);
    end
    j = 0;
    for (k = 0; k < 16; k = k + 1) begin
      in[k] <= j * 16 + k;
    end


    @(posedge clk);
    // Wait until the next data vector can be entered
    while (counter < 0) @(posedge clk);

    // On the next cycle, we will start the next data vector
    next   <= 1;
    clrCnt <= 1;
    @(posedge clk);
    clrCnt <= 0;
    next   <= 0;

    // Start entering next input vector
    for (j = 0; j < 0; j = j + 1) begin
      // Input 16 words per cycle
      for (k = 0; k < 16; k = k + 1) begin
        in[k] <= 16 + j * 16 + k;
      end
      @(posedge clk);
    end
    j = 0;
    for (k = 0; k < 16; k = k + 1) begin
      in[k] <= 16 + j * 16 + k;
    end
  end


  initial begin
    // set initial values
    in[0]  <= 0;
    in[1]  <= 0;
    in[2]  <= 0;
    in[3]  <= 0;
    in[4]  <= 0;
    in[5]  <= 0;
    in[6]  <= 0;
    in[7]  <= 0;
    in[8]  <= 0;
    in[9]  <= 0;
    in[10] <= 0;
    in[11] <= 0;
    in[12] <= 0;
    in[13] <= 0;
    in[14] <= 0;
    in[15] <= 0;
    next   <= 0;
    reset  <= 0;

    @(posedge clk);
    reset <= 1;
    @(posedge clk);
    reset <= 0;
    @(posedge clk);
    @(posedge clk);
    // Wait until next_out goes high, then wait one clock cycle and begin receiving data
    @(posedge next_out);
    @(posedge clk);
    #1;
    $display("--- begin output 1---");

    for (m = 0; m < 0; m = m + 1) begin
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $display("%x", Y4);
      $display("%x", Y5);
      $display("%x", Y6);
      $display("%x", Y7);
      $display("%x", Y8);
      $display("%x", Y9);
      $display("%x", Y10);
      $display("%x", Y11);
      $display("%x", Y12);
      $display("%x", Y13);
      $display("%x", Y14);
      $display("%x", Y15);
      @(posedge clk);
      #1;
    end
    $display("%x", Y0);
    $display("%x", Y1);
    $display("%x", Y2);
    $display("%x", Y3);
    $display("%x", Y4);
    $display("%x", Y5);
    $display("%x", Y6);
    $display("%x", Y7);
    $display("%x", Y8);
    $display("%x", Y9);
    $display("%x", Y10);
    $display("%x", Y11);
    $display("%x", Y12);
    $display("%x", Y13);
    $display("%x", Y14);
    $display("%x", Y15);
    // Wait until next_out goes high, then wait one clock cycle and begin receiving data
    @(posedge next_out);
    @(posedge clk);
    #1;
    $display("--- begin output 2---");

    for (m = 0; m < 0; m = m + 1) begin
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $display("%x", Y4);
      $display("%x", Y5);
      $display("%x", Y6);
      $display("%x", Y7);
      $display("%x", Y8);
      $display("%x", Y9);
      $display("%x", Y10);
      $display("%x", Y11);
      $display("%x", Y12);
      $display("%x", Y13);
      $display("%x", Y14);
      $display("%x", Y15);
      @(posedge clk);
      #1;
    end
    $display("%x", Y0);
    $display("%x", Y1);
    $display("%x", Y2);
    $display("%x", Y3);
    $display("%x", Y4);
    $display("%x", Y5);
    $display("%x", Y6);
    $display("%x", Y7);
    $display("%x", Y8);
    $display("%x", Y9);
    $display("%x", Y10);
    $display("%x", Y11);
    $display("%x", Y12);
    $display("%x", Y13);
    $display("%x", Y14);
    $display("%x", Y15);
    $finish;
  end
endmodule

// Latency: 12
// Gap: 1
// module_name_is:dft_top
module dft_top (
    clk,
    reset,
    next,
    next_out,
    X0,
    Y0,
    X1,
    Y1,
    X2,
    Y2,
    X3,
    Y3,
    X4,
    Y4,
    X5,
    Y5,
    X6,
    Y6,
    X7,
    Y7,
    X8,
    Y8,
    X9,
    Y9,
    X10,
    Y10,
    X11,
    Y11,
    X12,
    Y12,
    X13,
    Y13,
    X14,
    Y14,
    X15,
    Y15
);

  output next_out;
  input clk, reset, next;

  input [31:0] X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15;

  output [31:0] Y0, Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8, Y9, Y10, Y11, Y12, Y13, Y14, Y15;

  wire [31:0] t0_0;
  wire [31:0] t0_1;
  wire [31:0] t0_2;
  wire [31:0] t0_3;
  wire [31:0] t0_4;
  wire [31:0] t0_5;
  wire [31:0] t0_6;
  wire [31:0] t0_7;
  wire [31:0] t0_8;
  wire [31:0] t0_9;
  wire [31:0] t0_10;
  wire [31:0] t0_11;
  wire [31:0] t0_12;
  wire [31:0] t0_13;
  wire [31:0] t0_14;
  wire [31:0] t0_15;
  wire next_0;
  wire [31:0] t1_0;
  wire [31:0] t1_1;
  wire [31:0] t1_2;
  wire [31:0] t1_3;
  wire [31:0] t1_4;
  wire [31:0] t1_5;
  wire [31:0] t1_6;
  wire [31:0] t1_7;
  wire [31:0] t1_8;
  wire [31:0] t1_9;
  wire [31:0] t1_10;
  wire [31:0] t1_11;
  wire [31:0] t1_12;
  wire [31:0] t1_13;
  wire [31:0] t1_14;
  wire [31:0] t1_15;
  wire next_1;
  wire [31:0] t2_0;
  wire [31:0] t2_1;
  wire [31:0] t2_2;
  wire [31:0] t2_3;
  wire [31:0] t2_4;
  wire [31:0] t2_5;
  wire [31:0] t2_6;
  wire [31:0] t2_7;
  wire [31:0] t2_8;
  wire [31:0] t2_9;
  wire [31:0] t2_10;
  wire [31:0] t2_11;
  wire [31:0] t2_12;
  wire [31:0] t2_13;
  wire [31:0] t2_14;
  wire [31:0] t2_15;
  wire next_2;
  assign t0_0 = X0;
  assign Y0 = t2_0;
  assign t0_1 = X1;
  assign Y1 = t2_1;
  assign t0_2 = X2;
  assign Y2 = t2_2;
  assign t0_3 = X3;
  assign Y3 = t2_3;
  assign t0_4 = X4;
  assign Y4 = t2_4;
  assign t0_5 = X5;
  assign Y5 = t2_5;
  assign t0_6 = X6;
  assign Y6 = t2_6;
  assign t0_7 = X7;
  assign Y7 = t2_7;
  assign t0_8 = X8;
  assign Y8 = t2_8;
  assign t0_9 = X9;
  assign Y9 = t2_9;
  assign t0_10 = X10;
  assign Y10 = t2_10;
  assign t0_11 = X11;
  assign Y11 = t2_11;
  assign t0_12 = X12;
  assign Y12 = t2_12;
  assign t0_13 = X13;
  assign Y13 = t2_13;
  assign t0_14 = X14;
  assign Y14 = t2_14;
  assign t0_15 = X15;
  assign Y15 = t2_15;
  assign next_0 = next;
  assign next_out = next_2;

  // latency=9, gap=1
  codeBlock69344 stage0 (
      .clk(clk),
      .reset(reset),
      .next_in(next_0),
      .next_out(next_1),
      .X0_in(t0_0),
      .Y0(t1_0),
      .X1_in(t0_1),
      .Y1(t1_1),
      .X2_in(t0_2),
      .Y2(t1_2),
      .X3_in(t0_3),
      .Y3(t1_3),
      .X4_in(t0_4),
      .Y4(t1_4),
      .X5_in(t0_5),
      .Y5(t1_5),
      .X6_in(t0_6),
      .Y6(t1_6),
      .X7_in(t0_7),
      .Y7(t1_7),
      .X8_in(t0_8),
      .Y8(t1_8),
      .X9_in(t0_9),
      .Y9(t1_9),
      .X10_in(t0_10),
      .Y10(t1_10),
      .X11_in(t0_11),
      .Y11(t1_11),
      .X12_in(t0_12),
      .Y12(t1_12),
      .X13_in(t0_13),
      .Y13(t1_13),
      .X14_in(t0_14),
      .Y14(t1_14),
      .X15_in(t0_15),
      .Y15(t1_15)
  );


  // latency=3, gap=1
  codeBlock69708 stage1 (
      .clk(clk),
      .reset(reset),
      .next_in(next_1),
      .next_out(next_2),
      .X0_in(t1_0),
      .Y0(t2_0),
      .X1_in(t1_1),
      .Y1(t2_1),
      .X2_in(t1_2),
      .Y2(t2_2),
      .X3_in(t1_3),
      .Y3(t2_3),
      .X4_in(t1_4),
      .Y4(t2_4),
      .X5_in(t1_5),
      .Y5(t2_5),
      .X6_in(t1_6),
      .Y6(t2_6),
      .X7_in(t1_7),
      .Y7(t2_7),
      .X8_in(t1_8),
      .Y8(t2_8),
      .X9_in(t1_9),
      .Y9(t2_9),
      .X10_in(t1_10),
      .Y10(t2_10),
      .X11_in(t1_11),
      .Y11(t2_11),
      .X12_in(t1_12),
      .Y12(t2_12),
      .X13_in(t1_13),
      .Y13(t2_13),
      .X14_in(t1_14),
      .Y14(t2_14),
      .X15_in(t1_15),
      .Y15(t2_15)
  );


endmodule

// Latency: 9
// Gap: 1
module codeBlock69344 (
    clk,
    reset,
    next_in,
    next_out,
    X0_in,
    Y0,
    X1_in,
    Y1,
    X2_in,
    Y2,
    X3_in,
    Y3,
    X4_in,
    Y4,
    X5_in,
    Y5,
    X6_in,
    Y6,
    X7_in,
    Y7,
    X8_in,
    Y8,
    X9_in,
    Y9,
    X10_in,
    Y10,
    X11_in,
    Y11,
    X12_in,
    Y12,
    X13_in,
    Y13,
    X14_in,
    Y14,
    X15_in,
    Y15
);

  output next_out;
  input clk, reset, next_in;

  reg next;

  input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in,
      X8_in,
      X9_in,
      X10_in,
      X11_in,
      X12_in,
      X13_in,
      X14_in,
      X15_in;

  reg [31:0] X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15;

  output [31:0] Y0, Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8, Y9, Y10, Y11, Y12, Y13, Y14, Y15;

  shiftRegFIFO #(8, 1) shiftFIFO_70465 (
      .X  (next),
      .Y  (next_out),
      .clk(clk)
  );


  wire signed [31:0] a109;
  wire signed [31:0] a110;
  wire signed [31:0] a111;
  wire signed [31:0] a112;
  wire signed [31:0] a117;
  wire signed [31:0] a118;
  wire signed [31:0] a119;
  wire signed [31:0] a120;
  wire signed [31:0] a125;
  wire signed [31:0] a126;
  wire signed [31:0] a127;
  wire signed [31:0] a128;
  wire signed [31:0] a133;
  wire signed [31:0] a134;
  wire signed [31:0] a135;
  wire signed [31:0] a136;
  wire signed [31:0] t349;
  wire signed [31:0] t350;
  wire signed [31:0] t351;
  wire signed [31:0] t352;
  wire signed [31:0] t353;
  wire signed [31:0] t354;
  wire signed [31:0] t355;
  wire signed [31:0] t356;
  wire signed [31:0] t359;
  wire signed [31:0] t360;
  wire signed [31:0] t361;
  wire signed [31:0] t362;
  wire signed [31:0] t363;
  wire signed [31:0] t364;
  wire signed [31:0] t365;
  wire signed [31:0] t366;
  reg signed  [31:0] tm4;
  reg signed  [31:0] tm11;
  reg signed  [31:0] tm18;
  reg signed  [31:0] tm25;
  reg signed  [31:0] tm32;
  reg signed  [31:0] tm39;
  reg signed  [31:0] tm46;
  reg signed  [31:0] tm53;
  reg signed  [31:0] tm60;
  reg signed  [31:0] tm67;
  reg signed  [31:0] tm74;
  reg signed  [31:0] tm81;
  reg signed  [31:0] tm5;
  reg signed  [31:0] tm12;
  reg signed  [31:0] tm19;
  reg signed  [31:0] tm26;
  reg signed  [31:0] tm33;
  reg signed  [31:0] tm40;
  reg signed  [31:0] tm47;
  reg signed  [31:0] tm54;
  reg signed  [31:0] tm61;
  reg signed  [31:0] tm68;
  reg signed  [31:0] tm75;
  reg signed  [31:0] tm82;
  reg signed  [31:0] tm6;
  reg signed  [31:0] tm13;
  reg signed  [31:0] tm20;
  reg signed  [31:0] tm27;
  reg signed  [31:0] tm34;
  reg signed  [31:0] tm41;
  reg signed  [31:0] tm48;
  reg signed  [31:0] tm55;
  reg signed  [31:0] tm62;
  reg signed  [31:0] tm69;
  reg signed  [31:0] tm76;
  reg signed  [31:0] tm83;
  reg signed  [31:0] tm7;
  reg signed  [31:0] tm14;
  reg signed  [31:0] tm21;
  reg signed  [31:0] tm28;
  reg signed  [31:0] tm35;
  reg signed  [31:0] tm42;
  reg signed  [31:0] tm49;
  reg signed  [31:0] tm56;
  reg signed  [31:0] tm63;
  reg signed  [31:0] tm70;
  reg signed  [31:0] tm77;
  reg signed  [31:0] tm84;
  reg signed  [31:0] tm8;
  reg signed  [31:0] tm15;
  reg signed  [31:0] tm22;
  reg signed  [31:0] tm29;
  reg signed  [31:0] tm36;
  reg signed  [31:0] tm43;
  reg signed  [31:0] tm50;
  reg signed  [31:0] tm57;
  reg signed  [31:0] tm64;
  reg signed  [31:0] tm71;
  reg signed  [31:0] tm78;
  reg signed  [31:0] tm85;
  wire signed [31:0] a105;
  wire signed [31:0] a106;
  wire signed [31:0] a107;
  wire signed [31:0] a108;
  reg signed  [31:0] tm9;
  reg signed  [31:0] tm16;
  reg signed  [31:0] tm23;
  reg signed  [31:0] tm30;
  reg signed  [31:0] tm37;
  reg signed  [31:0] tm44;
  reg signed  [31:0] tm51;
  reg signed  [31:0] tm58;
  reg signed  [31:0] tm65;
  reg signed  [31:0] tm72;
  reg signed  [31:0] tm79;
  reg signed  [31:0] tm86;
  wire signed [31:0] Y0;
  wire signed [31:0] Y1;
  wire signed [31:0] Y2;
  wire signed [31:0] Y3;
  wire signed [31:0] t357;
  wire signed [31:0] t358;
  wire signed [31:0] Y4;
  wire signed [31:0] Y5;
  wire signed [31:0] Y6;
  wire signed [31:0] Y7;
  wire signed [31:0] Y8;
  wire signed [31:0] Y9;
  wire signed [31:0] Y10;
  wire signed [31:0] Y11;
  wire signed [31:0] t367;
  wire signed [31:0] t368;
  wire signed [31:0] Y12;
  wire signed [31:0] Y13;
  wire signed [31:0] Y14;
  wire signed [31:0] Y15;
  reg signed  [31:0] tm10;
  reg signed  [31:0] tm17;
  reg signed  [31:0] tm24;
  reg signed  [31:0] tm31;
  reg signed  [31:0] tm38;
  reg signed  [31:0] tm45;
  reg signed  [31:0] tm52;
  reg signed  [31:0] tm59;
  reg signed  [31:0] tm66;
  reg signed  [31:0] tm73;
  reg signed  [31:0] tm80;
  reg signed  [31:0] tm87;

  wire signed [31:0] tm0;
  assign tm0  = 32'h2d413ccd;

  assign a109 = X0;
  assign a110 = X8;
  assign a111 = X1;
  assign a112 = X9;
  assign a117 = X2;
  assign a118 = X10;
  assign a119 = X3;
  assign a120 = X11;
  assign a125 = X4;
  assign a126 = X12;
  assign a127 = X5;
  assign a128 = X13;
  assign a133 = X6;
  assign a134 = X14;
  assign a135 = X7;
  assign a136 = X15;
  assign Y0   = tm10;
  assign Y1   = tm17;
  assign Y2   = tm24;
  assign Y3   = tm31;
  assign Y4   = tm38;
  assign Y5   = tm45;
  assign Y6   = t357;
  assign Y7   = t358;
  assign Y8   = tm52;
  assign Y9   = tm59;
  assign Y10  = tm66;
  assign Y11  = tm73;
  assign Y12  = tm80;
  assign Y13  = tm87;
  assign Y14  = t367;
  assign Y15  = (~(t368) + 1);

  addfxp #(32, 1) add69356 (
      .a  (a109),
      .b  (a110),
      .clk(clk),
      .q  (t349)
  );  // 0
  addfxp #(32, 1) add69371 (
      .a  (a111),
      .b  (a112),
      .clk(clk),
      .q  (t350)
  );  // 0
  subfxp #(32, 1) sub69386 (
      .a  (a109),
      .b  (a110),
      .clk(clk),
      .q  (t351)
  );  // 0
  subfxp #(32, 1) sub69401 (
      .a  (a111),
      .b  (a112),
      .clk(clk),
      .q  (t352)
  );  // 0
  addfxp #(32, 1) add69432 (
      .a  (a117),
      .b  (a118),
      .clk(clk),
      .q  (t353)
  );  // 0
  addfxp #(32, 1) add69447 (
      .a  (a119),
      .b  (a120),
      .clk(clk),
      .q  (t354)
  );  // 0
  subfxp #(32, 1) sub69462 (
      .a  (a117),
      .b  (a118),
      .clk(clk),
      .q  (t355)
  );  // 0
  subfxp #(32, 1) sub69477 (
      .a  (a119),
      .b  (a120),
      .clk(clk),
      .q  (t356)
  );  // 0
  addfxp #(32, 1) add69536 (
      .a  (a125),
      .b  (a126),
      .clk(clk),
      .q  (t359)
  );  // 0
  addfxp #(32, 1) add69551 (
      .a  (a127),
      .b  (a128),
      .clk(clk),
      .q  (t360)
  );  // 0
  subfxp #(32, 1) sub69566 (
      .a  (a125),
      .b  (a126),
      .clk(clk),
      .q  (t361)
  );  // 0
  subfxp #(32, 1) sub69581 (
      .a  (a127),
      .b  (a128),
      .clk(clk),
      .q  (t362)
  );  // 0
  addfxp #(32, 1) add69613 (
      .a  (a133),
      .b  (a134),
      .clk(clk),
      .q  (t363)
  );  // 0
  addfxp #(32, 1) add69628 (
      .a  (a135),
      .b  (a136),
      .clk(clk),
      .q  (t364)
  );  // 0
  subfxp #(32, 1) sub69643 (
      .a  (a133),
      .b  (a134),
      .clk(clk),
      .q  (t365)
  );  // 0
  subfxp #(32, 1) sub69658 (
      .a  (a135),
      .b  (a136),
      .clk(clk),
      .q  (t366)
  );  // 0
  multfix #(32, 6) m69484 (
      .a(tm0),
      .b(t355),
      .clk(clk),
      .q_sc(a105),
      .q_unsc(),
      .rst(reset)
  );
  multfix #(32, 6) m69491 (
      .a(tm0),
      .b(t356),
      .clk(clk),
      .q_sc(a106),
      .q_unsc(),
      .rst(reset)
  );
  multfix #(32, 6) m69665 (
      .a(tm0),
      .b(t366),
      .clk(clk),
      .q_sc(a107),
      .q_unsc(),
      .rst(reset)
  );
  multfix #(32, 6) m69672 (
      .a(tm0),
      .b(t365),
      .clk(clk),
      .q_sc(a108),
      .q_unsc(),
      .rst(reset)
  );
  addfxp #(32, 1) add69498 (
      .a  (a105),
      .b  (a106),
      .clk(clk),
      .q  (t357)
  );  // 7
  subfxp #(32, 1) sub69505 (
      .a  (a106),
      .b  (a105),
      .clk(clk),
      .q  (t358)
  );  // 7
  subfxp #(32, 1) sub69679 (
      .a  (a107),
      .b  (a108),
      .clk(clk),
      .q  (t367)
  );  // 7
  addfxp #(32, 1) add69686 (
      .a  (a108),
      .b  (a107),
      .clk(clk),
      .q  (t368)
  );  // 7


  always @(posedge clk) begin
    if (reset == 1) begin
    end else begin
      X0   <= X0_in;
      X1   <= X1_in;
      X2   <= X2_in;
      X3   <= X3_in;
      X4   <= X4_in;
      X5   <= X5_in;
      X6   <= X6_in;
      X7   <= X7_in;
      X8   <= X8_in;
      X9   <= X9_in;
      X10  <= X10_in;
      X11  <= X11_in;
      X12  <= X12_in;
      X13  <= X13_in;
      X14  <= X14_in;
      X15  <= X15_in;
      next <= next_in;
      tm4  <= t349;
      tm11 <= t350;
      tm18 <= t351;
      tm25 <= t352;
      tm32 <= t353;
      tm39 <= t354;
      tm46 <= t359;
      tm53 <= t360;
      tm60 <= t362;
      tm67 <= (~(t361) + 1);
      tm74 <= t363;
      tm81 <= t364;
      tm5  <= tm4;
      tm12 <= tm11;
      tm19 <= tm18;
      tm26 <= tm25;
      tm33 <= tm32;
      tm40 <= tm39;
      tm47 <= tm46;
      tm54 <= tm53;
      tm61 <= tm60;
      tm68 <= tm67;
      tm75 <= tm74;
      tm82 <= tm81;
      tm6  <= tm5;
      tm13 <= tm12;
      tm20 <= tm19;
      tm27 <= tm26;
      tm34 <= tm33;
      tm41 <= tm40;
      tm48 <= tm47;
      tm55 <= tm54;
      tm62 <= tm61;
      tm69 <= tm68;
      tm76 <= tm75;
      tm83 <= tm82;
      tm7  <= tm6;
      tm14 <= tm13;
      tm21 <= tm20;
      tm28 <= tm27;
      tm35 <= tm34;
      tm42 <= tm41;
      tm49 <= tm48;
      tm56 <= tm55;
      tm63 <= tm62;
      tm70 <= tm69;
      tm77 <= tm76;
      tm84 <= tm83;
      tm8  <= tm7;
      tm15 <= tm14;
      tm22 <= tm21;
      tm29 <= tm28;
      tm36 <= tm35;
      tm43 <= tm42;
      tm50 <= tm49;
      tm57 <= tm56;
      tm64 <= tm63;
      tm71 <= tm70;
      tm78 <= tm77;
      tm85 <= tm84;
      tm9  <= tm8;
      tm16 <= tm15;
      tm23 <= tm22;
      tm30 <= tm29;
      tm37 <= tm36;
      tm44 <= tm43;
      tm51 <= tm50;
      tm58 <= tm57;
      tm65 <= tm64;
      tm72 <= tm71;
      tm79 <= tm78;
      tm86 <= tm85;
      tm10 <= tm9;
      tm17 <= tm16;
      tm24 <= tm23;
      tm31 <= tm30;
      tm38 <= tm37;
      tm45 <= tm44;
      tm52 <= tm51;
      tm59 <= tm58;
      tm66 <= tm65;
      tm73 <= tm72;
      tm80 <= tm79;
      tm87 <= tm86;
    end
  end
endmodule

module shiftRegFIFO (
    X,
    Y,
    clk
);
  parameter depth = 1, width = 1;

  output [width-1:0] Y;
  input [width-1:0] X;
  input clk;

  reg     [width-1:0] mem   [depth-1:0];
  integer             index;

  assign Y = mem[depth-1];

  always @(posedge clk) begin
    for (index = 1; index < depth; index = index + 1) begin
      mem[index] <= mem[index-1];
    end
    mem[0] <= X;
  end
endmodule

// Latency: 3
// Gap: 1
module codeBlock69708 (
    clk,
    reset,
    next_in,
    next_out,
    X0_in,
    Y0,
    X1_in,
    Y1,
    X2_in,
    Y2,
    X3_in,
    Y3,
    X4_in,
    Y4,
    X5_in,
    Y5,
    X6_in,
    Y6,
    X7_in,
    Y7,
    X8_in,
    Y8,
    X9_in,
    Y9,
    X10_in,
    Y10,
    X11_in,
    Y11,
    X12_in,
    Y12,
    X13_in,
    Y13,
    X14_in,
    Y14,
    X15_in,
    Y15
);

  output next_out;
  input clk, reset, next_in;

  reg next;

  input [31:0] X0_in,
      X1_in,
      X2_in,
      X3_in,
      X4_in,
      X5_in,
      X6_in,
      X7_in,
      X8_in,
      X9_in,
      X10_in,
      X11_in,
      X12_in,
      X13_in,
      X14_in,
      X15_in;

  reg [31:0] X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15;

  output [31:0] Y0, Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8, Y9, Y10, Y11, Y12, Y13, Y14, Y15;

  shiftRegFIFO #(2, 1) shiftFIFO_70468 (
      .X  (next),
      .Y  (next_out),
      .clk(clk)
  );


  wire signed [31:0] a33;
  wire signed [31:0] a34;
  wire signed [31:0] a35;
  wire signed [31:0] a36;
  wire signed [31:0] a41;
  wire signed [31:0] a42;
  wire signed [31:0] a43;
  wire signed [31:0] a44;
  wire signed [31:0] a49;
  wire signed [31:0] a50;
  wire signed [31:0] a51;
  wire signed [31:0] a52;
  wire signed [31:0] a57;
  wire signed [31:0] a58;
  wire signed [31:0] a59;
  wire signed [31:0] a60;
  wire signed [31:0] t209;
  wire signed [31:0] t210;
  wire signed [31:0] t211;
  wire signed [31:0] t212;
  wire signed [31:0] t213;
  wire signed [31:0] t214;
  wire signed [31:0] t215;
  wire signed [31:0] t216;
  wire signed [31:0] t225;
  wire signed [31:0] t226;
  wire signed [31:0] t227;
  wire signed [31:0] t228;
  wire signed [31:0] t229;
  wire signed [31:0] t230;
  wire signed [31:0] t231;
  wire signed [31:0] t232;
  wire signed [31:0] t217;
  wire signed [31:0] t218;
  wire signed [31:0] t219;
  wire signed [31:0] t220;
  wire signed [31:0] Y0;
  wire signed [31:0] Y1;
  wire signed [31:0] Y8;
  wire signed [31:0] Y9;
  wire signed [31:0] t221;
  wire signed [31:0] t222;
  wire signed [31:0] t223;
  wire signed [31:0] t224;
  wire signed [31:0] Y4;
  wire signed [31:0] Y5;
  wire signed [31:0] Y12;
  wire signed [31:0] Y13;
  wire signed [31:0] t233;
  wire signed [31:0] t234;
  wire signed [31:0] t235;
  wire signed [31:0] t236;
  wire signed [31:0] Y2;
  wire signed [31:0] Y3;
  wire signed [31:0] Y10;
  wire signed [31:0] Y11;
  wire signed [31:0] t237;
  wire signed [31:0] t238;
  wire signed [31:0] t239;
  wire signed [31:0] t240;
  wire signed [31:0] Y6;
  wire signed [31:0] Y7;
  wire signed [31:0] Y14;
  wire signed [31:0] Y15;


  assign a33 = X0;
  assign a34 = X8;
  assign a35 = X1;
  assign a36 = X9;
  assign a41 = X4;
  assign a42 = X12;
  assign a43 = X5;
  assign a44 = X13;
  assign a49 = X2;
  assign a50 = X10;
  assign a51 = X3;
  assign a52 = X11;
  assign a57 = X6;
  assign a58 = X14;
  assign a59 = X7;
  assign a60 = X15;
  assign Y0  = t217;
  assign Y1  = t218;
  assign Y8  = t219;
  assign Y9  = t220;
  assign Y4  = t221;
  assign Y5  = t222;
  assign Y12 = t223;
  assign Y13 = t224;
  assign Y2  = t233;
  assign Y3  = t234;
  assign Y10 = t235;
  assign Y11 = t236;
  assign Y6  = t237;
  assign Y7  = t238;
  assign Y14 = t239;
  assign Y15 = t240;

  addfxp #(32, 1) add69720 (
      .a  (a33),
      .b  (a34),
      .clk(clk),
      .q  (t209)
  );  // 0
  addfxp #(32, 1) add69735 (
      .a  (a35),
      .b  (a36),
      .clk(clk),
      .q  (t210)
  );  // 0
  subfxp #(32, 1) sub69750 (
      .a  (a33),
      .b  (a34),
      .clk(clk),
      .q  (t211)
  );  // 0
  subfxp #(32, 1) sub69765 (
      .a  (a35),
      .b  (a36),
      .clk(clk),
      .q  (t212)
  );  // 0
  addfxp #(32, 1) add69780 (
      .a  (a41),
      .b  (a42),
      .clk(clk),
      .q  (t213)
  );  // 0
  addfxp #(32, 1) add69795 (
      .a  (a43),
      .b  (a44),
      .clk(clk),
      .q  (t214)
  );  // 0
  subfxp #(32, 1) sub69810 (
      .a  (a41),
      .b  (a42),
      .clk(clk),
      .q  (t215)
  );  // 0
  subfxp #(32, 1) sub69825 (
      .a  (a43),
      .b  (a44),
      .clk(clk),
      .q  (t216)
  );  // 0
  addfxp #(32, 1) add69928 (
      .a  (a49),
      .b  (a50),
      .clk(clk),
      .q  (t225)
  );  // 0
  addfxp #(32, 1) add69943 (
      .a  (a51),
      .b  (a52),
      .clk(clk),
      .q  (t226)
  );  // 0
  subfxp #(32, 1) sub69958 (
      .a  (a49),
      .b  (a50),
      .clk(clk),
      .q  (t227)
  );  // 0
  subfxp #(32, 1) sub69973 (
      .a  (a51),
      .b  (a52),
      .clk(clk),
      .q  (t228)
  );  // 0
  addfxp #(32, 1) add69988 (
      .a  (a57),
      .b  (a58),
      .clk(clk),
      .q  (t229)
  );  // 0
  addfxp #(32, 1) add70003 (
      .a  (a59),
      .b  (a60),
      .clk(clk),
      .q  (t230)
  );  // 0
  subfxp #(32, 1) sub70018 (
      .a  (a57),
      .b  (a58),
      .clk(clk),
      .q  (t231)
  );  // 0
  subfxp #(32, 1) sub70033 (
      .a  (a59),
      .b  (a60),
      .clk(clk),
      .q  (t232)
  );  // 0
  addfxp #(32, 1) add69832 (
      .a  (t209),
      .b  (t213),
      .clk(clk),
      .q  (t217)
  );  // 1
  addfxp #(32, 1) add69839 (
      .a  (t210),
      .b  (t214),
      .clk(clk),
      .q  (t218)
  );  // 1
  subfxp #(32, 1) sub69846 (
      .a  (t209),
      .b  (t213),
      .clk(clk),
      .q  (t219)
  );  // 1
  subfxp #(32, 1) sub69853 (
      .a  (t210),
      .b  (t214),
      .clk(clk),
      .q  (t220)
  );  // 1
  addfxp #(32, 1) add69876 (
      .a  (t211),
      .b  (t216),
      .clk(clk),
      .q  (t221)
  );  // 1
  subfxp #(32, 1) sub69883 (
      .a  (t212),
      .b  (t215),
      .clk(clk),
      .q  (t222)
  );  // 1
  subfxp #(32, 1) sub69890 (
      .a  (t211),
      .b  (t216),
      .clk(clk),
      .q  (t223)
  );  // 1
  addfxp #(32, 1) add69897 (
      .a  (t212),
      .b  (t215),
      .clk(clk),
      .q  (t224)
  );  // 1
  addfxp #(32, 1) add70040 (
      .a  (t225),
      .b  (t229),
      .clk(clk),
      .q  (t233)
  );  // 1
  addfxp #(32, 1) add70047 (
      .a  (t226),
      .b  (t230),
      .clk(clk),
      .q  (t234)
  );  // 1
  subfxp #(32, 1) sub70054 (
      .a  (t225),
      .b  (t229),
      .clk(clk),
      .q  (t235)
  );  // 1
  subfxp #(32, 1) sub70061 (
      .a  (t226),
      .b  (t230),
      .clk(clk),
      .q  (t236)
  );  // 1
  addfxp #(32, 1) add70084 (
      .a  (t227),
      .b  (t232),
      .clk(clk),
      .q  (t237)
  );  // 1
  subfxp #(32, 1) sub70091 (
      .a  (t228),
      .b  (t231),
      .clk(clk),
      .q  (t238)
  );  // 1
  subfxp #(32, 1) sub70098 (
      .a  (t227),
      .b  (t232),
      .clk(clk),
      .q  (t239)
  );  // 1
  addfxp #(32, 1) add70105 (
      .a  (t228),
      .b  (t231),
      .clk(clk),
      .q  (t240)
  );  // 1


  always @(posedge clk) begin
    if (reset == 1) begin
    end else begin
      X0   <= X0_in;
      X1   <= X1_in;
      X2   <= X2_in;
      X3   <= X3_in;
      X4   <= X4_in;
      X5   <= X5_in;
      X6   <= X6_in;
      X7   <= X7_in;
      X8   <= X8_in;
      X9   <= X9_in;
      X10  <= X10_in;
      X11  <= X11_in;
      X12  <= X12_in;
      X13  <= X13_in;
      X14  <= X14_in;
      X15  <= X15_in;
      next <= next_in;
    end
  end
endmodule


module multfix (
    clk,
    rst,
    a,
    b,
    q_sc,
    q_unsc
);
  parameter WIDTH = 35, CYCLES = 6;

  input signed [WIDTH-1:0] a, b;
  output [WIDTH-1:0] q_sc;
  output [WIDTH-1:0] q_unsc;

  input clk, rst;

  reg signed  [2*WIDTH-1:0] q   [CYCLES-1:0];
  wire signed [2*WIDTH-1:0] res;
  integer                   i;

  assign res    = q[CYCLES-1];

  assign q_unsc = res[WIDTH-1:0];
  assign q_sc   = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};

  always @(posedge clk) begin
    q[0] <= a * b;
    for (i = 1; i < CYCLES; i = i + 1) begin
      q[i] <= q[i-1];
    end
  end

endmodule
module addfxp (
    a,
    b,
    q,
    clk
);

  parameter width = 16, cycles = 1;

  input signed [width-1:0] a, b;
  input clk;
  output signed [width-1:0] q;
  reg signed [width-1:0] res[cycles-1:0];

  assign q = res[cycles-1];

  integer i;

  always @(posedge clk) begin
    res[0] <= a + b;
    for (i = 1; i < cycles; i = i + 1) res[i] <= res[i-1];

  end

endmodule

module subfxp (
    a,
    b,
    q,
    clk
);

  parameter width = 16, cycles = 1;

  input signed [width-1:0] a, b;
  input clk;
  output signed [width-1:0] q;
  reg signed [width-1:0] res[cycles-1:0];

  assign q = res[cycles-1];

  integer i;

  always @(posedge clk) begin
    res[0] <= a - b;
    for (i = 1; i < cycles; i = i + 1) res[i] <= res[i-1];

  end

endmodule
