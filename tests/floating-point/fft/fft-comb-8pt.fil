import "primitives/reshape.fil";
import "primitives/float.fil";

// Combinational FFT using 32 bit floats and with 8 points.
comp FFT8<'G: 1>(
  in[16]: ['G, 'G+1] 32 // input with [real, imag] pairs
) -> (
  out[16]: ['G, 'G+1] 32 // output with [real, imag] pairs
) {
  // define the twiddle factors
  // generated using C at the moment to run the sine operations
  // stored in [real, imag] pairs
  bundle twiddle[16]: ['G, 'G+1] 32;
  TR0 := new SignedConst[32, 1065353216]<'G>();
  twiddle{0} = TR0.out;
  twiddle{1} = twiddle{4};

  TR1 := new SignedConst[32, 1060439283]<'G>();
  twiddle{2} = TR1.out;
  twiddle{3} = twiddle{6};

  TR2 := new SignedConst[32, 613232946]<'G>();
  twiddle{4} = TR2.out;
  twiddle{5} = twiddle{8};

  TR3 := new SignedConst[32, 3207922931]<'G>();
  twiddle{6} = TR3.out;
  twiddle{7} = twiddle{10};

  TR4 := new SignedConst[32, 3212836864]<'G>();
  twiddle{8} = TR4.out;
  twiddle{9} = twiddle{12};

  TR5 := new SignedConst[32, 3207922931]<'G>();
  twiddle{10} = TR5.out;
  twiddle{11} = twiddle{14};

  TR6 := new SignedConst[32, 2773731786]<'G>();
  twiddle{12} = TR6.out;
  twiddle{13} = twiddle{0};

  TR7 := new SignedConst[32, 1060439283]<'G>();
  twiddle{14} = TR7.out;
  twiddle{15} = twiddle{2};

  // Stage 0 input (bit reversal on pairs)
  bundle s0[16]: ['G, 'G+1] 32;
  s0{0..2} = in{0..2}; // 000 -> 000 (0 -> 0)
  s0{2..4} = in{8..10}; // 001 -> 100 (1 -> 4)
  s0{4..6} = in{4..6}; // 010 -> 010 (2 -> 2)
  s0{6..8} = in{12..14}; // 011 -> 110 (3 -> 6)
  s0{8..10} = in{2..4}; // 100 -> 001 (4 -> 1)
  s0{10..12} = in{10..12}; // 101 -> 101 (5 -> 5)
  s0{12..14} = in{6..8}; // 110 -> 011 (6 -> 3)
  s0{14..16} = in{14..16}; // 111 -> 111 (7 -> 7)

  // now do the butterfly operations
  // STAGE 1 butterfly ops (twiddles are all 1)
  // stored in pairs of real and imaginary
  bundle s1[16]: ['G, 'G+1] 32;

  // first butterfly
  B10 := new Butterfly8<'G>(s0{0..2}, s0{2..4}, twiddle{0..2});
  B11 := new Butterfly8<'G>(s0{4..6}, s0{6..8}, twiddle{0..2});
  B12 := new Butterfly8<'G>(s0{8..10}, s0{10..12}, twiddle{0..2});
  B13 := new Butterfly8<'G>(s0{12..14}, s0{14..16}, twiddle{0..2});

  s1{0..2} = B10.out0{0..2};
  s1{2..4} = B10.out1{0..2};
  s1{4..6} = B11.out0{0..2};
  s1{6..8} = B11.out1{0..2};
  s1{8..10} = B12.out0{0..2};
  s1{10..12} = B12.out1{0..2};
  s1{12..14} = B13.out0{0..2};
  s1{14..16} = B13.out1{0..2};

  // STAGE 2 butterfly ops (1, w^2)
  bundle s2[16]: ['G, 'G+1] 32;

  B20 := new Butterfly8<'G>(s1{0..2}, s1{4..6}, twiddle{0..2});
  B21 := new Butterfly8<'G>(s1{2..4}, s1{6..8}, twiddle{4..6});
  B22 := new Butterfly8<'G>(s1{8..10}, s1{12..14}, twiddle{0..2});
  B23 := new Butterfly8<'G>(s1{10..12}, s1{14..16}, twiddle{4..6});

  s2{0..2} = B20.out0{0..2};
  s2{2..4} = B21.out0{0..2};
  s2{4..6} = B20.out1{0..2};
  s2{6..8} = B21.out1{0..2};
  s2{8..10} = B22.out0{0..2};
  s2{10..12} = B23.out0{0..2};
  s2{12..14} = B22.out1{0..2};
  s2{14..16} = B23.out1{0..2};

  // STAGE 3 butterfly ops (1, w, w^2, w^3)
  bundle s3[16]: ['G, 'G+1] 32;

  B30 := new Butterfly8<'G>(s2{0..2}, s2{8..10}, twiddle{0..2});
  B31 := new Butterfly8<'G>(s2{2..4}, s2{10..12}, twiddle{2..4});
  B32 := new Butterfly8<'G>(s2{4..6}, s2{12..14}, twiddle{4..6});
  B33 := new Butterfly8<'G>(s2{6..8}, s2{14..16}, twiddle{6..8});

  s3{0..2} = B30.out0{0..2};
  s3{2..4} = B31.out0{0..2};
  s3{4..6} = B32.out0{0..2};
  s3{6..8} = B33.out0{0..2};
  s3{8..10} = B30.out1{0..2};
  s3{10..12} = B31.out1{0..2};
  s3{12..14} = B32.out1{0..2};
  s3{14..16} = B33.out1{0..2};

  out{0..16} = s3{0..16};  
}

// Combinational butterfly using 32 bit floats and with 8 points.
comp Butterfly8<'G: 1>(
  in0[2]: ['G, 'G+1] 32, // real and imaginary parts of input
  in1[2]: ['G, 'G+1] 32,
  twiddle[2]: ['G, 'G+1] 32 // twiddle factor
) -> (
  out0[2]: ['G, 'G+1] 32,
  out1[2]: ['G, 'G+1] 32
) {
  t1 := new ComplexMult8<'G>(in1{0..2}, twiddle{0..2});
  O0 := new ComplexAdd8<'G>(in0{0..2}, t1.out{0..2});
  out0{0..2} = O0.out{0..2};
  
  // multiply by twiddle
  O1 := new ComplexSub8<'G>(in0{0..2}, t1.out{0..2});
  out1{0..2} = O1.out{0..2};
}

comp ComplexMult8<'G: 1>(
  left[2]: ['G, 'G+1] 32, // a + bi
  right[2]: ['G, 'G+1] 32 // c + di
) -> (
  out[2]: ['G, 'G+1] 32
) {
  let W = 32;
  let E = 8;
  let M = 23;

  // fully combinational
  ac := new FMult[W, E, M]<'G>(left{0}, right{0}); // ac
  bd := new FMult[W, E, M]<'G>(left{1}, right{1}); // bd
  re := new FSub[W, E, M]<'G>(ac.out, bd.out); // ac - bd

  ad := new FMult[W, E, M]<'G>(left{0}, right{1}); // ad
  bc := new FMult[W, E, M]<'G>(left{1}, right{0}); // bc
  im := new FAdd[W, E, M]<'G>(ad.out, bc.out); // ad + bc

  out{0} = re.out;
  out{1} = im.out;
}

comp ComplexAdd8<'G: 1>(
  left[2]: ['G, 'G+1] 32, // a + bi
  right[2]: ['G, 'G+1] 32 // c + di
) -> (
  out[2]: ['G, 'G+1] 32
) {
  let W = 32;
  let E = 8;
  let M = 23;

  // fully combinational
  re := new FAdd[W, E, M]<'G>(left{0}, right{0}); // a + c
  im := new FAdd[W, E, M]<'G>(left{1}, right{1}); // b + d

  out{0} = re.out;
  out{1} = im.out;
}

// negation of a complex number
comp ComplexNeg8<'G: 1>(
  in[2]: ['G, 'G+1] 32 // a + bi
) -> (
  out[2]: ['G, 'G+1] 32
) {

  let W = 32;
  let E = 8;
  let M = 23;

  neg1 := new FNeg[W, E, M]<'G>(in{0}); // -a
  neg2 := new FNeg[W, E, M]<'G>(in{1}); // -b

  out{0} = neg1.out;
  out{1} = neg2.out;
}

// subtraction of complex numbers
comp ComplexSub8<'G: 1>(
  left[2]: ['G, 'G+1] 32,
  right[2]: ['G, 'G+1] 32
) -> (
  out[2]: ['G, 'G+1] 32
) {
  neg := new ComplexNeg8<'G>(right{0..2});
  add := new ComplexAdd8<'G>(left{0..2}, neg.out{0..2});
  out{0..2} = add.out{0..2};
}