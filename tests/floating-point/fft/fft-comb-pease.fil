import "primitives/signed.fil";
import "primitives/math/complex.fil";

/// Implements a combinational PEASE fft dataflow.
comp CombPeaseFFT[NStages, W, E, ?M=W-E-1]<'G: 1>(
  in[NPoints*2]: ['G, 'G+1] W
) -> (
  out[NPoints*2]: ['G, 'G+1] W
) with {
  let NPoints = pow2(NStages);
} where
  NStages > 0,
  W == E + M + 1,
  E > 1,
  M > 1
{
  // generate twiddle factors
  bundle twiddle[NPoints*2]: ['G, 'G+1] W;
  for i in 0..NPoints {
    cosbits := new SignedConst[W, cos_bits(i, NPoints)]<'G>();
    sinbits := new SignedConst[W, sin_bits(i+pow2(NStages-1), NPoints)]<'G>(); // equivalent to -sin
    twiddle{i*2} = cosbits.out;
    twiddle{i*2+1} = sinbits.out;
  }

  // NPoints*2 * (Nstages+1) bus storing the inputs and outputs for every stage
  bundle data[NPoints*2 * (NStages+1)]: ['G, 'G+1] W;
  // bit reverse the input
  for j in 0..NPoints {
    let br = bit_rev(j, NStages);
    assume br < NPoints;
    data{j*2..j*2+2} = in{br*2..br*2+2};
  }

  // perform the fft
  for stage in 0..NStages {
    bundle stage_twiddle[NPoints*2]: ['G, 'G+1] W;
    // calculate the twiddle factors.
    // Uses the fact that the twiddle factors can be generated recursively
    for twiddle_i in 0..pow2(NStages-stage) {
      for twiddle_j in 0..pow2(stage) {
        let stage_twiddle_index = twiddle_i+twiddle_j;
        let twiddle_index = twiddle_j * pow2(NStages-stage);
        assume stage_twiddle_index < NPoints;
        assume twiddle_index < NPoints;
        stage_twiddle{stage_twiddle_index*2..stage_twiddle_index*2+2} = twiddle{twiddle_index*2..twiddle_index*2+2};
      }
    }

    let data_offset = NPoints * stage * 2;

    // temporary data storage before stride permutation
    bundle tmp_data[NPoints*2]: ['G, 'G+1] W;

    // perform the butterflies
    for butterfly_i in 0..pow2(NStages-1) {
      butterfly := new Butterfly[W, E, M]<'G>(
        data{data_offset+butterfly_i*2..data_offset+butterfly_i*2+2},
        stage_twiddle{butterfly_i*2..butterfly_i*2+2}
      );

      tmp_data{butterfly_i*2..butterfly_i*2+2} = butterfly.out0{0..2};
      tmp_data{butterfly_i*2+2..butterfly_i*2+4} = butterfly.out1{0..2};
    }

    // perform the stride permutation
    stride_perm := new StridePermutation[NPoints, W]<'G>(tmp_data);
    // set the next stage's data
    data_offset{data_offset+NPoints*2..data_offset+NPoints*4} = stride_perm.out{0..NPoints*2};
  }

  out = data{NPoints*NStages*2..NPoints*NStages*2+NPoints*2};
}

// Creates the twiddle factors for an `NPoints` point FFT given a larger fft.
comp TwiddleStage[NStages, W]<'G: 1>(
  twiddle[NPoints]: ['G, 'G+1] W
) -> (
  out[NPoints*2]: ['G, 'G+1] W
) with {
  let NPoints = pow2(NStages);
} where
  NStages > 0,
  N < NStages
{

}

/// Performs an `NPoints` point stride permutation.
comp StridePermutation[NPoints, W]<'G: 1>(
  in[NPoints*2]: ['G, 'G+1] W
) -> (
  out[NPoints*2]: ['G, 'G+1] W
) where
  NPoints > 0,
  W > 0
{
  // Described on page 33 of https://link.springer.com/chapter/10.1007/978-1-4757-2767-8_2.

  for i in 0..NPoints {
    out{i} = in{i*2};
    out{i+NPoints} = in{i*2+1};
  }
}