import "primitives/comb.fil";
import "primitives/float.fil";

// Parametrized combinational fft
comp FFTComb[NPoints, W, E, ?M=W-E-1]<'G: 1>(
  in[2*NPoints]: ['G, 'G+1] W // input with [real, imag] pairs
) -> (
  out[2*NPoints]: ['G, 'G+1] W // output with [real, imag] pairs
) where
  E > 1,
  M > 1,
  W == E + M + 1
{
  // define the twiddle factors
  // generated using C at the moment to run the sine operations
  // stored in [real, imag] pairs
  bundle twiddle[16]: ['G, 'G+1] 32;
  TR0 := new Const[32, 1065353216]<'G>();
  twiddle{0} = TR0.out;
  twiddle{1} = twiddle{12};

  TR1 := new Const[32, 1060439283]<'G>();
  twiddle{2} = TR1.out;
  twiddle{3} = twiddle{14};

  TR2 := new Const[32, 613232946]<'G>();
  twiddle{4} = TR2.out;
  twiddle{5} = twiddle{0};

  TR3 := new NegConst[32, 1087044365]<'G>();
  twiddle{6} = TR3.out;
  twiddle{7} = twiddle{2};

  TR4 := new NegConst[32, 1082130432]<'G>();
  twiddle{8} = TR4.out;
  twiddle{9} = twiddle{4};

  TR5 := new NegConst[32, 1087044365]<'G>();
  twiddle{10} = TR5.out;
  twiddle{11} = twiddle{6};

  TR6 := new NegConst[32, 1521235510]<'G>();
  twiddle{12} = TR6.out;
  twiddle{13} = twiddle{8};

  TR7 := new Const[32, 1060439283]<'G>();
  twiddle{14} = TR7.out;
  twiddle{15} = twiddle{10};

  zero := new Const[32, 0]<'G>();

  // Stage 0 input (bit reversal on pairs)
  bundle s0[16]: ['G, 'G+1] 32;
  s0{0} = in{0}; // 000 -> 000
  s0{1} = in{1}; 
  s0{2} = in{8}; // 001 -> 100
  s0{3} = in{9};
  s0{4} = in{4}; // 010 -> 010
  s0{5} = in{5};
  s0{6} = in{12}; // 011 -> 110
  s0{7} = in{13};
  s0{8} = in{2}; // 100 -> 001
  s0{9} = in{3};
  s0{10} = in{10}; // 101 -> 101
  s0{11} = in{11};
  s0{12} = in{6}; // 110 -> 011
  s0{13} = in{7};
  s0{14} = in{14}; // 111 -> 111
  s0{15} = in{15};

  // now do the butterfly operations
  // STAGE 1 butterfly ops
  // stored in pairs of real and imaginary
  bundle s1[16]: ['G, 'G+1] 32;

  // first butterfly
  B10 := new Butterfly8<'G>(s0{0..2}, s0{2..4}, twiddle{0..2});
  B11 := new Butterfly8<'G>(s0{4..6}, s0{6..8}, twiddle{0..2});
  B12 := new Butterfly8<'G>(s0{8..10}, s0{10..12}, twiddle{0..2});
  B13 := new Butterfly8<'G>(s0{12..14}, s0{14..16}, twiddle{0..2});

  s1{0..2} = B10.out0{0..2};
  s1{2..4} = B10.out1{0..2};
  s1{4..6} = B11.out0{0..2};
  s1{6..8} = B11.out1{0..2};
  s1{8..10} = B12.out0{0..2};
  s1{10..12} = B12.out1{0..2};
  s1{12..14} = B13.out0{0..2};
  s1{14..16} = B13.out1{0..2};

  // STAGE 2 butterfly ops
  bundle s2[16]: ['G, 'G+1] 32;

  B20 := new Butterfly8<'G>(s1{0..2}, s1{4..6}, twiddle{0..2});
  B21 := new Butterfly8<'G>(s1{2..4}, s1{6..8}, twiddle{4..6});
  B22 := new Butterfly8<'G>(s1{8..10}, s1{12..14}, twiddle{0..2});
  B23 := new Butterfly8<'G>(s1{10..12}, s1{14..16}, twiddle{4..6});

  s2{0..2} = B20.out0{0..2};
  s2{2..4} = B21.out0{0..2};
  s2{4..6} = B20.out1{0..2};
  s2{6..8} = B21.out1{0..2};
  s2{8..10} = B22.out0{0..2};
  s2{10..12} = B23.out0{0..2};
  s2{12..14} = B22.out1{0..2};
  s2{14..16} = B23.out1{0..2};

  // STAGE 3 butterfly ops
  bundle s3[16]: ['G, 'G+1] 32;

  B30 := new Butterfly8<'G>(s2{0..2}, s2{8..10}, twiddle{0..2});
  B31 := new Butterfly8<'G>(s2{2..4}, s2{10..12}, twiddle{2..4});
  B32 := new Butterfly8<'G>(s2{4..6}, s2{12..14}, twiddle{4..6});
  B33 := new Butterfly8<'G>(s2{6..8}, s2{14..16}, twiddle{6..8});

  s3{0..2} = B30.out0{0..2};
  s3{2..4} = B31.out0{0..2};
  s3{4..6} = B32.out0{0..2};
  s3{6..8} = B33.out0{0..2};
  s3{8..10} = B30.out1{0..2};
  s3{10..12} = B31.out1{0..2};
  s3{12..14} = B32.out1{0..2};
  s3{14..16} = B33.out1{0..2};

  out{0..16} = s3{0..16};  
}

// Combinational butterfly using 32 bit floats and with 8 points.
comp Butterfly8<'G: 1>(
  in0[2]: ['G, 'G+1] 32, // real and imaginary parts of input
  in1[2]: ['G, 'G+1] 32,
  twiddle[2]: ['G, 'G+1] 32 // twiddle factor
) -> (
  out0[2]: ['G, 'G+1] 32,
  out1[2]: ['G, 'G+1] 32
) {
  O0 := new ComplexAdd<'G>(in0{0..2}, in1{0..2});
  out0{0..2} = O0.out{0..2};
  
  // multiply by twiddle
  Twid := new ComplexMult<'G>(in1{0..2}, twiddle{0..2});
  O1 := new ComplexAdd<'G>(in0{0..2}, Twid.out{0..2});
  out1{0..2} = O1.out{0..2};
}

comp ComplexMult<'G: 1>(
  left[2]: ['G, 'G+1] 32,
  right[2]: ['G, 'G+1] 32
) -> (
  out[2]: ['G, 'G+1] 32
) {
  let W = 32;
  let E = 8;
  let M = 23;
  assume W == 32;
  assume E == 8;
  assume M == 23;

  // fully combinational
  ac := new FMult[W, E, M]<'G>(left{0}, right{0});
  bd := new FMult[W, E, M]<'G>(left{1}, right{1});
  bdn := new FNeg[W, E, M]<'G>(bd.out);
  re := new FAdd[W, E, M]<'G>(ac.out, bdn.out);

  ad := new FMult[W, E, M]<'G>(left{0}, right{1});
  bc := new FMult[W, E, M]<'G>(left{1}, right{0});
  im := new FAdd[W, E, M]<'G>(ad.out, bc.out);

  out{0} = re.out;
  out{1} = im.out;
}

comp ComplexAdd<'G: 1>(
  left[2]: ['G, 'G+1] 32,
  right[2]: ['G, 'G+1] 32
) -> (
  out[2]: ['G, 'G+1] 32
) {
  let W = 32;
  let E = 8;
  let M = 23;
  assume W == 32;
  assume E == 8;
  assume M == 23;

  // fully combinational
  re := new FAdd[W, E, M]<'G>(left{0}, right{0});
  im := new FAdd[W, E, M]<'G>(left{1}, right{1});

  out{0} = re.out;
  out{1} = im.out;
}