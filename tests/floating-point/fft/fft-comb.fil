import "primitives/signed.fil";
import "primitives/math/complex.fil";

/// Toplevel FFT Module
comp CombFFT[NStages, W, E, ?M=W-E-1]<'G: 1>(
  in[NPoints*2]: ['G, 'G+1] W,
) -> (
  out[NPoints*2]: ['G, 'G+1] W
) with {
  let NPoints = pow2(NStages);
} where
  NStages > 0,
  W == E + M + 1,
  E > 1,
  M > 1
{
  // generate twiddle factors
  bundle twiddle[NPoints*2]: ['G, 'G+1] W;
  for i in 0..pow2(NStages) {
    cosbits := new SignedConst[W, cos_bits(i, NPoints)]<'G>();
    sinbits := new SignedConst[W, sin_bits(i+pow2(NStages-1), NPoints)]<'G>(); // equivalent to -sin
    twiddle{i*2} = cosbits.out;
    twiddle{i*2+1} = sinbits.out;
  }

  // bit reverse the input
  bundle bitrev[NPoints*2]: ['G, 'G+1] W;
  for j in 0..NPoints {
    let br = bit_rev(j, NStages);
    assume br < NPoints;
    bitrev{j*2..j*2+2} = in{br*2..br*2+2};
  }

  // run the inner fft
  fft := new _FFT_Inner[NStages, W, E, M]<'G>(bitrev{0..NPoints*2}, twiddle{0..NPoints*2});

  out{0..NPoints*2} = fft.out{0..NPoints*2};
}

/// Inner FFT module that takes twiddle factors as input
/// Assumes that input is already bit reversed here.
comp _FFT_Inner[NStages, W, E, ?M=W-E-1]<'G: 1>(
  in[NPoints*2]: ['G, 'G+1] W,
  twiddle[NPoints*2]: ['G, 'G+1] W,
) -> (
  out[NPoints*2]: ['G, 'G+1] W
) with {
  let NPoints = pow2(NStages);
} where
  NStages >= 0,
  W == E + M + 1,
  E > 1,
  M > 1
{
  assume pow2(NStages-1)*2 == pow2(NStages);
  assume pow2(NStages)*2 == pow2(NStages+1);
  if NStages == 0 {
    // No stages here, this is the identity.
    out{0..2} = in{0..2};
  } else {
    // twiddle factors for the smaller fft
    bundle inner_twiddle[NPoints]: ['G, 'G+1] W;
    // hook up every other fft to this fft.
    for t in 0..pow2(NStages-1) {
      inner_twiddle{t*2} = twiddle{t*4};
      inner_twiddle{t*2+1} = twiddle{t*4+1};
    } 
    // Run the two smaller FFTs
    // This does the first `N-1` Stages of the FFT for us.
    fft1 := new _FFT_Inner[NStages-1, W, E, M]<'G>(in{0..NPoints}, inner_twiddle{0..NPoints});
    fft2 := new _FFT_Inner[NStages-1, W, E, M]<'G>(in{NPoints..NPoints*2}, inner_twiddle{0..NPoints});

    // Combine the two FFTs in the last stage
    for i in 0..pow2(NStages-1) {
      butterfly := new Butterfly[W, E, M]<'G>(fft1.out{i*2..i*2+2}, fft2.out{i*2..i*2+2}, twiddle{2*i..2*i+2});
      out{i*2..i*2+2} = butterfly.out0{0..2};
      out{i*2+NPoints..i*2+NPoints+2} = butterfly.out1{0..2};
    }
  }
}