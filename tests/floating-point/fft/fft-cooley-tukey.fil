import "primitives/float.fil";
import "primitives/reshape.fil";

// W: Bitwidth of the input and output
// NStages: number of stages in the FFT (log2 of the number of points)
// StageLatency: number of cycles to take for one stage
// StreamingCount: number of floats input per cycle (must be such that NPoints/StreamingCount < StageLatency)
// W, Exponent, Mantissa: parameters for the floating point type to use.
// MultiplierNum: number of multipliers per stage (sets to the minimum required to fit within StageLatency/2)
comp FFT[
    NStages,
    StreamingCount,
    MultiplierNum,
    W=32,
    Exponent=8,
    ?Mantissa=W-Exponent-1,
]<'G: StageLatency> (
    @interface['G] go: 1,
    @['G, 'G+1] in: StreamingCount*W,
) -> (
    @['G+StageLatency, 'G+StageLatency+1] out: StreamingCount*W,
)
where
    NStages > 0,
    StreamingCount > 0,
    MultiplierNum > 0,
    W > 0,
    Exponent > 0,
    Mantissa > 0,
    Exponent + Mantissa + 1 == W
with
    NPoints=pow2(NStages),
    StreamingW=StreamingCount*W,
    StreamingCount=NPoints/StreamingCount,
    StageLatency=MultiplierNum*2,
{
}

comp _FFT_Stage[
    Stage,
    NStages,
    StreamingCount,
    MultiplierNum,
    W=32,
    Exponent=8,
    ?Mantissa=W-Exponent-1,
]<G: NPoints/MultiplierNum> (
    @interface['G] go: 1,
    @['G, 'G+1] in: StreamingCount*W,
) -> (
    @['G+StageLatency, 'G+StageLatency+1] out: StreamingCount*W,
)
where 
    Stage >= 0,
    Stage < NStages,
    NStages > 0,
    StreamingCount > 0,
    MultiplierNum > 0,
    W > 0,
    Exponent > 0,
    Mantissa > 0,
    Exponent + Mantissa + 1 == W
with
    NPoints=pow2(NStages),
    StreamingW=StreamingCount*W,
    StreamingCount=NPoints/StreamingCount,
    StageLatency=MultiplierNum*2,
{
}

// Performs complex multiplication
// Takes: two complex numbers, each represented as two floats (real and imaginary)
comp ComplexMult[Latency, W, Exponent, ?Mantissa=W-Exponent-1]<G: Latency> (
    interface['G] go: 1,
    left[2]: ['G, 'G+1] W,
    right[2]: ['G, 'G+1] W,
) -> (
    out[2]: ['G, 'G+1] W,
) where
    Latency >= 0, // latency must be 0 or 3 depending on whether we share the multiplier
    Latency <= 3,
    Latency != 1,
    W > 0,
    Exponent > 0,
    Mantissa > 0,
{
    // performs the multiplication
    // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
    if Latency == 0 {
        // fully combinational
        ac := new FMult[W, Exponent, Mantissa]<G>(left{0}, right{0});
        bd := new FMult[W, Exponent, Mantissa]<G>(left{1}, right{1});
        bdn := new FNeg[W, Exponent, Mantissa]<G>(bd.out);
        re := new FAdd[W, Exponent, Mantissa]<G>(ac.out, bdn.out);

        ad := new FMult[W, Exponent, Mantissa]<G>(left{0}, right{1});
        bc := new FMult[W, Exponent, Mantissa]<G>(left{1}, right{0});
        im := new FAdd[W, Exponent, Mantissa]<G>(ad.out, bc.out);

        out{0} = re.out;
        out{1} = im.out;
    } else if Latency == 1 {
        M1 := new FMult[W, Exponent, Mantissa];
        M2 := new FMult[W, Exponent, Mantissa];
        A1 := new FAdd[W, Exponent, Mantissa];
        // fully combinational
        ac := M1<G>(left{0}, right{0});
        bd := M2<G>(left{1}, right{1});
        bdn := new FNeg[W, Exponent, Mantissa]<G>(bd.out);
        re := A1<G>(ac.out, bdn.out);

        ad := M1<G+1>(left{0}, right{1});
        bc := M2<G+1>(left{1}, right{0});
        im := A1<G+1>(ad.out, bc.out);

        out{0} = re.out;
        out{1} = im.out;
    } else {
        // TODO
        out{0..1} = left{0..1};
    }
}

