import "primitives/signed.fil";
import "helpers.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";

/// Implements a combinational PEASE fft dataflow.
/// Uses `N` butterflies
comp PeaseFFT[NStages, N]<'G: L>(
  go: interface['G],
  in[NPoints][2]: ['G, 'G+1] W
) -> (
  out[NPoints][2]: ['G+L, 'G+L+1] W
) with {
  let NPoints = pow2(NStages);
  some L where L > 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} where
  // number of butterflies (N) must divide the total number of butterflies per stage (NPoints/2)
  NPoints % (2*N) == 0,
  N > 0,
  N * 2 <= NPoints,
  NStages > 0
{
  // cvc5 stalls trying to prove this...
  assume NPoints % 2 == 0;

  assume pow2(NStages-1) == NPoints/2;
  assume pow2(NStages+1) == NPoints*2;
  assume pow2(NStages+2) == NPoints*4;

  bitrev := new BitRev[NStages, W]<'G>(in{0..NPoints}{0..2});
  // butterfly components
  B := new Butterflies[N, W, E, M];
  // number of times we have to reuse the butterflies per stage
  let reuses = NPoints / (2*N);
  assume reuses * 2 * N == NPoints;
  let stage_latency = B::L * reuses + 1; // + 1 here is for the extra delay cycle necessary to transfer values between stages
  let latency = stage_latency * NStages;
  
  // twiddle factor that stays alive for the whole computation
  twiddle := new TwiddleFactor[NPoints, latency]<'G>();

  // contains all the twiddle stage data as an allways-alive constant matrix
  bundle twiddle_in[NStages][NPoints/2][2]: ['G, 'G + latency] W;

  for twiddle_i in 0..NStages {
    twiddle_stage := new TwiddleStage[NStages, twiddle_i, W, latency]<'G>(twiddle.out{0..NPoints/2}{0..2});
    twiddle_in{twiddle_i}{0..NPoints/2}{0..2} = twiddle_stage.out{0..NPoints/2}{0..2};
  }

  // Synchronized data (happens between each stage, inputs and outputs to stride permutation)
  // Separated by the input and output to and from the registers.
  // There are Nstages of these (one for input and one for output for each stage)
  bundle sync_data_in[NStages+1][NPoints][2]: for<sdii, _sdi, __sdi> ['G + sdii*stage_latency, 'G + sdii*stage_latency + 1] W;
  bundle sync_data_out[NStages][NPoints][2]:  for<sdoi, _sdo, __sdo> ['G + (sdoi+1) * stage_latency - 1, 'G + (sdoi+1) * stage_latency] W;

  // Unsynchronized data (happens within each stage, input to and ouptut from the butterfly calculations)
  // There are `reuses` blocks within each stage, each separated by `B::L`.
  // `i % (NPoints*2)` is the progress within the stage, and there are `4*N` inputs per butterfly chunk
  // Each butterfly takes B::L cycles to complete
  // no bundles for this as they can be stored temprorarily in registers


  // Dataflow for one register looks like this:
  // Synchronized in -> hold till butterfly -> unsync in -> butterfly -> unsync out -> hold till sync -> sync out -> stride permutation -> sync in

  // hook up inputs
  sync_data_in{0}{0..NPoints}{0..2} = bitrev.out{0..NPoints}{0..2};
  

  /// ------------ hook up registers and butterfly components. ------------
  if reuses == 1 {
    // Whole stage done at once, no registers necessary
    for r_stage in 0..NStages {
      let sync_in_t = r_stage * stage_latency; // start stage here
      let sync_out_t = (r_stage + 1) * stage_latency; // end stage here

      let usync_in_t = sync_in_t; // start butterfly here
      let usync_out_t = sync_in_t + B::L; // end butterfly here
      
      // simple order assumptions
      assume usync_in_t == sync_in_t;
      assume usync_out_t > usync_in_t;
      assume sync_out_t == usync_out_t;
      
      assume 2 * N == NPoints;
    
      // don't need the registers at all
      b := B<'G + usync_in_t>(sync_data_in{r_stage}{0..2*N}{0..2}, twiddle_in{r_stage}{0..NPoints/2}{0..2});
      sync_data_out{r_stage}{0..2*N}{0..2} = b.out{0..2*N}{0..2};
    }
  } else {
    // for every reuse of a butterfly
    for reg_i in 0..reuses {
      // one big register storing all the inputs and outputs of one butterfly chunk
      R := new PassThroughRegister[W * 4 * N];

      for r_stage in 0..NStages {
        let sync_in_t = r_stage * stage_latency; // start stage here
        let sync_out_t = (r_stage + 1) * stage_latency; // end stage here

        let usync_in_t = sync_in_t + reg_i * B::L; // start butterfly here
        let usync_out_t = sync_in_t + (reg_i + 1) * B::L; // end butterfly here

        let start = reg_i*2*N;
        let end = (reg_i+1)*2*N;

        // sync in -> unsync in
        c1 := new CombineButterflyBundle[N, W]<'G + sync_in_t>(sync_data_in{r_stage}{start..end}{0..2});
        r1 := R<'G + sync_in_t, 'G + usync_out_t>(c1.out);
        s1 := new SplitButterflyBundle[N, W, usync_out_t-usync_in_t]<'G + usync_in_t>(r1.out);
        // unsync in -> butterfly
        b := B<'G + usync_in_t>(s1.out{0..2*N}{0..2}, twiddle_in{r_stage}{reg_i*N..(reg_i+1)*N}{0..2});
        // unsync out -> sync out
        c2 := new CombineButterflyBundle[N, W]<'G + usync_out_t>(b.out{0..2*N}{0..2});
        r2 := R<'G + usync_out_t, 'G + sync_out_t>(c2.out);
        s2 := new SplitButterflyBundle[N, W]<'G + sync_out_t-1>(r2.out);

        // store sync out
        sync_data_out{r_stage}{start..end}{0..2} = s2.out{0..2*N}{0..2};
      } 
    }
  }

  // --------------- STRIDE PERMUTATIONS ----------------

  SP := new StridePermutation[NStages, W];
  
  // A delay is necessary for between stages so the pass-through register
  // isn't used twice at the same time
  D := new Delay[W*NPoints*2];


  // hook up stride permutations
  for stage in 0..NStages {
    let sync_out_t = (stage + 1) * stage_latency - 1;
    stride := SP<'G + sync_out_t>(sync_data_out{stage}{0..NPoints}{0..2});

    // delay between stages
    c1 := new CombineButterflyBundle[NPoints/2, W]<'G + sync_out_t>(stride.out{0..NPoints}{0..2});
    d1 := D<'G + sync_out_t>(c1.out);
    s1 := new SplitButterflyBundle[NPoints/2, W]<'G + sync_out_t + 1>(d1.out);

    sync_data_in{stage+1}{0..NPoints}{0..2} = s1.out{0..NPoints}{0..2};
  }

  out{0..NPoints}{0..2} = sync_data_in{NStages}{0..NPoints}{0..2};
  L := latency;
}

/// Computes N butterflies at once.
comp Butterflies[N, W, E, ?M=W-E-1]<'G: L>(
  in[N*2][2]: ['G, 'G+1] W, // Each butterfly takes 2 complex numbers
  twiddle[N][2]: ['G, 'G+1] W // twiddle factor for each butterfly
) -> (
  out[N*2][2]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
} where
    N > 0,
    W == E + M + 1,
    E > 1,
    M > 1
{
  Bx := new Butterfly[W, E, M];
  L := Bx::L;

  for i in 0..N {
    b := new Butterfly[W, E, M]<'G>(in{2*i}{0..2}, in{2*i+1}{0..2}, twiddle{i}{0..2});
    out{2*i}{0..2} = b.out0{0..2};
    out{2*i+1}{0..2} = b.out1{0..2};
  }
}

/// Combines output of the Butterflies component into a single wire
comp CombineButterflyBundle[N, W]<'G: 1>(
  in[N*2][2]: ['G, 'G+1] W
) -> (
  out: ['G, 'G+1] W*4*N
) where
    N > 0,
    W > 0
{
  bundle outb[N*4]: ['G, 'G+1] W;
  for i in 0..N*2 {
    outb{i*2} = in{i}{0};
    outb{i*2+1} = in{i}{1};
  }
  
  cb := new ConcatBundle[W, N*4]<'G>(outb{0..N*4});
  
  out = cb.out;
}

/// Splits output of the Butterflies component into a bundle
comp SplitButterflyBundle[N, W]<'G: 1>(
  in: ['G, 'G+1] W*4*N
) -> (
  out[N*2][2]: ['G, 'G+1] W
) where
    N > 0,
    W > 0
{
  sw := new SplitWire[W, N*4]<'G>(in);
  for i in 0..N*2 {
    out{i}{0} = sw.out{i*2};
    out{i}{1} = sw.out{i*2+1};
  }
}


/// Butterfly module using existential parameters.
comp Butterfly[W, E, ?M=W-E-1]<'G: L>(
  in0[2]: ['G, 'G+1] W, // real and imaginary parts of input
  in1[2]: ['G, 'G+1] W,
  twiddle[2]: ['G, 'G+1] W // twiddle factor
) -> (
  out0[2]: ['G+L, 'G+L+1] W,
  out1[2]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
} where
    W == E + M + 1,
    E > 1,
    M > 1
{
  // switches between the type of butterfly unit
  let T = 0;
  if T == 0 {
    // Fully combinational butterfly module
    // multiply by twiddle
    t1 := new ComplexMult[W, E, M]<'G>(in1{0..2}, twiddle{0..2});
    
    O0 := new ComplexAdd[W, E, M]<'G>(in0{0..2}, t1.out{0..2});
    O1 := new ComplexSub[W, E, M]<'G>(in0{0..2}, t1.out{0..2});

    // registers
    d00 := new Delay[W]<'G>(O0.out{0});
    d01 := new Delay[W]<'G>(O0.out{1});
    d10 := new Delay[W]<'G>(O1.out{0});
    d11 := new Delay[W]<'G>(O1.out{1});
    out0{0} = d00.out;
    out0{1} = d01.out;
    out1{0} = d10.out;
    out1{1} = d11.out;

    L := 1;
  }
  // else if T == 1 {
  //   // Partially iterative butterfly module

  //   FM1 := new FMult[W, E, M];
  //   FM2 := new FMult[W, E, M];

  //   FA := new FAdd[W, E, M];
  //   FS := new FSub[W, E, M];
    
  //   // Perform w * in1
  //   ac := FM<'G>(, right{0}); // ac
  //   bd := FM2<'G>(left{1}, right{1}); // bd
  //   re := FS<'G>(ac.out, bd.out); // ac - bd

  //   ad := FM<'G+1>(left{0}, right{1}); // ad
  //   bc := FM2<'G+1>(left{1}, right{0}); // bc
  //   im := new FAdd[W, E, M]<'G>(ad.out, bc.out); // ad + bc

  //   out{0} = re.out;
  //   out{1} = im.out;
  // }
}