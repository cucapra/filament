import "primitives/signed.fil";
import "helpers.fil";
import "primitives/state.fil";
import "primitives/reshape.fil";

/// Implements a combinational PEASE fft dataflow.
/// Uses `N` butterflies
comp PeaseFFT[NStages, N]<'G: L>(
  go: interface['G],
  in[NPoints*2]: ['G, 'G+1] W
) -> (
  out[NPoints*2]: ['G+L, 'G+L+1] W
) with {
  let NPoints = pow2(NStages);
  some L where L > 0;
  // Floating Point specification
  let W = 32;
  let E = 8;
  let M = 23;
} where
  // number of butterflies (N) must divide the total number of butterflies per stage (NPoints/2)
  NPoints % (2*N) == 0,
  N > 0,
  N * 2 <= NPoints,
  NStages > 0
{
  // cvc5 stalls trying to prove this...
  assume NPoints % 2 == 0;

  assume pow2(NStages+1) == NPoints*2;
  assume pow2(NStages+2) == NPoints*4;

  bitrev := new BitRev[NStages, W]<'G>(in{0..NPoints*2});
  // butterfly components
  B := new Butterflies[N, W, E, M];
  // number of times we have to reuse the butterflies per stage
  let reuses = NPoints / (2*N);
  assume reuses * 2 * N == NPoints;
  let stage_latency = B::L * reuses;
  let latency = stage_latency * NStages;
  L := latency;
  
  // twiddle factor that stays alive for the whole computation
  twiddle := new TwiddleFactor[NPoints, latency]<'G>();

  // contains all the twiddle stage data as an allways-alive constant matrix
  bundle twiddle_in[NStages*NPoints]: for<_> ['G, 'G + latency] W;

  for twiddle_i in 0..NStages {
    let start = twiddle_i * NPoints;
    let end = (twiddle_i + 1) * NPoints;
    twiddle_stage := new TwiddleStage[NStages, twiddle_i, W, latency]<'G>(twiddle.out{0..NPoints});
    twiddle_in{start..end} = twiddle_stage.out{0..NPoints};
  }

  // Synchronized data (happens between each stage, inputs and outputs to stride permutation)
  // Separated by the input and output to and from the registers.
  // There are Nstages of these (one for input and one for output for each stage)
  bundle sync_data_in[(NStages + 1) * NPoints * 2]: for<sdii> ['G + sdii/(NPoints*2) * stage_latency, 'G + sdii/(NPoints*2) * stage_latency + 1] W;
  bundle sync_data_out[NStages * NPoints * 2]:  for<sdoi> ['G + (sdoi/(NPoints*2)+1) * stage_latency, 'G + (sdoi/(NPoints*2)+1) * stage_latency + 1] W;

  // Unsynchronized data (happens within each stage, input to and ouptut from the butterfly calculations)
  // There are `reuses` blocks within each stage, each separated by `B::L`.
  // `i % (NPoints*2)` is the progress within the stage, and there are `4*N` inputs per butterfly chunk
  // Each butterfly takes B::L cycles to complete
  // no bundles for this as they can be stored temprorarily in registers


  // Dataflow for one register looks like this:
  // Synchronized in -> hold till butterfly -> unsync in -> butterfly -> unsync out -> hold till sync -> sync out -> stride permutation -> sync in

  // helper bundle concatenator and wire splitter
  CB := new ConcatBundle[W, 4*N];
  SW := new SplitWire[W, 4*N];

  // hook up inputs
  sync_data_in{0..NPoints*2} = bitrev.out{0..NPoints*2};
  

  /// ------------ hook up registers and butterfly components. ------------
  if reuses == 1 {
    // Whole stage done at once, no registers necessary
    for r_stage in 0..NStages {
      let sync_in_t = r_stage * stage_latency; // start stage here
      let sync_out_t = (r_stage + 1) * stage_latency; // end stage here

      let usync_in_t = sync_in_t; // start butterfly here
      let usync_out_t = sync_in_t + B::L; // end butterfly here
      
      // simple order assertions
      assert usync_in_t == sync_in_t;
      assert usync_out_t > usync_in_t;
      assert sync_out_t == usync_out_t;

      let start = r_stage * NPoints * 2; // start of data chunk
      let end = r_stage * NPoints * 2 + 4 * N; // end of data chunk
      
      assume 2 * N < NPoints;
      assume start / (NPoints * 2) == r_stage;
      assume end / (NPoints * 2) == r_stage + 1;

      let twiddle_start = r_stage * NPoints; // start of twiddle chunk
      let twiddle_end = r_stage * NPoints + 2 * N; // end of twiddle chunk
    
      // stage 0 doesn't need the first register invocation
      b := B<'G + usync_in_t>(sync_data_in{start..end}, twiddle_in{twiddle_start..twiddle_end});
      sync_data_out{start..end} = b.out{0..4*N};
    }
  } else {
    R0 := new Register[W * 4 * N];
    // first butterfly only needs a register after computation
    for r0_stage in 0..NStages {
        let sync_in_t = r0_stage * stage_latency; // start stage here
        let sync_out_t = (r0_stage + 1) * stage_latency; // end stage here

        let usync_in_t = sync_in_t; // start butterfly here
        let usync_out_t = sync_in_t + B::L; // end butterfly here
        
        // simple order assertions
        assert usync_in_t == sync_in_t;
        assert usync_out_t > usync_in_t;
        assert sync_out_t > usync_out_t;

        let start = r0_stage * NPoints * 2; // start of data chunk
        let end = r0_stage * NPoints * 2 + 4 * N; // end of data chunk
        
        assume 4 * N < 2 * NPoints;
        assume start / (NPoints * 2) == r0_stage;
        assume end / (NPoints * 2) == r0_stage;

        let twiddle_start = r0_stage * NPoints; // start of twiddle chunk
        let twiddle_end = r0_stage * NPoints + 2 * N; // end of twiddle chunk
      
        // stage 0 doesn't need the first register invocation
        b := B<'G + usync_in_t>(sync_data_in{start..end}, twiddle_in{twiddle_start..twiddle_end});
        // unsync out -> sync out
        c2 := CB<'G + usync_out_t>(b.out{0..4*N});
        r2 := R0<'G + usync_out_t, 'G + sync_out_t + 1>(c2.out);
        s2 := SW<'G + sync_out_t>(r2.out);

        // this significantly speeds up the final assertion, but slows down some of the above assertions
        assume start / (NPoints * 2) >= r0_stage;
        assume end / (NPoints * 2) <= r0_stage;
        
        // store sync out
        sync_data_out{start..end} = s2.out{0..4*N};
    }

    // middle butterflies
    for reg_i in 1..reuses-1 {
      // one big register storing all the inputs and outputs of one butterfly chunk
      R := new Register[W * 4 * N];

      for r_stage in 0..NStages {
        let sync_in_t = r_stage * stage_latency; // start stage here
        let sync_out_t = (r_stage + 1) * stage_latency; // end stage here

        let usync_in_t = sync_in_t + reg_i * B::L; // start butterfly here
        let usync_out_t = sync_in_t + (reg_i + 1) * B::L; // end butterfly here
        
        // simple order assertions
        assert usync_in_t > sync_in_t;
        assert usync_out_t > usync_in_t;
        assert sync_out_t > usync_out_t;

        let start = r_stage * NPoints * 2 + reg_i * 4 * N; // start of data chunk
        let end = r_stage * NPoints * 2 + (reg_i + 1) * 4 * N; // end of data chunk
        
        assume (reg_i+1)*2*N < NPoints;
        assume start / (NPoints * 2) == r_stage;
        assume end / (NPoints * 2) == r_stage;

        let twiddle_start = r_stage * NPoints + reg_i * 2 * N; // start of twiddle chunk
        let twiddle_end = r_stage * NPoints + (reg_i + 1) * 2 * N; // end of twiddle chunk

        // sync in -> unsync in
        c1 := CB<'G + sync_in_t>(sync_data_in{start..end});
        r1 := R<'G + sync_in_t, 'G + usync_in_t + 1>(c1.out);
        s1 := SW<'G + usync_in_t>(r1.out);
        // unsync in -> butterfly
        b := B<'G + usync_in_t>(s1.out{0..4*N}, twiddle_in{twiddle_start..twiddle_end});
        // unsync out -> sync out
        c2 := CB<'G + usync_out_t>(b.out{0..4*N});
        r2 := R<'G + usync_out_t, 'G + sync_out_t + 1>(c2.out);
        s2 := SW<'G + sync_out_t>(r2.out);


        // this significantly speeds up the final assertion, but slows down some of the above assertions
        assume start / (NPoints * 2) >= r_stage;
        assume end / (NPoints * 2) <= r_stage;

        // store sync out
        sync_data_out{start..end} = s2.out{0..4*N};
      } 
    }
    
    RF := new Register[W * 4 * N];
    // final butterfly only needs a register before computation
    for rf_stage in 0..NStages {
      let sync_in_t = rf_stage * stage_latency; // start stage here
      let sync_out_t = (rf_stage + 1) * stage_latency; // end stage here

      let usync_in_t = sync_in_t + (reuses - 1) * B::L; // start butterfly here
      let usync_out_t = sync_in_t + reuses * B::L; // end butterfly here
      
      // simple order assertions
      assert usync_in_t > sync_in_t;
      assert usync_out_t > usync_in_t;
      assert sync_out_t == usync_out_t;

      let start = rf_stage * NPoints * 2 + (reuses - 1) * 4 * N; // start of data chunk
      let end = rf_stage * NPoints * 2 + reuses * 4 * N; // end of data chunk
      
      assume reuses*2*N == NPoints;
      assume start / (NPoints * 2) == rf_stage;
      assume end / (NPoints * 2) == rf_stage + 1;

      let twiddle_start = rf_stage * NPoints + (reuses - 1) * 2 * N; // start of twiddle chunk
      let twiddle_end = rf_stage * NPoints + reuses * 2 * N; // end of twiddle chunk

      // sync in -> unsync in
      c1 := CB<'G + sync_in_t>(sync_data_in{start..end});
      r1 := RF<'G + sync_in_t, 'G + usync_in_t + 1>(c1.out);
      s1 := SW<'G + usync_in_t>(r1.out);
      // unsync in -> butterfly
      b := B<'G + usync_in_t>(s1.out{0..4*N}, twiddle_in{twiddle_start..twiddle_end});

      // this significantly speeds up the final assertion, but slows down some of the above assertions
      assume start / (NPoints * 2) >= rf_stage;
      assume end / (NPoints * 2) <= rf_stage + 1;

      // store sync out
      sync_data_out{start..end} = b.out{0..4*N};
    }
  }

  // --------------- STRIDE PERMUTATIONS ----------------

  SP := new StridePermutation[NStages, W];

  // hook up stride permutations
  for stage in 0..NStages {
    stride := SP<'G + (stage + 1) * stage_latency>(sync_data_out{stage * NPoints * 2..(stage + 1) * NPoints * 2});
    assume stage * NPoints * 2 / (NPoints * 2) + 1 == (stage + 1) * NPoints * 2 / (NPoints * 2);
    assume (stage + 2) * NPoints * 2 / (NPoints * 2) + 1 == (stage + 2) * NPoints * 2 / (NPoints * 2);

    sync_data_in{(stage + 1) * NPoints * 2..(stage + 2) * NPoints * 2} = stride.out{0..NPoints*2};
  }

  // hook up output
  assume (NStages * NPoints * 2) / (NPoints * 2) == NStages;
  assume ((NStages+1) * NPoints * 2 - 1) / (NPoints * 2) == NStages;
  out{0..NPoints*2} = sync_data_in{NStages * NPoints * 2..(NStages + 1) * NPoints * 2};
}

/// Computes N butterflies at once.
comp Butterflies[N, W, E, ?M=W-E-1]<'G: L>(
  in[4*N]: ['G, 'G+1] W, // Each butterfly takes a chunk of 4 inputs (2 complex numbers)
  twiddle[2*N]: ['G, 'G+1] W // twiddle factor for each butterfly
) -> (
  out[4*N]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
} where
    N > 0,
    W == E + M + 1,
    E > 1,
    M > 1
{
  if N == 1 {
    B := new Butterfly[W, E, M];
    b := B<'G>(in{0..2}, in{2..4}, twiddle{0..2});
    out{0..2} = b.out0{0..2};
    out{2..4} = b.out1{0..2};
    L := B::L;
  } else {
    BB := new Butterfly[W, E, M];
    // First butterfly
    bb := BB<'G>(in{0..2}, in{2..4}, twiddle{0..2});
    // Recurse
    BS := new Butterflies[N-1, W, E, M];
    butterflies := BS<'G>(in{4..4*N}, twiddle{2..2*N});

    assume BB::L == BS::L;
    L := BB::L;

    out{0..2} = bb.out0{0..2};
    out{2..4} = bb.out1{0..2};
    out{4..4*N} = butterflies.out{0..4*N-4};
  }
}

/// Butterfly module using existential parameters.
comp Butterfly[W, E, ?M=W-E-1]<'G: L>(
  in0[2]: ['G, 'G+1] W, // real and imaginary parts of input
  in1[2]: ['G, 'G+1] W,
  twiddle[2]: ['G, 'G+1] W // twiddle factor
) -> (
  out0[2]: ['G+L, 'G+L+1] W,
  out1[2]: ['G+L, 'G+L+1] W
) with {
  some L where L > 0;
} where
    W == E + M + 1,
    E > 1,
    M > 1
{
  // switches between the type of butterfly unit
  let T = 0;
  if T == 0 {
    // Fully combinational butterfly module
    t1 := new ComplexMult[W, E, M]<'G>(in1{0..2}, twiddle{0..2});
    O0 := new ComplexAdd[W, E, M]<'G>(in0{0..2}, t1.out{0..2});

    // multiply by twiddle
    O1 := new ComplexSub[W, E, M]<'G>(in0{0..2}, t1.out{0..2});

    // registers
    d00 := new Delay[W]<'G>(O0.out{0});
    d01 := new Delay[W]<'G>(O0.out{1});
    d10 := new Delay[W]<'G>(O1.out{0});
    d11 := new Delay[W]<'G>(O1.out{1});
    out0{0} = d00.out;
    out0{1} = d01.out;
    out1{0} = d10.out;
    out1{1} = d11.out;

    L := 1;
  }
}