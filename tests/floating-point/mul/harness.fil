import "fp-mul.fil";
import "primitives/math/float.fil";
import "primitives/flopoco/def.fil";

extern "fp-mult-nopipe.sv" {
  comp FP_Mult_NoPipe<'G: 1>(
       a: ['G, 'G+1] 32,
       b: ['G, 'G+1] 32,
  ) -> (
       exception: ['G, 'G+1] 1,
       overflow: ['G, 'G+1] 1,
       underflow: ['G, 'G+1] 1,
       res: ['G, 'G+1] 32,
  );
}

comp main<'G: 1>(
  go: interface['G],
   left: ['G, 'G+1] 32,
   right: ['G, 'G+1] 32,
) -> (
   out: ['G, 'G+1] 32,
   verilog_nopipe: ['G, 'G+1] 32,
   filament_lib: ['G, 'G+1] 32,
   flopoco: ['G+L_Flopoco, 'G+L_Flopoco+1] 32
) with {
  some L_Flopoco where L_Flopoco >= 0;
} {
  np := new FP_Mult_NoPipe<'G>(left, right);
  f := new FilFPMult<'G>(left, right);
  prim := new FMult[32, 8, 23]<'G>(left, right);
  
  // Flopoco Multiplication
  FPtoFLO1 := new InputIEEE[8, 23, 8, 23];
  FPtoFLO2 := new InputIEEE[8, 23, 8, 23];
  FLOMult := new FPMult[8, 23];
  FLOtoFP := new OutputIEEE[8, 23, 8, 23];

  left_flopoco := FPtoFLO1<'G>(left);
  right_flopoco := FPtoFLO2<'G>(right);
  flo_add := FLOMult<'G+FPtoFLO1::L>(left_flopoco.R, right_flopoco.R);
  out_fp := FLOtoFP<'G+FPtoFLO1::L+FLOMult::L>(flo_add.R);
  L_Flopoco := FPtoFLO1::L + FLOMult::L + FLOtoFP::L;
  flopoco = out_fp.R;

  verilog_nopipe = np.res;
  out = f.out;
  filament_lib = prim.out;
}
